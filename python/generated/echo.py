# @generated by roam-codegen
# DO NOT EDIT - regenerate with `cargo run -p roam-codegen`

from abc import ABC, abstractmethod
from typing import Protocol

METHOD_ID = {
    "echo": 0x3D66DD9EE36B4240,
    "reverse": 0x268246D3219503FB,
}

""" Simple echo service for conformance testing."""


class EchoClient(Protocol):
    """Client protocol for calling service methods."""

    def echo(self, message: str) -> str:
        """Echoes the message back."""
        ...

    def reverse(self, message: str) -> str:
        """Returns the message reversed."""
        ...


class EchoHandler(ABC):
    """Abstract base class for implementing the service."""

    @abstractmethod
    def echo(self, message: str) -> str:
        """Echoes the message back."""
        ...

    @abstractmethod
    def reverse(self, message: str) -> str:
        """Returns the message reversed."""
        ...


def create_echo_dispatcher(handler: EchoHandler):
    """Create a dispatcher function for the service."""

    def dispatch(method_id: int, payload: bytes) -> bytes:
        o = 0
        match method_id:
            case 0x3D66DD9EE36B4240:
                try:
                    message, o = decode_string(payload, o)
                    result = handler.echo(message)
                    return encode_result_ok(result, encode_string)
                except Exception as e:
                    return encode_invalid_payload_error()
            case 0x268246D3219503FB:
                try:
                    message, o = decode_string(payload, o)
                    result = handler.reverse(message)
                    return encode_result_ok(result, encode_string)
                except Exception as e:
                    return encode_invalid_payload_error()
            case _:
                return encode_unknown_method_error()

    return dispatch


# Runtime helper functions


def encode_varint(value: int) -> bytes:
    if value < 0:
        raise ValueError("negative varint")
    out = bytearray()
    while True:
        byte = value & 0x7F
        value >>= 7
        if value != 0:
            byte |= 0x80
        out.append(byte)
        if value == 0:
            break
    return bytes(out)


def decode_varint(buf: bytes, offset: int) -> tuple[int, int]:
    result = 0
    shift = 0
    i = offset
    while True:
        if i >= len(buf):
            raise ValueError("varint: eof")
        byte = buf[i]
        i += 1
        if shift >= 64:
            raise ValueError("varint: overflow")
        result |= (byte & 0x7F) << shift
        if (byte & 0x80) == 0:
            return result, i
        shift += 7


def encode_string(s: str) -> bytes:
    b = s.encode("utf-8")
    return encode_varint(len(b)) + b


def decode_string(buf: bytes, offset: int) -> tuple[str, int]:
    length, o = decode_varint(buf, offset)
    if o + length > len(buf):
        raise ValueError("string: length out of range")
    s = buf[o : o + length].decode("utf-8")
    return s, o + length


def encode_result_ok(value: str, encoder) -> bytes:
    out = encode_varint(0)  # Result::Ok
    out += encoder(value)
    return out


def encode_result_err(err: Exception) -> bytes:
    out = encode_varint(1)  # Result::Err
    out += encode_varint(0)  # RoamError::User
    out += encode_string(str(err))
    return out


def encode_unknown_method_error() -> bytes:
    out = encode_varint(1)  # Result::Err
    out += encode_varint(1)  # RoamError::UnknownMethod
    return out


def encode_invalid_payload_error() -> bytes:
    out = encode_varint(1)  # Result::Err
    out += encode_varint(2)  # RoamError::InvalidPayload
    return out
