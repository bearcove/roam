// @generated by roam-codegen
// DO NOT EDIT - regenerate with `cargo xtask codegen --typescript`

import type { MethodHandler, Connection, MessageTransport, DecodeResult } from "@bearcove/roam-core";
import {
  encodeResultOk, encodeResultErr, encodeInvalidPayload,
  concat, encodeVarint, decodeVarintNumber, decodeRpcResult,
  encodeBool, decodeBool,
  encodeU8, decodeU8, encodeI8, decodeI8,
  encodeU16, decodeU16, encodeI16, decodeI16,
  encodeU32, decodeU32, encodeI32, decodeI32,
  encodeU64, decodeU64, encodeI64, decodeI64,
  encodeF32, decodeF32, encodeF64, decodeF64,
  encodeString, decodeString,
  encodeBytes, decodeBytes,
  encodeOption, decodeOption,
  encodeVec, decodeVec,
  encodeTuple2, decodeTuple2, encodeTuple3, decodeTuple3,
  encodeEnumVariant, decodeEnumVariant,
} from "@bearcove/roam-core";
import type { Push, Pull, StreamId } from "@bearcove/roam-core";

export const METHOD_ID = {
  sum: 0xb11b6938d911345an,
  range: 0x082b800b771a1679n,
  pipe: 0x5310edf6c055f563n,
  stats: 0xae23eb3ec98852ecn,
} as const;

// Type definitions
export type SumRequest = [Pull<number>];
export type SumResponse = bigint;

export type RangeRequest = [number];
export type RangeResponse = Push<number>;

export type PipeRequest = [Pull<string>];
export type PipeResponse = Push<string>;

export type StatsRequest = [Pull<number>];
export type StatsResponse = [bigint, bigint, number];

// Caller interface for Streaming
export interface StreamingCaller {
  /**  Client pushes numbers, server returns their sum.

 Tests: client-to-server streaming (`Push<T>` → scalar return).
 r[impl streaming.client-to-server] - Client sends stream, server returns scalar. */
  sum(numbers: Push<number>): Promise<bigint>;
  /**  Client sends a count, server returns that many numbers.

 Tests: server-to-client streaming (scalar → `Pull<T>`).
 r[impl streaming.server-to-client] - Client sends scalar, server returns stream. */
  range(count: number): Promise<Pull<number>>;
  /**  Client pushes strings, server echoes each back.

 Tests: bidirectional streaming (`Push<T>` ↔ `Pull<T>`).
 r[impl streaming.bidirectional] - Both sides stream simultaneously. */
  pipe(input: Push<string>): Promise<Pull<string>>;
  /**  Client pushes numbers, server returns (sum, count, average).

 Tests: aggregating a stream into a compound result. */
  stats(numbers: Push<number>): Promise<[bigint, bigint, number]>;
}

// Client implementation for Streaming
export class StreamingClient<T extends MessageTransport = MessageTransport> implements StreamingCaller {
  private conn: Connection<T>;

  constructor(conn: Connection<T>) {
    this.conn = conn;
  }

  /**  Client pushes numbers, server returns their sum.

 Tests: client-to-server streaming (`Push<T>` → scalar return).
 r[impl streaming.client-to-server] - Client sends stream, server returns scalar. */
  async sum(numbers: Push<number>): Promise<bigint> {
    throw new Error("Not yet implemented: encoding/decoding for this method");
  }

  /**  Client sends a count, server returns that many numbers.

 Tests: server-to-client streaming (scalar → `Pull<T>`).
 r[impl streaming.server-to-client] - Client sends scalar, server returns stream. */
  async range(count: number): Promise<Pull<number>> {
    throw new Error("Not yet implemented: encoding/decoding for this method");
  }

  /**  Client pushes strings, server echoes each back.

 Tests: bidirectional streaming (`Push<T>` ↔ `Pull<T>`).
 r[impl streaming.bidirectional] - Both sides stream simultaneously. */
  async pipe(input: Push<string>): Promise<Pull<string>> {
    throw new Error("Not yet implemented: encoding/decoding for this method");
  }

  /**  Client pushes numbers, server returns (sum, count, average).

 Tests: aggregating a stream into a compound result. */
  async stats(numbers: Push<number>): Promise<[bigint, bigint, number]> {
    throw new Error("Not yet implemented: encoding/decoding for this method");
  }

}

// Handler interface for Streaming
export interface StreamingHandler {
  sum(numbers: Pull<number>): Promise<bigint> | bigint;
  range(count: number): Promise<Push<number>> | Push<number>;
  pipe(input: Pull<string>): Promise<Push<string>> | Push<string>;
  stats(numbers: Pull<number>): Promise<[bigint, bigint, number]> | [bigint, bigint, number];
}

// Method handlers for Streaming
export const streaming_methodHandlers = new Map<bigint, MethodHandler<StreamingHandler>>([
  [0xb11b6938d911345an, async (handler, payload) => {
    try {
      // TODO: implement encoding/decoding for streaming types
      return encodeResultErr(encodeInvalidPayload());
    } catch (e) {
      return encodeResultErr(encodeInvalidPayload());
    }
  }],
  [0x082b800b771a1679n, async (handler, payload) => {
    try {
      // TODO: implement encoding/decoding for streaming types
      return encodeResultErr(encodeInvalidPayload());
    } catch (e) {
      return encodeResultErr(encodeInvalidPayload());
    }
  }],
  [0x5310edf6c055f563n, async (handler, payload) => {
    try {
      // TODO: implement encoding/decoding for streaming types
      return encodeResultErr(encodeInvalidPayload());
    } catch (e) {
      return encodeResultErr(encodeInvalidPayload());
    }
  }],
  [0xae23eb3ec98852ecn, async (handler, payload) => {
    try {
      // TODO: implement encoding/decoding for streaming types
      return encodeResultErr(encodeInvalidPayload());
    } catch (e) {
      return encodeResultErr(encodeInvalidPayload());
    }
  }],
]);
