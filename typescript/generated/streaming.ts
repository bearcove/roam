// @generated by roam-codegen
// DO NOT EDIT - regenerate with `cargo xtask codegen --typescript`

import type { MethodHandler } from "@bearcove/roam-core";
import { encodeResultOk, encodeResultErr, encodeInvalidPayload } from "@bearcove/roam-core";
import { encodeString, decodeString } from "@bearcove/roam-core";
import type { Push, Pull, StreamId } from "@bearcove/roam-core";

export const METHOD_ID = {
  sum: 0x09e710c9cb34ef40n,
  range: 0x082b800b771a1679n,
  pipe: 0x92cdb59bb5df3977n,
  stats: 0xc416b4ee044521dcn,
} as const;

// Type definitions
export type SumRequest = [/* stream */ number];
export type SumResponse = bigint;

export type RangeRequest = [number];
export type RangeResponse = /* stream */ number;

export type PipeRequest = [/* stream */ string];
export type PipeResponse = /* stream */ string;

export type StatsRequest = [/* stream */ number];
export type StatsResponse = [bigint, bigint, number];

// Client interface for Streaming
export interface StreamingClient {
  /**  Client pushes numbers, server returns their sum.

 Tests: client-to-server streaming (`Push<T>` → scalar return).
 r[impl streaming.client-to-server] - Client sends stream, server returns scalar. */
  sum(numbers: Push<number>): Promise<bigint>;
  /**  Client sends a count, server returns that many numbers.

 Tests: server-to-client streaming (scalar → `Pull<T>`).
 r[impl streaming.server-to-client] - Client sends scalar, server returns stream. */
  range(count: number): Promise<Pull<number>>;
  /**  Client pushes strings, server echoes each back.

 Tests: bidirectional streaming (`Push<T>` ↔ `Pull<T>`).
 r[impl streaming.bidirectional] - Both sides stream simultaneously. */
  pipe(input: Push<string>): Promise<Pull<string>>;
  /**  Client pushes numbers, server returns (sum, count, average).

 Tests: aggregating a stream into a compound result. */
  stats(numbers: Push<number>): Promise<[bigint, bigint, number]>;
}

// Server handler interface for Streaming
export interface StreamingHandler {
  sum(numbers: Pull<number>): Promise<bigint> | bigint;
  range(count: number): Promise<Push<number>> | Push<number>;
  pipe(input: Pull<string>): Promise<Push<string>> | Push<string>;
  stats(numbers: Pull<number>): Promise<[bigint, bigint, number]> | [bigint, bigint, number];
}

// Method handlers for Streaming
export const streaming_methodHandlers = new Map<bigint, MethodHandler<StreamingHandler>>([
  [0x09e710c9cb34ef40n, async (handler, payload) => {
    try {
      // TODO: implement encoding/decoding for complex types
      return encodeResultErr(encodeInvalidPayload());
    } catch (e) {
      return encodeResultErr(encodeInvalidPayload());
    }
  }],
  [0x082b800b771a1679n, async (handler, payload) => {
    try {
      // TODO: implement encoding/decoding for complex types
      return encodeResultErr(encodeInvalidPayload());
    } catch (e) {
      return encodeResultErr(encodeInvalidPayload());
    }
  }],
  [0x92cdb59bb5df3977n, async (handler, payload) => {
    try {
      // TODO: implement encoding/decoding for complex types
      return encodeResultErr(encodeInvalidPayload());
    } catch (e) {
      return encodeResultErr(encodeInvalidPayload());
    }
  }],
  [0xc416b4ee044521dcn, async (handler, payload) => {
    try {
      // TODO: implement encoding/decoding for complex types
      return encodeResultErr(encodeInvalidPayload());
    } catch (e) {
      return encodeResultErr(encodeInvalidPayload());
    }
  }],
]);
