// @generated by roam-codegen
// DO NOT EDIT - regenerate with `cargo xtask codegen --typescript`

import type { MethodHandler, Connection, MessageTransport, DecodeResult } from "@bearcove/roam-core";
import {
  encodeResultOk, encodeResultErr, encodeInvalidPayload,
  concat, encodeVarint, decodeVarintNumber, decodeRpcResult,
  encodeBool, decodeBool,
  encodeU8, decodeU8, encodeI8, decodeI8,
  encodeU16, decodeU16, encodeI16, decodeI16,
  encodeU32, decodeU32, encodeI32, decodeI32,
  encodeU64, decodeU64, encodeI64, decodeI64,
  encodeF32, decodeF32, encodeF64, decodeF64,
  encodeString, decodeString,
  encodeBytes, decodeBytes,
  encodeOption, decodeOption,
  encodeVec, decodeVec,
  encodeTuple2, decodeTuple2, encodeTuple3, decodeTuple3,
  encodeEnumVariant, decodeEnumVariant,
} from "@bearcove/roam-core";
import { Push, Pull } from "@bearcove/roam-core";
import type { StreamId } from "@bearcove/roam-core";

export const METHOD_ID = {
  sum: 0xb11b6938d911345an,
  range: 0x082b800b771a1679n,
  pipe: 0x5310edf6c055f563n,
  stats: 0xae23eb3ec98852ecn,
} as const;

// Type definitions
export type SumRequest = [Pull<number>];
export type SumResponse = bigint;

export type RangeRequest = [number];
export type RangeResponse = Push<number>;

export type PipeRequest = [Pull<string>];
export type PipeResponse = Push<string>;

export type StatsRequest = [Pull<number>];
export type StatsResponse = [bigint, bigint, number];

// Caller interface for Streaming
export interface StreamingCaller {
  /**  Client pushes numbers, server returns their sum.

 Tests: client-to-server streaming (`Push<T>` → scalar return).
 r[impl streaming.client-to-server] - Client sends stream, server returns scalar. */
  sum(numbers: Push<number>): Promise<bigint>;
  /**  Client sends a count, server returns that many numbers.

 Tests: server-to-client streaming (scalar → `Pull<T>`).
 r[impl streaming.server-to-client] - Client sends scalar, server returns stream. */
  range(count: number): Promise<Pull<number>>;
  /**  Client pushes strings, server echoes each back.

 Tests: bidirectional streaming (`Push<T>` ↔ `Pull<T>`).
 r[impl streaming.bidirectional] - Both sides stream simultaneously. */
  pipe(input: Push<string>): Promise<Pull<string>>;
  /**  Client pushes numbers, server returns (sum, count, average).

 Tests: aggregating a stream into a compound result. */
  stats(numbers: Push<number>): Promise<[bigint, bigint, number]>;
}

// Client implementation for Streaming
export class StreamingClient<T extends MessageTransport = MessageTransport> implements StreamingCaller {
  private conn: Connection<T>;

  constructor(conn: Connection<T>) {
    this.conn = conn;
  }

  /**  Client pushes numbers, server returns their sum.

 Tests: client-to-server streaming (`Push<T>` → scalar return).
 r[impl streaming.client-to-server] - Client sends stream, server returns scalar. */
  async sum(numbers: Push<number>): Promise<bigint> {
    const payload = encodeU64(numbers.streamId);
    const response = await this.conn.call(0xb11b6938d911345an, payload);
    const buf = response;
    let offset = decodeRpcResult(buf, 0);
    const _result_r = decodeI64(buf, offset); const result = _result_r.value; offset = _result_r.next;
    return result;
  }

  /**  Client sends a count, server returns that many numbers.

 Tests: server-to-client streaming (scalar → `Pull<T>`).
 r[impl streaming.server-to-client] - Client sends scalar, server returns stream. */
  async range(count: number): Promise<Pull<number>> {
    const payload = encodeU32(count);
    const response = await this.conn.call(0x082b800b771a1679n, payload);
    const buf = response;
    let offset = decodeRpcResult(buf, 0);
    const _result_r = decodeU64(buf, offset); const result = { streamId: _result_r.value } as Pull<number>; offset = _result_r.next; /* TODO: create real Pull handle */
    return result;
  }

  /**  Client pushes strings, server echoes each back.

 Tests: bidirectional streaming (`Push<T>` ↔ `Pull<T>`).
 r[impl streaming.bidirectional] - Both sides stream simultaneously. */
  async pipe(input: Push<string>): Promise<Pull<string>> {
    const payload = encodeU64(input.streamId);
    const response = await this.conn.call(0x5310edf6c055f563n, payload);
    const buf = response;
    let offset = decodeRpcResult(buf, 0);
    const _result_r = decodeU64(buf, offset); const result = { streamId: _result_r.value } as Pull<string>; offset = _result_r.next; /* TODO: create real Pull handle */
    return result;
  }

  /**  Client pushes numbers, server returns (sum, count, average).

 Tests: aggregating a stream into a compound result. */
  async stats(numbers: Push<number>): Promise<[bigint, bigint, number]> {
    const payload = encodeU64(numbers.streamId);
    const response = await this.conn.call(0xae23eb3ec98852ecn, payload);
    const buf = response;
    let offset = decodeRpcResult(buf, 0);
    const _result_r = decodeTuple3(buf, offset, (buf, off) => decodeI64(buf, off), (buf, off) => decodeU64(buf, off), (buf, off) => decodeF64(buf, off)); const result = _result_r.value; offset = _result_r.next;
    return result;
  }

}

// Handler interface for Streaming
export interface StreamingHandler {
  sum(numbers: Pull<number>): Promise<bigint> | bigint;
  range(count: number): Promise<Push<number>> | Push<number>;
  pipe(input: Pull<string>): Promise<Push<string>> | Push<string>;
  stats(numbers: Pull<number>): Promise<[bigint, bigint, number]> | [bigint, bigint, number];
}

// Method handlers for Streaming
export const streaming_methodHandlers = new Map<bigint, MethodHandler<StreamingHandler>>([
  [0xb11b6938d911345an, async (handler, payload) => {
    try {
      const buf = payload;
      let offset = 0;
      const _numbers_r = decodeU64(buf, offset); const numbers = { streamId: _numbers_r.value } as Pull<number>; offset = _numbers_r.next; /* TODO: create real Pull handle */
      if (offset !== buf.length) throw new Error("args: trailing bytes");
      const result = await handler.sum(numbers);
      return encodeResultOk(encodeI64(result));
    } catch (e) {
      return encodeResultErr(encodeInvalidPayload());
    }
  }],
  [0x082b800b771a1679n, async (handler, payload) => {
    try {
      const buf = payload;
      let offset = 0;
      const _count_r = decodeU32(buf, offset); const count = _count_r.value; offset = _count_r.next;
      if (offset !== buf.length) throw new Error("args: trailing bytes");
      const result = await handler.range(count);
      return encodeResultOk(encodeU64(result.streamId));
    } catch (e) {
      return encodeResultErr(encodeInvalidPayload());
    }
  }],
  [0x5310edf6c055f563n, async (handler, payload) => {
    try {
      const buf = payload;
      let offset = 0;
      const _input_r = decodeU64(buf, offset); const input = { streamId: _input_r.value } as Pull<string>; offset = _input_r.next; /* TODO: create real Pull handle */
      if (offset !== buf.length) throw new Error("args: trailing bytes");
      const result = await handler.pipe(input);
      return encodeResultOk(encodeU64(result.streamId));
    } catch (e) {
      return encodeResultErr(encodeInvalidPayload());
    }
  }],
  [0xae23eb3ec98852ecn, async (handler, payload) => {
    try {
      const buf = payload;
      let offset = 0;
      const _numbers_r = decodeU64(buf, offset); const numbers = { streamId: _numbers_r.value } as Pull<number>; offset = _numbers_r.next; /* TODO: create real Pull handle */
      if (offset !== buf.length) throw new Error("args: trailing bytes");
      const result = await handler.stats(numbers);
      return encodeResultOk(concat(encodeI64(result[0]), encodeU64(result[1]), encodeF64(result[2])));
    } catch (e) {
      return encodeResultErr(encodeInvalidPayload());
    }
  }],
]);
