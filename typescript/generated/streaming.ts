// @generated by roam-codegen
// DO NOT EDIT - regenerate with `cargo xtask codegen --typescript`

import type {
  MethodHandler,
  Connection,
  MessageTransport,
  DecodeResult,
} from "@bearcove/roam-core";
import {
  encodeResultOk,
  encodeResultErr,
  encodeInvalidPayload,
  concat,
  encodeVarint,
  decodeVarintNumber,
  decodeRpcResult,
  encodeBool,
  decodeBool,
  encodeU8,
  decodeU8,
  encodeI8,
  decodeI8,
  encodeU16,
  decodeU16,
  encodeI16,
  decodeI16,
  encodeU32,
  decodeU32,
  encodeI32,
  decodeI32,
  encodeU64,
  decodeU64,
  encodeI64,
  decodeI64,
  encodeF32,
  decodeF32,
  encodeF64,
  decodeF64,
  encodeString,
  decodeString,
  encodeBytes,
  decodeBytes,
  encodeOption,
  decodeOption,
  encodeVec,
  decodeVec,
  encodeTuple2,
  decodeTuple2,
  encodeTuple3,
  decodeTuple3,
  encodeEnumVariant,
  decodeEnumVariant,
} from "@bearcove/roam-core";
import { Tx, Rx } from "@bearcove/roam-core";
import type { StreamId } from "@bearcove/roam-core";

export const METHOD_ID = {
  sum: 0x09e710c9cb34ef40n,
  range: 0x18001f01839e9728n,
  pipe: 0xf67367cc79e4ac35n,
  stats: 0xc416b4ee044521dcn,
} as const;

// Type definitions
export type SumRequest = [Tx<number>];
export type SumResponse = bigint;

export type RangeRequest = [
  number, // count
  Rx<number>, // output
];
export type RangeResponse = void;

export type PipeRequest = [
  Tx<string>, // input
  Rx<string>, // output
];
export type PipeResponse = void;

export type StatsRequest = [Tx<number>];
export type StatsResponse = [bigint, bigint, number];

// Caller interface for Streaming
export interface StreamingCaller {
  /**  Client sends numbers, server returns their sum.

 Tests: client-to-server streaming (`Tx<T>` → scalar return).
 r[impl streaming.client-to-server] - Client sends channel, server returns scalar. */
  sum(numbers: Tx<number>): Promise<bigint>;
  /**  Client sends a count, server streams that many numbers back.

 Tests: server-to-client streaming (scalar → `Rx<T>` as output parameter).
 r[impl streaming.server-to-client] - Client sends scalar, server returns channel. */
  range(count: number, output: Rx<number>): Promise<void>;
  /**  Client sends strings, server echoes each back.

 Tests: bidirectional streaming (`Tx<T>` ↔ `Rx<T>`).
 r[impl streaming.bidirectional] - Both sides stream simultaneously. */
  pipe(input: Tx<string>, output: Rx<string>): Promise<void>;
  /**  Client sends numbers, server returns (sum, count, average).

 Tests: aggregating a channel into a compound result. */
  stats(numbers: Tx<number>): Promise<[bigint, bigint, number]>;
}

// Client implementation for Streaming
export class StreamingClient<
  T extends MessageTransport = MessageTransport,
> implements StreamingCaller {
  private conn: Connection<T>;

  constructor(conn: Connection<T>) {
    this.conn = conn;
  }

  /**  Client sends numbers, server returns their sum.

 Tests: client-to-server streaming (`Tx<T>` → scalar return).
 r[impl streaming.client-to-server] - Client sends channel, server returns scalar. */
  async sum(numbers: Tx<number>): Promise<bigint> {
    const payload = encodeU64(numbers.streamId);
    const response = await this.conn.call(0x09e710c9cb34ef40n, payload);
    const buf = response;
    let offset = decodeRpcResult(buf, 0);
    const _result_r = decodeI64(buf, offset);
    const result = _result_r.value;
    offset = _result_r.next;
    return result;
  }

  /**  Client sends a count, server streams that many numbers back.

 Tests: server-to-client streaming (scalar → `Rx<T>` as output parameter).
 r[impl streaming.server-to-client] - Client sends scalar, server returns channel. */
  async range(count: number, output: Rx<number>): Promise<void> {
    const payload = concat(encodeU32(count), encodeU64(output.streamId));
    const response = await this.conn.call(0x18001f01839e9728n, payload);
    const buf = response;
    let offset = decodeRpcResult(buf, 0);
    const result = undefined;
    return result;
  }

  /**  Client sends strings, server echoes each back.

 Tests: bidirectional streaming (`Tx<T>` ↔ `Rx<T>`).
 r[impl streaming.bidirectional] - Both sides stream simultaneously. */
  async pipe(input: Tx<string>, output: Rx<string>): Promise<void> {
    const payload = concat(encodeU64(input.streamId), encodeU64(output.streamId));
    const response = await this.conn.call(0xf67367cc79e4ac35n, payload);
    const buf = response;
    let offset = decodeRpcResult(buf, 0);
    const result = undefined;
    return result;
  }

  /**  Client sends numbers, server returns (sum, count, average).

 Tests: aggregating a channel into a compound result. */
  async stats(numbers: Tx<number>): Promise<[bigint, bigint, number]> {
    const payload = encodeU64(numbers.streamId);
    const response = await this.conn.call(0xc416b4ee044521dcn, payload);
    const buf = response;
    let offset = decodeRpcResult(buf, 0);
    const _result_r = decodeTuple3(
      buf,
      offset,
      (buf, off) => decodeI64(buf, off),
      (buf, off) => decodeU64(buf, off),
      (buf, off) => decodeF64(buf, off),
    );
    const result = _result_r.value;
    offset = _result_r.next;
    return result;
  }
}

// Handler interface for Streaming
export interface StreamingHandler {
  sum(numbers: Rx<number>): Promise<bigint> | bigint;
  range(count: number, output: Tx<number>): Promise<void> | void;
  pipe(input: Rx<string>, output: Tx<string>): Promise<void> | void;
  stats(numbers: Rx<number>): Promise<[bigint, bigint, number]> | [bigint, bigint, number];
}

// Method handlers for Streaming
export const streaming_methodHandlers = new Map<bigint, MethodHandler<StreamingHandler>>([
  [
    0x09e710c9cb34ef40n,
    async (handler, payload) => {
      try {
        const buf = payload;
        let offset = 0;
        const _numbers_r = decodeU64(buf, offset);
        const numbers = { streamId: _numbers_r.value } as Rx<number>;
        offset = _numbers_r.next; /* TODO: create real Rx handle */
        if (offset !== buf.length) throw new Error("args: trailing bytes");
        const result = await handler.sum(numbers);
        return encodeResultOk(encodeI64(result));
      } catch (e) {
        return encodeResultErr(encodeInvalidPayload());
      }
    },
  ],
  [
    0x18001f01839e9728n,
    async (handler, payload) => {
      try {
        const buf = payload;
        let offset = 0;
        const _count_r = decodeU32(buf, offset);
        const count = _count_r.value;
        offset = _count_r.next;
        const _output_r = decodeU64(buf, offset);
        const output = { streamId: _output_r.value } as Tx<number>;
        offset = _output_r.next; /* TODO: create real Tx handle */
        if (offset !== buf.length) throw new Error("args: trailing bytes");
        const result = await handler.range(count, output);
        return encodeResultOk(new Uint8Array(0));
      } catch (e) {
        return encodeResultErr(encodeInvalidPayload());
      }
    },
  ],
  [
    0xf67367cc79e4ac35n,
    async (handler, payload) => {
      try {
        const buf = payload;
        let offset = 0;
        const _input_r = decodeU64(buf, offset);
        const input = { streamId: _input_r.value } as Rx<string>;
        offset = _input_r.next; /* TODO: create real Rx handle */
        const _output_r = decodeU64(buf, offset);
        const output = { streamId: _output_r.value } as Tx<string>;
        offset = _output_r.next; /* TODO: create real Tx handle */
        if (offset !== buf.length) throw new Error("args: trailing bytes");
        const result = await handler.pipe(input, output);
        return encodeResultOk(new Uint8Array(0));
      } catch (e) {
        return encodeResultErr(encodeInvalidPayload());
      }
    },
  ],
  [
    0xc416b4ee044521dcn,
    async (handler, payload) => {
      try {
        const buf = payload;
        let offset = 0;
        const _numbers_r = decodeU64(buf, offset);
        const numbers = { streamId: _numbers_r.value } as Rx<number>;
        offset = _numbers_r.next; /* TODO: create real Rx handle */
        if (offset !== buf.length) throw new Error("args: trailing bytes");
        const result = await handler.stats(numbers);
        return encodeResultOk(
          concat(encodeI64(result[0]), encodeU64(result[1]), encodeF64(result[2])),
        );
      } catch (e) {
        return encodeResultErr(encodeInvalidPayload());
      }
    },
  ],
]);
