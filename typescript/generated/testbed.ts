// @generated by roam-codegen
// DO NOT EDIT - regenerate with `cargo xtask codegen --typescript`

import type { MethodHandler, Connection, MessageTransport, DecodeResult } from "@bearcove/roam-core";
import {
  encodeResultOk, encodeResultErr, encodeInvalidPayload,
  concat, encodeVarint, decodeVarintNumber, decodeRpcResult,
  encodeBool, decodeBool,
  encodeU8, decodeU8, encodeI8, decodeI8,
  encodeU16, decodeU16, encodeI16, decodeI16,
  encodeU32, decodeU32, encodeI32, decodeI32,
  encodeU64, decodeU64, encodeI64, decodeI64,
  encodeF32, decodeF32, encodeF64, decodeF64,
  encodeString, decodeString,
  encodeBytes, decodeBytes,
  encodeOption, decodeOption,
  encodeVec, decodeVec,
  encodeTuple2, decodeTuple2, encodeTuple3, decodeTuple3,
  encodeEnumVariant, decodeEnumVariant,
} from "@bearcove/roam-core";
import { Tx, Rx } from "@bearcove/roam-core";
import type { StreamId } from "@bearcove/roam-core";

export const METHOD_ID = {
  echo: 0x9aabc4ba61fd5df3n,
  reverse: 0xcba154600f640175n,
  sum: 0x855b3a25d97bfefdn,
  generate: 0x54d2273d8cdb9c38n,
  transform: 0x5d9895604eb18b19n,
  echoPoint: 0x453fa9bf6932528cn,
  createPerson: 0x3dd231f57b1bca21n,
  rectangleArea: 0xba75c48683f1d9e6n,
  parseColor: 0xe285f31c6dfffbfcn,
  shapeArea: 0x6e706354167c00c2n,
  createCanvas: 0xa914982e7d3c7b55n,
  processMessage: 0xed1dc0c625889d30n,
  getPoints: 0x5c8707f5ae4ccbccn,
  swapPair: 0xacd19a29fe0d470cn,
} as const;

// Named type definitions
export interface Point {
  x: number;
  y: number;
}

export interface Person {
  name: string;
  age: number;
  email: string | null;
}

export interface Rectangle {
  top_left: Point;
  bottom_right: Point;
  label: string | null;
}

export type Color =
  | { tag: 'Red' }
  | { tag: 'Green' }
  | { tag: 'Blue' };

export type Shape =
  | { tag: 'Circle'; radius: number }
  | { tag: 'Rectangle'; width: number; height: number }
  | { tag: 'Point' };

export interface Canvas {
  name: string;
  shapes: Shape[];
  background: Color;
}

export type Message =
  | { tag: 'Text'; value: string }
  | { tag: 'Number'; value: bigint }
  | { tag: 'Data'; value: Uint8Array };

// Type definitions
export type EchoRequest = [string];
export type EchoResponse = string;

export type ReverseRequest = [string];
export type ReverseResponse = string;

export type SumRequest = [Rx<number>];
export type SumResponse = bigint;

export type GenerateRequest = [
  number, // count
  Tx<number>, // output
];
export type GenerateResponse = void;

export type TransformRequest = [
  Rx<string>, // input
  Tx<string>, // output
];
export type TransformResponse = void;

export type EchoPointRequest = [Point];
export type EchoPointResponse = Point;

export type CreatePersonRequest = [
  string, // name
  number, // age
  string | null, // email
];
export type CreatePersonResponse = Person;

export type RectangleAreaRequest = [Rectangle];
export type RectangleAreaResponse = number;

export type ParseColorRequest = [string];
export type ParseColorResponse = Color | null;

export type ShapeAreaRequest = [Shape];
export type ShapeAreaResponse = number;

export type CreateCanvasRequest = [
  string, // name
  Shape[], // shapes
  Color, // background
];
export type CreateCanvasResponse = Canvas;

export type ProcessMessageRequest = [Message];
export type ProcessMessageResponse = Message;

export type GetPointsRequest = [number];
export type GetPointsResponse = Point[];

export type SwapPairRequest = [{ 0: number; 1: string }];
export type SwapPairResponse = { 0: string; 1: number };

// Caller interface for Testbed
export interface TestbedCaller {
  /**  Echoes the message back. */
  echo(message: string): Promise<string>;
  /**  Returns the message reversed. */
  reverse(message: string): Promise<string>;
  /**  Client sends numbers, server returns their sum.

 Tests: client→server streaming. Server receives via `Rx<T>`, returns scalar. */
  sum(numbers: Rx<number>): Promise<bigint>;
  /**  Server streams numbers back to client.

 Tests: server→client streaming. Server sends via `Tx<T>`. */
  generate(count: number, output: Tx<number>): Promise<void>;
  /**  Bidirectional: client sends strings, server echoes each back.

 Tests: bidirectional streaming. Server receives via `Rx<T>`, sends via `Tx<T>`. */
  transform(input: Rx<string>, output: Tx<string>): Promise<void>;
  /**  Echo a point back. */
  echoPoint(point: Point): Promise<Point>;
  /**  Create a person and return it. */
  createPerson(name: string, age: number, email: string | null): Promise<Person>;
  /**  Calculate the area of a rectangle. */
  rectangleArea(rect: Rectangle): Promise<number>;
  /**  Get a color by name. */
  parseColor(name: string): Promise<Color | null>;
  /**  Calculate the area of a shape. */
  shapeArea(shape: Shape): Promise<number>;
  /**  Create a canvas with given shapes. */
  createCanvas(name: string, shapes: Shape[], background: Color): Promise<Canvas>;
  /**  Process a message and return a response. */
  processMessage(msg: Message): Promise<Message>;
  /**  Return multiple points. */
  getPoints(count: number): Promise<Point[]>;
  /**  Test tuple types. */
  swapPair(pair: { 0: number; 1: string }): Promise<{ 0: string; 1: number }>;
}

// Client implementation for Testbed
export class TestbedClient<T extends MessageTransport = MessageTransport> implements TestbedCaller {
  private conn: Connection<T>;

  constructor(conn: Connection<T>) {
    this.conn = conn;
  }

  /**  Echoes the message back. */
  async echo(message: string): Promise<string> {
    const payload = encodeString(message);
    const response = await this.conn.call(0x9aabc4ba61fd5df3n, payload);
    const buf = response;
    let offset = decodeRpcResult(buf, 0);
    const _result_r = decodeString(buf, offset); const result = _result_r.value; offset = _result_r.next;
    return result;
  }

  /**  Returns the message reversed. */
  async reverse(message: string): Promise<string> {
    const payload = encodeString(message);
    const response = await this.conn.call(0xcba154600f640175n, payload);
    const buf = response;
    let offset = decodeRpcResult(buf, 0);
    const _result_r = decodeString(buf, offset); const result = _result_r.value; offset = _result_r.next;
    return result;
  }

  /**  Client sends numbers, server returns their sum.

 Tests: client→server streaming. Server receives via `Rx<T>`, returns scalar. */
  async sum(numbers: Rx<number>): Promise<bigint> {
    const payload = encodeU64(numbers.streamId);
    const response = await this.conn.call(0x855b3a25d97bfefdn, payload);
    const buf = response;
    let offset = decodeRpcResult(buf, 0);
    const _result_r = decodeI64(buf, offset); const result = _result_r.value; offset = _result_r.next;
    return result;
  }

  /**  Server streams numbers back to client.

 Tests: server→client streaming. Server sends via `Tx<T>`. */
  async generate(count: number, output: Tx<number>): Promise<void> {
    const payload = concat(encodeU32(count), encodeU64(output.streamId));
    const response = await this.conn.call(0x54d2273d8cdb9c38n, payload);
    const buf = response;
    let offset = decodeRpcResult(buf, 0);
    const result = undefined;
    return result;
  }

  /**  Bidirectional: client sends strings, server echoes each back.

 Tests: bidirectional streaming. Server receives via `Rx<T>`, sends via `Tx<T>`. */
  async transform(input: Rx<string>, output: Tx<string>): Promise<void> {
    const payload = concat(encodeU64(input.streamId), encodeU64(output.streamId));
    const response = await this.conn.call(0x5d9895604eb18b19n, payload);
    const buf = response;
    let offset = decodeRpcResult(buf, 0);
    const result = undefined;
    return result;
  }

  /**  Echo a point back. */
  async echoPoint(point: Point): Promise<Point> {
    const payload = concat(encodeI32(point.x), encodeI32(point.y));
    const response = await this.conn.call(0x453fa9bf6932528cn, payload);
    const buf = response;
    let offset = decodeRpcResult(buf, 0);
    const _result_f0_r = decodeI32(buf, offset); const result_f0 = _result_f0_r.value; offset = _result_f0_r.next;
const _result_f1_r = decodeI32(buf, offset); const result_f1 = _result_f1_r.value; offset = _result_f1_r.next;
const result = { x: result_f0, y: result_f1 };
    return result;
  }

  /**  Create a person and return it. */
  async createPerson(name: string, age: number, email: string | null): Promise<Person> {
    const payload = concat(encodeString(name), encodeU8(age), encodeOption(email, (v) => encodeString(v)));
    const response = await this.conn.call(0x3dd231f57b1bca21n, payload);
    const buf = response;
    let offset = decodeRpcResult(buf, 0);
    const _result_f0_r = decodeString(buf, offset); const result_f0 = _result_f0_r.value; offset = _result_f0_r.next;
const _result_f1_r = decodeU8(buf, offset); const result_f1 = _result_f1_r.value; offset = _result_f1_r.next;
const _result_f2_r = decodeOption(buf, offset, (buf, off) => decodeString(buf, off)); const result_f2 = _result_f2_r.value; offset = _result_f2_r.next;
const result = { name: result_f0, age: result_f1, email: result_f2 };
    return result;
  }

  /**  Calculate the area of a rectangle. */
  async rectangleArea(rect: Rectangle): Promise<number> {
    const payload = concat(concat(encodeI32(rect.top_left.x), encodeI32(rect.top_left.y)), concat(encodeI32(rect.bottom_right.x), encodeI32(rect.bottom_right.y)), encodeOption(rect.label, (v) => encodeString(v)));
    const response = await this.conn.call(0xba75c48683f1d9e6n, payload);
    const buf = response;
    let offset = decodeRpcResult(buf, 0);
    const _result_r = decodeF64(buf, offset); const result = _result_r.value; offset = _result_r.next;
    return result;
  }

  /**  Get a color by name. */
  async parseColor(name: string): Promise<Color | null> {
    const payload = encodeString(name);
    const response = await this.conn.call(0xe285f31c6dfffbfcn, payload);
    const buf = response;
    let offset = decodeRpcResult(buf, 0);
    const _result_r = decodeOption(buf, offset, (buf: Uint8Array, off: number): DecodeResult<any> => { let o = off;
  const disc = decodeEnumVariant(buf, o); o = disc.next;
  switch (disc.value) {
    case 0: return { value: { tag: 'Red' }, next: o };
    case 1: return { value: { tag: 'Green' }, next: o };
    case 2: return { value: { tag: 'Blue' }, next: o };
    default: throw new Error(`unknown enum variant: ${disc.value}`);
  }
}); const result = _result_r.value; offset = _result_r.next;
    return result;
  }

  /**  Calculate the area of a shape. */
  async shapeArea(shape: Shape): Promise<number> {
    const payload = (() => { switch (shape.tag) {
      case 'Circle': return concat(encodeEnumVariant(0), encodeF64(shape.radius));
      case 'Rectangle': return concat(encodeEnumVariant(1), encodeF64(shape.width), encodeF64(shape.height));
      case 'Point': return encodeEnumVariant(2);
      default: throw new Error('unknown enum variant'); } })();
    const response = await this.conn.call(0x6e706354167c00c2n, payload);
    const buf = response;
    let offset = decodeRpcResult(buf, 0);
    const _result_r = decodeF64(buf, offset); const result = _result_r.value; offset = _result_r.next;
    return result;
  }

  /**  Create a canvas with given shapes. */
  async createCanvas(name: string, shapes: Shape[], background: Color): Promise<Canvas> {
    const payload = concat(encodeString(name), encodeVec(shapes, (item) => (() => { switch (item.tag) {
      case 'Circle': return concat(encodeEnumVariant(0), encodeF64(item.radius));
      case 'Rectangle': return concat(encodeEnumVariant(1), encodeF64(item.width), encodeF64(item.height));
      case 'Point': return encodeEnumVariant(2);
      default: throw new Error('unknown enum variant'); } })()), (() => { switch (background.tag) {
      case 'Red': return encodeEnumVariant(0);
      case 'Green': return encodeEnumVariant(1);
      case 'Blue': return encodeEnumVariant(2);
      default: throw new Error('unknown enum variant'); } })());
    const response = await this.conn.call(0xa914982e7d3c7b55n, payload);
    const buf = response;
    let offset = decodeRpcResult(buf, 0);
    const _result_f0_r = decodeString(buf, offset); const result_f0 = _result_f0_r.value; offset = _result_f0_r.next;
const _result_f1_r = decodeVec(buf, offset, (buf: Uint8Array, off: number): DecodeResult<any> => { let o = off;
  const disc = decodeEnumVariant(buf, o); o = disc.next;
  switch (disc.value) {
    case 0: {
      const _f0_r = decodeF64(buf, o); const f0 = _f0_r.value; o = _f0_r.next;
      return { value: { tag: 'Circle', radius: f0 }, next: o };
    }
    case 1: {
      const _f0_r = decodeF64(buf, o); const f0 = _f0_r.value; o = _f0_r.next;
      const _f1_r = decodeF64(buf, o); const f1 = _f1_r.value; o = _f1_r.next;
      return { value: { tag: 'Rectangle', width: f0, height: f1 }, next: o };
    }
    case 2: return { value: { tag: 'Point' }, next: o };
    default: throw new Error(`unknown enum variant: ${disc.value}`);
  }
}); const result_f1 = _result_f1_r.value; offset = _result_f1_r.next;
const _result_f2_disc = decodeEnumVariant(buf, offset); offset = _result_f2_disc.next;
let result_f2: Color;
switch (_result_f2_disc.value) {
  case 0: {
    result_f2 = { tag: 'Red' };
    break;
  }
  case 1: {
    result_f2 = { tag: 'Green' };
    break;
  }
  case 2: {
    result_f2 = { tag: 'Blue' };
    break;
  }
  default: throw new Error(`unknown enum variant ${_result_f2_disc.value}`);
}
const result = { name: result_f0, shapes: result_f1, background: result_f2 };
    return result;
  }

  /**  Process a message and return a response. */
  async processMessage(msg: Message): Promise<Message> {
    const payload = (() => { switch (msg.tag) {
      case 'Text': return concat(encodeEnumVariant(0), encodeString(msg.value));
      case 'Number': return concat(encodeEnumVariant(1), encodeI64(msg.value));
      case 'Data': return concat(encodeEnumVariant(2), encodeBytes(msg.value));
      default: throw new Error('unknown enum variant'); } })();
    const response = await this.conn.call(0xed1dc0c625889d30n, payload);
    const buf = response;
    let offset = decodeRpcResult(buf, 0);
    const _result_disc = decodeEnumVariant(buf, offset); offset = _result_disc.next;
let result: Message;
switch (_result_disc.value) {
  case 0: {
    const _result_inner_r = decodeString(buf, offset); const result_inner = _result_inner_r.value; offset = _result_inner_r.next;
    result = { tag: 'Text', value: result_inner };
    break;
  }
  case 1: {
    const _result_inner_r = decodeI64(buf, offset); const result_inner = _result_inner_r.value; offset = _result_inner_r.next;
    result = { tag: 'Number', value: result_inner };
    break;
  }
  case 2: {
    const _result_inner_r = decodeBytes(buf, offset); const result_inner = _result_inner_r.value; offset = _result_inner_r.next;
    result = { tag: 'Data', value: result_inner };
    break;
  }
  default: throw new Error(`unknown enum variant ${_result_disc.value}`);
}
    return result;
  }

  /**  Return multiple points. */
  async getPoints(count: number): Promise<Point[]> {
    const payload = encodeU32(count);
    const response = await this.conn.call(0x5c8707f5ae4ccbccn, payload);
    const buf = response;
    let offset = decodeRpcResult(buf, 0);
    const _result_r = decodeVec(buf, offset, (buf: Uint8Array, off: number) => { let o = off;
  const _f0_r = decodeI32(buf, o); const f0 = _f0_r.value; o = _f0_r.next;
  const _f1_r = decodeI32(buf, o); const f1 = _f1_r.value; o = _f1_r.next;
  return { value: { x: f0, y: f1 }, next: o };
}); const result = _result_r.value; offset = _result_r.next;
    return result;
  }

  /**  Test tuple types. */
  async swapPair(pair: { 0: number; 1: string }): Promise<{ 0: string; 1: number }> {
    const payload = concat(encodeI32(pair[0]), encodeString(pair[1]));
    const response = await this.conn.call(0xacd19a29fe0d470cn, payload);
    const buf = response;
    let offset = decodeRpcResult(buf, 0);
    const _result_f0_r = decodeString(buf, offset); const result_f0 = _result_f0_r.value; offset = _result_f0_r.next;
const _result_f1_r = decodeI32(buf, offset); const result_f1 = _result_f1_r.value; offset = _result_f1_r.next;
const result = { 0: result_f0, 1: result_f1 };
    return result;
  }

}

// Handler interface for Testbed
export interface TestbedHandler {
  echo(message: string): Promise<string> | string;
  reverse(message: string): Promise<string> | string;
  sum(numbers: Rx<number>): Promise<bigint> | bigint;
  generate(count: number, output: Tx<number>): Promise<void> | void;
  transform(input: Rx<string>, output: Tx<string>): Promise<void> | void;
  echoPoint(point: Point): Promise<Point> | Point;
  createPerson(name: string, age: number, email: string | null): Promise<Person> | Person;
  rectangleArea(rect: Rectangle): Promise<number> | number;
  parseColor(name: string): Promise<Color | null> | Color | null;
  shapeArea(shape: Shape): Promise<number> | number;
  createCanvas(name: string, shapes: Shape[], background: Color): Promise<Canvas> | Canvas;
  processMessage(msg: Message): Promise<Message> | Message;
  getPoints(count: number): Promise<Point[]> | Point[];
  swapPair(pair: { 0: number; 1: string }): Promise<{ 0: string; 1: number }> | { 0: string; 1: number };
}

// Method handlers for Testbed
export const testbed_methodHandlers = new Map<bigint, MethodHandler<TestbedHandler>>([
  [0x9aabc4ba61fd5df3n, async (handler, payload) => {
    try {
      const buf = payload;
      let offset = 0;
      const _message_r = decodeString(buf, offset); const message = _message_r.value; offset = _message_r.next;
      if (offset !== buf.length) throw new Error("args: trailing bytes");
      const result = await handler.echo(message);
      return encodeResultOk(encodeString(result));
    } catch (e) {
      return encodeResultErr(encodeInvalidPayload());
    }
  }],
  [0xcba154600f640175n, async (handler, payload) => {
    try {
      const buf = payload;
      let offset = 0;
      const _message_r = decodeString(buf, offset); const message = _message_r.value; offset = _message_r.next;
      if (offset !== buf.length) throw new Error("args: trailing bytes");
      const result = await handler.reverse(message);
      return encodeResultOk(encodeString(result));
    } catch (e) {
      return encodeResultErr(encodeInvalidPayload());
    }
  }],
  [0x855b3a25d97bfefdn, async (handler, payload) => {
    try {
      const buf = payload;
      let offset = 0;
      const _numbers_r = decodeU64(buf, offset); const numbers = { streamId: _numbers_r.value } as Rx<number>; offset = _numbers_r.next; /* TODO: create real Rx handle */
      if (offset !== buf.length) throw new Error("args: trailing bytes");
      const result = await handler.sum(numbers);
      return encodeResultOk(encodeI64(result));
    } catch (e) {
      return encodeResultErr(encodeInvalidPayload());
    }
  }],
  [0x54d2273d8cdb9c38n, async (handler, payload) => {
    try {
      const buf = payload;
      let offset = 0;
      const _count_r = decodeU32(buf, offset); const count = _count_r.value; offset = _count_r.next;
      const _output_r = decodeU64(buf, offset); const output = { streamId: _output_r.value } as Tx<number>; offset = _output_r.next; /* TODO: create real Tx handle */
      if (offset !== buf.length) throw new Error("args: trailing bytes");
      const result = await handler.generate(count, output);
      return encodeResultOk(new Uint8Array(0));
    } catch (e) {
      return encodeResultErr(encodeInvalidPayload());
    }
  }],
  [0x5d9895604eb18b19n, async (handler, payload) => {
    try {
      const buf = payload;
      let offset = 0;
      const _input_r = decodeU64(buf, offset); const input = { streamId: _input_r.value } as Rx<string>; offset = _input_r.next; /* TODO: create real Rx handle */
      const _output_r = decodeU64(buf, offset); const output = { streamId: _output_r.value } as Tx<string>; offset = _output_r.next; /* TODO: create real Tx handle */
      if (offset !== buf.length) throw new Error("args: trailing bytes");
      const result = await handler.transform(input, output);
      return encodeResultOk(new Uint8Array(0));
    } catch (e) {
      return encodeResultErr(encodeInvalidPayload());
    }
  }],
  [0x453fa9bf6932528cn, async (handler, payload) => {
    try {
      const buf = payload;
      let offset = 0;
      const _point_f0_r = decodeI32(buf, offset); const point_f0 = _point_f0_r.value; offset = _point_f0_r.next;
const _point_f1_r = decodeI32(buf, offset); const point_f1 = _point_f1_r.value; offset = _point_f1_r.next;
const point = { x: point_f0, y: point_f1 };
      if (offset !== buf.length) throw new Error("args: trailing bytes");
      const result = await handler.echoPoint(point);
      return encodeResultOk(concat(encodeI32(result.x), encodeI32(result.y)));
    } catch (e) {
      return encodeResultErr(encodeInvalidPayload());
    }
  }],
  [0x3dd231f57b1bca21n, async (handler, payload) => {
    try {
      const buf = payload;
      let offset = 0;
      const _name_r = decodeString(buf, offset); const name = _name_r.value; offset = _name_r.next;
      const _age_r = decodeU8(buf, offset); const age = _age_r.value; offset = _age_r.next;
      const _email_r = decodeOption(buf, offset, (buf, off) => decodeString(buf, off)); const email = _email_r.value; offset = _email_r.next;
      if (offset !== buf.length) throw new Error("args: trailing bytes");
      const result = await handler.createPerson(name, age, email);
      return encodeResultOk(concat(encodeString(result.name), encodeU8(result.age), encodeOption(result.email, (v) => encodeString(v))));
    } catch (e) {
      return encodeResultErr(encodeInvalidPayload());
    }
  }],
  [0xba75c48683f1d9e6n, async (handler, payload) => {
    try {
      const buf = payload;
      let offset = 0;
      const _rect_f0_f0_r = decodeI32(buf, offset); const rect_f0_f0 = _rect_f0_f0_r.value; offset = _rect_f0_f0_r.next;
const _rect_f0_f1_r = decodeI32(buf, offset); const rect_f0_f1 = _rect_f0_f1_r.value; offset = _rect_f0_f1_r.next;
const rect_f0 = { x: rect_f0_f0, y: rect_f0_f1 };
const _rect_f1_f0_r = decodeI32(buf, offset); const rect_f1_f0 = _rect_f1_f0_r.value; offset = _rect_f1_f0_r.next;
const _rect_f1_f1_r = decodeI32(buf, offset); const rect_f1_f1 = _rect_f1_f1_r.value; offset = _rect_f1_f1_r.next;
const rect_f1 = { x: rect_f1_f0, y: rect_f1_f1 };
const _rect_f2_r = decodeOption(buf, offset, (buf, off) => decodeString(buf, off)); const rect_f2 = _rect_f2_r.value; offset = _rect_f2_r.next;
const rect = { top_left: rect_f0, bottom_right: rect_f1, label: rect_f2 };
      if (offset !== buf.length) throw new Error("args: trailing bytes");
      const result = await handler.rectangleArea(rect);
      return encodeResultOk(encodeF64(result));
    } catch (e) {
      return encodeResultErr(encodeInvalidPayload());
    }
  }],
  [0xe285f31c6dfffbfcn, async (handler, payload) => {
    try {
      const buf = payload;
      let offset = 0;
      const _name_r = decodeString(buf, offset); const name = _name_r.value; offset = _name_r.next;
      if (offset !== buf.length) throw new Error("args: trailing bytes");
      const result = await handler.parseColor(name);
      return encodeResultOk(encodeOption(result, (v) => (() => { switch (v.tag) {
      case 'Red': return encodeEnumVariant(0);
      case 'Green': return encodeEnumVariant(1);
      case 'Blue': return encodeEnumVariant(2);
      default: throw new Error('unknown enum variant'); } })()));
    } catch (e) {
      return encodeResultErr(encodeInvalidPayload());
    }
  }],
  [0x6e706354167c00c2n, async (handler, payload) => {
    try {
      const buf = payload;
      let offset = 0;
      const _shape_disc = decodeEnumVariant(buf, offset); offset = _shape_disc.next;
let shape: Shape;
switch (_shape_disc.value) {
  case 0: {
    const _shape_f0_r = decodeF64(buf, offset); const shape_f0 = _shape_f0_r.value; offset = _shape_f0_r.next;
    shape = { tag: 'Circle', radius: shape_f0 };
    break;
  }
  case 1: {
    const _shape_f0_r = decodeF64(buf, offset); const shape_f0 = _shape_f0_r.value; offset = _shape_f0_r.next;
    const _shape_f1_r = decodeF64(buf, offset); const shape_f1 = _shape_f1_r.value; offset = _shape_f1_r.next;
    shape = { tag: 'Rectangle', width: shape_f0, height: shape_f1 };
    break;
  }
  case 2: {
    shape = { tag: 'Point' };
    break;
  }
  default: throw new Error(`unknown enum variant ${_shape_disc.value}`);
}
      if (offset !== buf.length) throw new Error("args: trailing bytes");
      const result = await handler.shapeArea(shape);
      return encodeResultOk(encodeF64(result));
    } catch (e) {
      return encodeResultErr(encodeInvalidPayload());
    }
  }],
  [0xa914982e7d3c7b55n, async (handler, payload) => {
    try {
      const buf = payload;
      let offset = 0;
      const _name_r = decodeString(buf, offset); const name = _name_r.value; offset = _name_r.next;
      const _shapes_r = decodeVec(buf, offset, (buf: Uint8Array, off: number): DecodeResult<any> => { let o = off;
  const disc = decodeEnumVariant(buf, o); o = disc.next;
  switch (disc.value) {
    case 0: {
      const _f0_r = decodeF64(buf, o); const f0 = _f0_r.value; o = _f0_r.next;
      return { value: { tag: 'Circle', radius: f0 }, next: o };
    }
    case 1: {
      const _f0_r = decodeF64(buf, o); const f0 = _f0_r.value; o = _f0_r.next;
      const _f1_r = decodeF64(buf, o); const f1 = _f1_r.value; o = _f1_r.next;
      return { value: { tag: 'Rectangle', width: f0, height: f1 }, next: o };
    }
    case 2: return { value: { tag: 'Point' }, next: o };
    default: throw new Error(`unknown enum variant: ${disc.value}`);
  }
}); const shapes = _shapes_r.value; offset = _shapes_r.next;
      const _background_disc = decodeEnumVariant(buf, offset); offset = _background_disc.next;
let background: Color;
switch (_background_disc.value) {
  case 0: {
    background = { tag: 'Red' };
    break;
  }
  case 1: {
    background = { tag: 'Green' };
    break;
  }
  case 2: {
    background = { tag: 'Blue' };
    break;
  }
  default: throw new Error(`unknown enum variant ${_background_disc.value}`);
}
      if (offset !== buf.length) throw new Error("args: trailing bytes");
      const result = await handler.createCanvas(name, shapes, background);
      return encodeResultOk(concat(encodeString(result.name), encodeVec(result.shapes, (item) => (() => { switch (item.tag) {
      case 'Circle': return concat(encodeEnumVariant(0), encodeF64(item.radius));
      case 'Rectangle': return concat(encodeEnumVariant(1), encodeF64(item.width), encodeF64(item.height));
      case 'Point': return encodeEnumVariant(2);
      default: throw new Error('unknown enum variant'); } })()), (() => { switch (result.background.tag) {
      case 'Red': return encodeEnumVariant(0);
      case 'Green': return encodeEnumVariant(1);
      case 'Blue': return encodeEnumVariant(2);
      default: throw new Error('unknown enum variant'); } })()));
    } catch (e) {
      return encodeResultErr(encodeInvalidPayload());
    }
  }],
  [0xed1dc0c625889d30n, async (handler, payload) => {
    try {
      const buf = payload;
      let offset = 0;
      const _msg_disc = decodeEnumVariant(buf, offset); offset = _msg_disc.next;
let msg: Message;
switch (_msg_disc.value) {
  case 0: {
    const _msg_inner_r = decodeString(buf, offset); const msg_inner = _msg_inner_r.value; offset = _msg_inner_r.next;
    msg = { tag: 'Text', value: msg_inner };
    break;
  }
  case 1: {
    const _msg_inner_r = decodeI64(buf, offset); const msg_inner = _msg_inner_r.value; offset = _msg_inner_r.next;
    msg = { tag: 'Number', value: msg_inner };
    break;
  }
  case 2: {
    const _msg_inner_r = decodeBytes(buf, offset); const msg_inner = _msg_inner_r.value; offset = _msg_inner_r.next;
    msg = { tag: 'Data', value: msg_inner };
    break;
  }
  default: throw new Error(`unknown enum variant ${_msg_disc.value}`);
}
      if (offset !== buf.length) throw new Error("args: trailing bytes");
      const result = await handler.processMessage(msg);
      return encodeResultOk((() => { switch (result.tag) {
      case 'Text': return concat(encodeEnumVariant(0), encodeString(result.value));
      case 'Number': return concat(encodeEnumVariant(1), encodeI64(result.value));
      case 'Data': return concat(encodeEnumVariant(2), encodeBytes(result.value));
      default: throw new Error('unknown enum variant'); } })());
    } catch (e) {
      return encodeResultErr(encodeInvalidPayload());
    }
  }],
  [0x5c8707f5ae4ccbccn, async (handler, payload) => {
    try {
      const buf = payload;
      let offset = 0;
      const _count_r = decodeU32(buf, offset); const count = _count_r.value; offset = _count_r.next;
      if (offset !== buf.length) throw new Error("args: trailing bytes");
      const result = await handler.getPoints(count);
      return encodeResultOk(encodeVec(result, (item) => concat(encodeI32(item.x), encodeI32(item.y))));
    } catch (e) {
      return encodeResultErr(encodeInvalidPayload());
    }
  }],
  [0xacd19a29fe0d470cn, async (handler, payload) => {
    try {
      const buf = payload;
      let offset = 0;
      const _pair_f0_r = decodeI32(buf, offset); const pair_f0 = _pair_f0_r.value; offset = _pair_f0_r.next;
const _pair_f1_r = decodeString(buf, offset); const pair_f1 = _pair_f1_r.value; offset = _pair_f1_r.next;
const pair = { 0: pair_f0, 1: pair_f1 };
      if (offset !== buf.length) throw new Error("args: trailing bytes");
      const result = await handler.swapPair(pair);
      return encodeResultOk(concat(encodeString(result[0]), encodeI32(result[1])));
    } catch (e) {
      return encodeResultErr(encodeInvalidPayload());
    }
  }],
]);
