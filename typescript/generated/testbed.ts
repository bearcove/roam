// @generated by roam-codegen
// DO NOT EDIT - regenerate with `cargo xtask codegen --typescript`

import type {
  MethodHandler,
  Connection,
  MessageTransport,
  DecodeResult,
  MethodSchema,
} from "@bearcove/roam-core";
import {
  encodeResultOk,
  encodeResultErr,
  encodeInvalidPayload,
  concat,
  encodeVarint,
  decodeVarintNumber,
  decodeRpcResult,
  encodeBool,
  decodeBool,
  encodeU8,
  decodeU8,
  encodeI8,
  decodeI8,
  encodeU16,
  decodeU16,
  encodeI16,
  decodeI16,
  encodeU32,
  decodeU32,
  encodeI32,
  decodeI32,
  encodeU64,
  decodeU64,
  encodeI64,
  decodeI64,
  encodeF32,
  decodeF32,
  encodeF64,
  decodeF64,
  encodeString,
  decodeString,
  encodeBytes,
  decodeBytes,
  encodeOption,
  decodeOption,
  encodeVec,
  decodeVec,
  encodeTuple2,
  decodeTuple2,
  encodeTuple3,
  decodeTuple3,
  encodeEnumVariant,
  decodeEnumVariant,
} from "@bearcove/roam-core";
import { Tx, Rx, createServerTx, createServerRx, bindChannels } from "@bearcove/roam-core";
import type {
  ChannelId,
  ChannelRegistry,
  TaskSender,
  BindingSerializers,
  Schema,
} from "@bearcove/roam-core";

export const METHOD_ID = {
  echo: 0x9aabc4ba61fd5df3n,
  reverse: 0xcba154600f640175n,
  sum: 0x855b3a25d97bfefdn,
  generate: 0x54d2273d8cdb9c38n,
  transform: 0x5d9895604eb18b19n,
  echoPoint: 0x453fa9bf6932528cn,
  createPerson: 0x3dd231f57b1bca21n,
  rectangleArea: 0xba75c48683f1d9e6n,
  parseColor: 0xe285f31c6dfffbfcn,
  shapeArea: 0x6e706354167c00c2n,
  createCanvas: 0xa914982e7d3c7b55n,
  processMessage: 0xed1dc0c625889d30n,
  getPoints: 0x5c8707f5ae4ccbccn,
  swapPair: 0xacd19a29fe0d470cn,
} as const;

// Named type definitions
export interface Point {
  x: number;
  y: number;
}

export interface Person {
  name: string;
  age: number;
  email: string | null;
}

export interface Rectangle {
  top_left: Point;
  bottom_right: Point;
  label: string | null;
}

export type Color = { tag: "Red" } | { tag: "Green" } | { tag: "Blue" };

export type Shape =
  | { tag: "Circle"; radius: number }
  | { tag: "Rectangle"; width: number; height: number }
  | { tag: "Point" };

export interface Canvas {
  name: string;
  shapes: Shape[];
  background: Color;
}

export type Message =
  | { tag: "Text"; value: string }
  | { tag: "Number"; value: bigint }
  | { tag: "Data"; value: Uint8Array };

// Type definitions
export type EchoRequest = [string];
export type EchoResponse = string;

export type ReverseRequest = [string];
export type ReverseResponse = string;

export type SumRequest = [Rx<number>];
export type SumResponse = bigint;

export type GenerateRequest = [
  number, // count
  Tx<number>, // output
];
export type GenerateResponse = void;

export type TransformRequest = [
  Rx<string>, // input
  Tx<string>, // output
];
export type TransformResponse = void;

export type EchoPointRequest = [Point];
export type EchoPointResponse = Point;

export type CreatePersonRequest = [
  string, // name
  number, // age
  string | null, // email
];
export type CreatePersonResponse = Person;

export type RectangleAreaRequest = [Rectangle];
export type RectangleAreaResponse = number;

export type ParseColorRequest = [string];
export type ParseColorResponse = Color | null;

export type ShapeAreaRequest = [Shape];
export type ShapeAreaResponse = number;

export type CreateCanvasRequest = [
  string, // name
  Shape[], // shapes
  Color, // background
];
export type CreateCanvasResponse = Canvas;

export type ProcessMessageRequest = [Message];
export type ProcessMessageResponse = Message;

export type GetPointsRequest = [number];
export type GetPointsResponse = Point[];

export type SwapPairRequest = [[number, string]];
export type SwapPairResponse = [string, number];

// Caller interface for Testbed
export interface TestbedCaller {
  /**  Echoes the message back. */
  echo(message: string): Promise<string>;
  /**  Returns the message reversed. */
  reverse(message: string): Promise<string>;
  /**  Client sends numbers, server returns their sum.

 Tests: client→server streaming. Server receives via `Rx<T>`, returns scalar. */
  sum(numbers: Rx<number>): Promise<bigint>;
  /**  Server streams numbers back to client.

 Tests: server→client streaming. Server sends via `Tx<T>`. */
  generate(count: number, output: Tx<number>): Promise<void>;
  /**  Bidirectional: client sends strings, server echoes each back.

 Tests: bidirectional streaming. Server receives via `Rx<T>`, sends via `Tx<T>`. */
  transform(input: Rx<string>, output: Tx<string>): Promise<void>;
  /**  Echo a point back. */
  echoPoint(point: Point): Promise<Point>;
  /**  Create a person and return it. */
  createPerson(name: string, age: number, email: string | null): Promise<Person>;
  /**  Calculate the area of a rectangle. */
  rectangleArea(rect: Rectangle): Promise<number>;
  /**  Get a color by name. */
  parseColor(name: string): Promise<Color | null>;
  /**  Calculate the area of a shape. */
  shapeArea(shape: Shape): Promise<number>;
  /**  Create a canvas with given shapes. */
  createCanvas(name: string, shapes: Shape[], background: Color): Promise<Canvas>;
  /**  Process a message and return a response. */
  processMessage(msg: Message): Promise<Message>;
  /**  Return multiple points. */
  getPoints(count: number): Promise<Point[]>;
  /**  Test tuple types. */
  swapPair(pair: [number, string]): Promise<[string, number]>;
}

// Client implementation for Testbed
export class TestbedClient<T extends MessageTransport = MessageTransport> implements TestbedCaller {
  private conn: Connection<T>;

  constructor(conn: Connection<T>) {
    this.conn = conn;
  }

  /**  Echoes the message back. */
  async echo(message: string): Promise<string> {
    const payload = encodeString(message);
    const response = await this.conn.call(0x9aabc4ba61fd5df3n, payload);
    const buf = response;
    let offset = decodeRpcResult(buf, 0);
    const _result_r = decodeString(buf, offset);
    const result = _result_r.value;
    offset = _result_r.next;
    return result;
  }

  /**  Returns the message reversed. */
  async reverse(message: string): Promise<string> {
    const payload = encodeString(message);
    const response = await this.conn.call(0xcba154600f640175n, payload);
    const buf = response;
    let offset = decodeRpcResult(buf, 0);
    const _result_r = decodeString(buf, offset);
    const result = _result_r.value;
    offset = _result_r.next;
    return result;
  }

  /**  Client sends numbers, server returns their sum.

 Tests: client→server streaming. Server receives via `Rx<T>`, returns scalar. */
  async sum(numbers: Rx<number>): Promise<bigint> {
    // Bind any Tx/Rx channels in arguments
    bindChannels(
      testbed_schemas.sum.args,
      [numbers],
      this.conn.getChannelAllocator(),
      this.conn.getChannelRegistry(),
      testbed_serializers,
    );
    const payload = encodeU64(numbers.channelId);
    const response = await this.conn.call(0x855b3a25d97bfefdn, payload);
    const buf = response;
    let offset = decodeRpcResult(buf, 0);
    const _result_r = decodeI64(buf, offset);
    const result = _result_r.value;
    offset = _result_r.next;
    return result;
  }

  /**  Server streams numbers back to client.

 Tests: server→client streaming. Server sends via `Tx<T>`. */
  async generate(count: number, output: Tx<number>): Promise<void> {
    // Bind any Tx/Rx channels in arguments
    bindChannels(
      testbed_schemas.generate.args,
      [count, output],
      this.conn.getChannelAllocator(),
      this.conn.getChannelRegistry(),
      testbed_serializers,
    );
    const payload = concat(encodeU32(count), encodeU64(output.channelId));
    const response = await this.conn.call(0x54d2273d8cdb9c38n, payload);
    const buf = response;
    let offset = decodeRpcResult(buf, 0);
    const result = undefined;
    return result;
  }

  /**  Bidirectional: client sends strings, server echoes each back.

 Tests: bidirectional streaming. Server receives via `Rx<T>`, sends via `Tx<T>`. */
  async transform(input: Rx<string>, output: Tx<string>): Promise<void> {
    // Bind any Tx/Rx channels in arguments
    bindChannels(
      testbed_schemas.transform.args,
      [input, output],
      this.conn.getChannelAllocator(),
      this.conn.getChannelRegistry(),
      testbed_serializers,
    );
    const payload = concat(encodeU64(input.channelId), encodeU64(output.channelId));
    const response = await this.conn.call(0x5d9895604eb18b19n, payload);
    const buf = response;
    let offset = decodeRpcResult(buf, 0);
    const result = undefined;
    return result;
  }

  /**  Echo a point back. */
  async echoPoint(point: Point): Promise<Point> {
    const payload = concat(encodeI32(point.x), encodeI32(point.y));
    const response = await this.conn.call(0x453fa9bf6932528cn, payload);
    const buf = response;
    let offset = decodeRpcResult(buf, 0);
    const _result_f0_r = decodeI32(buf, offset);
    const result_f0 = _result_f0_r.value;
    offset = _result_f0_r.next;
    const _result_f1_r = decodeI32(buf, offset);
    const result_f1 = _result_f1_r.value;
    offset = _result_f1_r.next;
    const result = { x: result_f0, y: result_f1 };
    return result;
  }

  /**  Create a person and return it. */
  async createPerson(name: string, age: number, email: string | null): Promise<Person> {
    const payload = concat(
      encodeString(name),
      encodeU8(age),
      encodeOption(email, (v) => encodeString(v)),
    );
    const response = await this.conn.call(0x3dd231f57b1bca21n, payload);
    const buf = response;
    let offset = decodeRpcResult(buf, 0);
    const _result_f0_r = decodeString(buf, offset);
    const result_f0 = _result_f0_r.value;
    offset = _result_f0_r.next;
    const _result_f1_r = decodeU8(buf, offset);
    const result_f1 = _result_f1_r.value;
    offset = _result_f1_r.next;
    const _result_f2_r = decodeOption(buf, offset, (buf, off) => decodeString(buf, off));
    const result_f2 = _result_f2_r.value;
    offset = _result_f2_r.next;
    const result = { name: result_f0, age: result_f1, email: result_f2 };
    return result;
  }

  /**  Calculate the area of a rectangle. */
  async rectangleArea(rect: Rectangle): Promise<number> {
    const payload = concat(
      concat(encodeI32(rect.top_left.x), encodeI32(rect.top_left.y)),
      concat(encodeI32(rect.bottom_right.x), encodeI32(rect.bottom_right.y)),
      encodeOption(rect.label, (v) => encodeString(v)),
    );
    const response = await this.conn.call(0xba75c48683f1d9e6n, payload);
    const buf = response;
    let offset = decodeRpcResult(buf, 0);
    const _result_r = decodeF64(buf, offset);
    const result = _result_r.value;
    offset = _result_r.next;
    return result;
  }

  /**  Get a color by name. */
  async parseColor(name: string): Promise<Color | null> {
    const payload = encodeString(name);
    const response = await this.conn.call(0xe285f31c6dfffbfcn, payload);
    const buf = response;
    let offset = decodeRpcResult(buf, 0);
    const _result_r = decodeOption(
      buf,
      offset,
      (buf: Uint8Array, off: number): DecodeResult<any> => {
        let o = off;
        const disc = decodeEnumVariant(buf, o);
        o = disc.next;
        switch (disc.value) {
          case 0:
            return { value: { tag: "Red" }, next: o };
          case 1:
            return { value: { tag: "Green" }, next: o };
          case 2:
            return { value: { tag: "Blue" }, next: o };
          default:
            throw new Error(`unknown enum variant: ${disc.value}`);
        }
      },
    );
    const result = _result_r.value;
    offset = _result_r.next;
    return result;
  }

  /**  Calculate the area of a shape. */
  async shapeArea(shape: Shape): Promise<number> {
    const payload = (() => {
      switch (shape.tag) {
        case "Circle":
          return concat(encodeEnumVariant(0), encodeF64(shape.radius));
        case "Rectangle":
          return concat(encodeEnumVariant(1), encodeF64(shape.width), encodeF64(shape.height));
        case "Point":
          return encodeEnumVariant(2);
        default:
          throw new Error("unknown enum variant");
      }
    })();
    const response = await this.conn.call(0x6e706354167c00c2n, payload);
    const buf = response;
    let offset = decodeRpcResult(buf, 0);
    const _result_r = decodeF64(buf, offset);
    const result = _result_r.value;
    offset = _result_r.next;
    return result;
  }

  /**  Create a canvas with given shapes. */
  async createCanvas(name: string, shapes: Shape[], background: Color): Promise<Canvas> {
    const payload = concat(
      encodeString(name),
      encodeVec(shapes, (item) =>
        (() => {
          switch (item.tag) {
            case "Circle":
              return concat(encodeEnumVariant(0), encodeF64(item.radius));
            case "Rectangle":
              return concat(encodeEnumVariant(1), encodeF64(item.width), encodeF64(item.height));
            case "Point":
              return encodeEnumVariant(2);
            default:
              throw new Error("unknown enum variant");
          }
        })(),
      ),
      (() => {
        switch (background.tag) {
          case "Red":
            return encodeEnumVariant(0);
          case "Green":
            return encodeEnumVariant(1);
          case "Blue":
            return encodeEnumVariant(2);
          default:
            throw new Error("unknown enum variant");
        }
      })(),
    );
    const response = await this.conn.call(0xa914982e7d3c7b55n, payload);
    const buf = response;
    let offset = decodeRpcResult(buf, 0);
    const _result_f0_r = decodeString(buf, offset);
    const result_f0 = _result_f0_r.value;
    offset = _result_f0_r.next;
    const _result_f1_r = decodeVec(
      buf,
      offset,
      (buf: Uint8Array, off: number): DecodeResult<any> => {
        let o = off;
        const disc = decodeEnumVariant(buf, o);
        o = disc.next;
        switch (disc.value) {
          case 0: {
            const _f0_r = decodeF64(buf, o);
            const f0 = _f0_r.value;
            o = _f0_r.next;
            return { value: { tag: "Circle", radius: f0 }, next: o };
          }
          case 1: {
            const _f0_r = decodeF64(buf, o);
            const f0 = _f0_r.value;
            o = _f0_r.next;
            const _f1_r = decodeF64(buf, o);
            const f1 = _f1_r.value;
            o = _f1_r.next;
            return { value: { tag: "Rectangle", width: f0, height: f1 }, next: o };
          }
          case 2:
            return { value: { tag: "Point" }, next: o };
          default:
            throw new Error(`unknown enum variant: ${disc.value}`);
        }
      },
    );
    const result_f1 = _result_f1_r.value;
    offset = _result_f1_r.next;
    const _result_f2_disc = decodeEnumVariant(buf, offset);
    offset = _result_f2_disc.next;
    let result_f2: Color;
    switch (_result_f2_disc.value) {
      case 0: {
        result_f2 = { tag: "Red" };
        break;
      }
      case 1: {
        result_f2 = { tag: "Green" };
        break;
      }
      case 2: {
        result_f2 = { tag: "Blue" };
        break;
      }
      default:
        throw new Error(`unknown enum variant ${_result_f2_disc.value}`);
    }
    const result = { name: result_f0, shapes: result_f1, background: result_f2 };
    return result;
  }

  /**  Process a message and return a response. */
  async processMessage(msg: Message): Promise<Message> {
    const payload = (() => {
      switch (msg.tag) {
        case "Text":
          return concat(encodeEnumVariant(0), encodeString(msg.value));
        case "Number":
          return concat(encodeEnumVariant(1), encodeI64(msg.value));
        case "Data":
          return concat(encodeEnumVariant(2), encodeBytes(msg.value));
        default:
          throw new Error("unknown enum variant");
      }
    })();
    const response = await this.conn.call(0xed1dc0c625889d30n, payload);
    const buf = response;
    let offset = decodeRpcResult(buf, 0);
    const _result_disc = decodeEnumVariant(buf, offset);
    offset = _result_disc.next;
    let result: Message;
    switch (_result_disc.value) {
      case 0: {
        const _result_inner_r = decodeString(buf, offset);
        const result_inner = _result_inner_r.value;
        offset = _result_inner_r.next;
        result = { tag: "Text", value: result_inner };
        break;
      }
      case 1: {
        const _result_inner_r = decodeI64(buf, offset);
        const result_inner = _result_inner_r.value;
        offset = _result_inner_r.next;
        result = { tag: "Number", value: result_inner };
        break;
      }
      case 2: {
        const _result_inner_r = decodeBytes(buf, offset);
        const result_inner = _result_inner_r.value;
        offset = _result_inner_r.next;
        result = { tag: "Data", value: result_inner };
        break;
      }
      default:
        throw new Error(`unknown enum variant ${_result_disc.value}`);
    }
    return result;
  }

  /**  Return multiple points. */
  async getPoints(count: number): Promise<Point[]> {
    const payload = encodeU32(count);
    const response = await this.conn.call(0x5c8707f5ae4ccbccn, payload);
    const buf = response;
    let offset = decodeRpcResult(buf, 0);
    const _result_r = decodeVec(buf, offset, (buf: Uint8Array, off: number) => {
      let o = off;
      const _f0_r = decodeI32(buf, o);
      const f0 = _f0_r.value;
      o = _f0_r.next;
      const _f1_r = decodeI32(buf, o);
      const f1 = _f1_r.value;
      o = _f1_r.next;
      return { value: { x: f0, y: f1 }, next: o };
    });
    const result = _result_r.value;
    offset = _result_r.next;
    return result;
  }

  /**  Test tuple types. */
  async swapPair(pair: [number, string]): Promise<[string, number]> {
    const payload = concat(encodeI32(pair[0]), encodeString(pair[1]));
    const response = await this.conn.call(0xacd19a29fe0d470cn, payload);
    const buf = response;
    let offset = decodeRpcResult(buf, 0);
    const _result_0_r = decodeString(buf, offset);
    const result_0 = _result_0_r.value;
    offset = _result_0_r.next;
    const _result_1_r = decodeI32(buf, offset);
    const result_1 = _result_1_r.value;
    offset = _result_1_r.next;
    const result = [result_0, result_1] as [string, number];
    return result;
  }
}

// Handler interface for Testbed
export interface TestbedHandler {
  echo(message: string): Promise<string> | string;
  reverse(message: string): Promise<string> | string;
  sum(numbers: Rx<number>): Promise<bigint> | bigint;
  generate(count: number, output: Tx<number>): Promise<void> | void;
  transform(input: Rx<string>, output: Tx<string>): Promise<void> | void;
  echoPoint(point: Point): Promise<Point> | Point;
  createPerson(name: string, age: number, email: string | null): Promise<Person> | Person;
  rectangleArea(rect: Rectangle): Promise<number> | number;
  parseColor(name: string): Promise<Color | null> | Color | null;
  shapeArea(shape: Shape): Promise<number> | number;
  createCanvas(name: string, shapes: Shape[], background: Color): Promise<Canvas> | Canvas;
  processMessage(msg: Message): Promise<Message> | Message;
  getPoints(count: number): Promise<Point[]> | Point[];
  swapPair(pair: [number, string]): Promise<[string, number]> | [string, number];
}

// Method handlers for Testbed
export const testbed_methodHandlers = new Map<bigint, MethodHandler<TestbedHandler>>([
  [
    0x9aabc4ba61fd5df3n,
    async (handler, payload) => {
      try {
        const buf = payload;
        let offset = 0;
        const _message_r = decodeString(buf, offset);
        const message = _message_r.value;
        offset = _message_r.next;
        if (offset !== buf.length) throw new Error("args: trailing bytes");
        const result = await handler.echo(message);
        return encodeResultOk(encodeString(result));
      } catch (e) {
        return encodeResultErr(encodeInvalidPayload());
      }
    },
  ],
  [
    0xcba154600f640175n,
    async (handler, payload) => {
      try {
        const buf = payload;
        let offset = 0;
        const _message_r = decodeString(buf, offset);
        const message = _message_r.value;
        offset = _message_r.next;
        if (offset !== buf.length) throw new Error("args: trailing bytes");
        const result = await handler.reverse(message);
        return encodeResultOk(encodeString(result));
      } catch (e) {
        return encodeResultErr(encodeInvalidPayload());
      }
    },
  ],
  [
    0x855b3a25d97bfefdn,
    async (handler, payload) => {
      try {
        // Channeling method - use streamingDispatch() instead of simple RPC dispatch
        return encodeResultErr(encodeInvalidPayload());
      } catch (e) {
        return encodeResultErr(encodeInvalidPayload());
      }
    },
  ],
  [
    0x54d2273d8cdb9c38n,
    async (handler, payload) => {
      try {
        // Channeling method - use streamingDispatch() instead of simple RPC dispatch
        return encodeResultErr(encodeInvalidPayload());
      } catch (e) {
        return encodeResultErr(encodeInvalidPayload());
      }
    },
  ],
  [
    0x5d9895604eb18b19n,
    async (handler, payload) => {
      try {
        // Channeling method - use streamingDispatch() instead of simple RPC dispatch
        return encodeResultErr(encodeInvalidPayload());
      } catch (e) {
        return encodeResultErr(encodeInvalidPayload());
      }
    },
  ],
  [
    0x453fa9bf6932528cn,
    async (handler, payload) => {
      try {
        const buf = payload;
        let offset = 0;
        const _point_f0_r = decodeI32(buf, offset);
        const point_f0 = _point_f0_r.value;
        offset = _point_f0_r.next;
        const _point_f1_r = decodeI32(buf, offset);
        const point_f1 = _point_f1_r.value;
        offset = _point_f1_r.next;
        const point = { x: point_f0, y: point_f1 };
        if (offset !== buf.length) throw new Error("args: trailing bytes");
        const result = await handler.echoPoint(point);
        return encodeResultOk(concat(encodeI32(result.x), encodeI32(result.y)));
      } catch (e) {
        return encodeResultErr(encodeInvalidPayload());
      }
    },
  ],
  [
    0x3dd231f57b1bca21n,
    async (handler, payload) => {
      try {
        const buf = payload;
        let offset = 0;
        const _name_r = decodeString(buf, offset);
        const name = _name_r.value;
        offset = _name_r.next;
        const _age_r = decodeU8(buf, offset);
        const age = _age_r.value;
        offset = _age_r.next;
        const _email_r = decodeOption(buf, offset, (buf, off) => decodeString(buf, off));
        const email = _email_r.value;
        offset = _email_r.next;
        if (offset !== buf.length) throw new Error("args: trailing bytes");
        const result = await handler.createPerson(name, age, email);
        return encodeResultOk(
          concat(
            encodeString(result.name),
            encodeU8(result.age),
            encodeOption(result.email, (v) => encodeString(v)),
          ),
        );
      } catch (e) {
        return encodeResultErr(encodeInvalidPayload());
      }
    },
  ],
  [
    0xba75c48683f1d9e6n,
    async (handler, payload) => {
      try {
        const buf = payload;
        let offset = 0;
        const _rect_f0_f0_r = decodeI32(buf, offset);
        const rect_f0_f0 = _rect_f0_f0_r.value;
        offset = _rect_f0_f0_r.next;
        const _rect_f0_f1_r = decodeI32(buf, offset);
        const rect_f0_f1 = _rect_f0_f1_r.value;
        offset = _rect_f0_f1_r.next;
        const rect_f0 = { x: rect_f0_f0, y: rect_f0_f1 };
        const _rect_f1_f0_r = decodeI32(buf, offset);
        const rect_f1_f0 = _rect_f1_f0_r.value;
        offset = _rect_f1_f0_r.next;
        const _rect_f1_f1_r = decodeI32(buf, offset);
        const rect_f1_f1 = _rect_f1_f1_r.value;
        offset = _rect_f1_f1_r.next;
        const rect_f1 = { x: rect_f1_f0, y: rect_f1_f1 };
        const _rect_f2_r = decodeOption(buf, offset, (buf, off) => decodeString(buf, off));
        const rect_f2 = _rect_f2_r.value;
        offset = _rect_f2_r.next;
        const rect = { top_left: rect_f0, bottom_right: rect_f1, label: rect_f2 };
        if (offset !== buf.length) throw new Error("args: trailing bytes");
        const result = await handler.rectangleArea(rect);
        return encodeResultOk(encodeF64(result));
      } catch (e) {
        return encodeResultErr(encodeInvalidPayload());
      }
    },
  ],
  [
    0xe285f31c6dfffbfcn,
    async (handler, payload) => {
      try {
        const buf = payload;
        let offset = 0;
        const _name_r = decodeString(buf, offset);
        const name = _name_r.value;
        offset = _name_r.next;
        if (offset !== buf.length) throw new Error("args: trailing bytes");
        const result = await handler.parseColor(name);
        return encodeResultOk(
          encodeOption(result, (v) =>
            (() => {
              switch (v.tag) {
                case "Red":
                  return encodeEnumVariant(0);
                case "Green":
                  return encodeEnumVariant(1);
                case "Blue":
                  return encodeEnumVariant(2);
                default:
                  throw new Error("unknown enum variant");
              }
            })(),
          ),
        );
      } catch (e) {
        return encodeResultErr(encodeInvalidPayload());
      }
    },
  ],
  [
    0x6e706354167c00c2n,
    async (handler, payload) => {
      try {
        const buf = payload;
        let offset = 0;
        const _shape_disc = decodeEnumVariant(buf, offset);
        offset = _shape_disc.next;
        let shape: Shape;
        switch (_shape_disc.value) {
          case 0: {
            const _shape_f0_r = decodeF64(buf, offset);
            const shape_f0 = _shape_f0_r.value;
            offset = _shape_f0_r.next;
            shape = { tag: "Circle", radius: shape_f0 };
            break;
          }
          case 1: {
            const _shape_f0_r = decodeF64(buf, offset);
            const shape_f0 = _shape_f0_r.value;
            offset = _shape_f0_r.next;
            const _shape_f1_r = decodeF64(buf, offset);
            const shape_f1 = _shape_f1_r.value;
            offset = _shape_f1_r.next;
            shape = { tag: "Rectangle", width: shape_f0, height: shape_f1 };
            break;
          }
          case 2: {
            shape = { tag: "Point" };
            break;
          }
          default:
            throw new Error(`unknown enum variant ${_shape_disc.value}`);
        }
        if (offset !== buf.length) throw new Error("args: trailing bytes");
        const result = await handler.shapeArea(shape);
        return encodeResultOk(encodeF64(result));
      } catch (e) {
        return encodeResultErr(encodeInvalidPayload());
      }
    },
  ],
  [
    0xa914982e7d3c7b55n,
    async (handler, payload) => {
      try {
        const buf = payload;
        let offset = 0;
        const _name_r = decodeString(buf, offset);
        const name = _name_r.value;
        offset = _name_r.next;
        const _shapes_r = decodeVec(
          buf,
          offset,
          (buf: Uint8Array, off: number): DecodeResult<any> => {
            let o = off;
            const disc = decodeEnumVariant(buf, o);
            o = disc.next;
            switch (disc.value) {
              case 0: {
                const _f0_r = decodeF64(buf, o);
                const f0 = _f0_r.value;
                o = _f0_r.next;
                return { value: { tag: "Circle", radius: f0 }, next: o };
              }
              case 1: {
                const _f0_r = decodeF64(buf, o);
                const f0 = _f0_r.value;
                o = _f0_r.next;
                const _f1_r = decodeF64(buf, o);
                const f1 = _f1_r.value;
                o = _f1_r.next;
                return { value: { tag: "Rectangle", width: f0, height: f1 }, next: o };
              }
              case 2:
                return { value: { tag: "Point" }, next: o };
              default:
                throw new Error(`unknown enum variant: ${disc.value}`);
            }
          },
        );
        const shapes = _shapes_r.value;
        offset = _shapes_r.next;
        const _background_disc = decodeEnumVariant(buf, offset);
        offset = _background_disc.next;
        let background: Color;
        switch (_background_disc.value) {
          case 0: {
            background = { tag: "Red" };
            break;
          }
          case 1: {
            background = { tag: "Green" };
            break;
          }
          case 2: {
            background = { tag: "Blue" };
            break;
          }
          default:
            throw new Error(`unknown enum variant ${_background_disc.value}`);
        }
        if (offset !== buf.length) throw new Error("args: trailing bytes");
        const result = await handler.createCanvas(name, shapes, background);
        return encodeResultOk(
          concat(
            encodeString(result.name),
            encodeVec(result.shapes, (item) =>
              (() => {
                switch (item.tag) {
                  case "Circle":
                    return concat(encodeEnumVariant(0), encodeF64(item.radius));
                  case "Rectangle":
                    return concat(
                      encodeEnumVariant(1),
                      encodeF64(item.width),
                      encodeF64(item.height),
                    );
                  case "Point":
                    return encodeEnumVariant(2);
                  default:
                    throw new Error("unknown enum variant");
                }
              })(),
            ),
            (() => {
              switch (result.background.tag) {
                case "Red":
                  return encodeEnumVariant(0);
                case "Green":
                  return encodeEnumVariant(1);
                case "Blue":
                  return encodeEnumVariant(2);
                default:
                  throw new Error("unknown enum variant");
              }
            })(),
          ),
        );
      } catch (e) {
        return encodeResultErr(encodeInvalidPayload());
      }
    },
  ],
  [
    0xed1dc0c625889d30n,
    async (handler, payload) => {
      try {
        const buf = payload;
        let offset = 0;
        const _msg_disc = decodeEnumVariant(buf, offset);
        offset = _msg_disc.next;
        let msg: Message;
        switch (_msg_disc.value) {
          case 0: {
            const _msg_inner_r = decodeString(buf, offset);
            const msg_inner = _msg_inner_r.value;
            offset = _msg_inner_r.next;
            msg = { tag: "Text", value: msg_inner };
            break;
          }
          case 1: {
            const _msg_inner_r = decodeI64(buf, offset);
            const msg_inner = _msg_inner_r.value;
            offset = _msg_inner_r.next;
            msg = { tag: "Number", value: msg_inner };
            break;
          }
          case 2: {
            const _msg_inner_r = decodeBytes(buf, offset);
            const msg_inner = _msg_inner_r.value;
            offset = _msg_inner_r.next;
            msg = { tag: "Data", value: msg_inner };
            break;
          }
          default:
            throw new Error(`unknown enum variant ${_msg_disc.value}`);
        }
        if (offset !== buf.length) throw new Error("args: trailing bytes");
        const result = await handler.processMessage(msg);
        return encodeResultOk(
          (() => {
            switch (result.tag) {
              case "Text":
                return concat(encodeEnumVariant(0), encodeString(result.value));
              case "Number":
                return concat(encodeEnumVariant(1), encodeI64(result.value));
              case "Data":
                return concat(encodeEnumVariant(2), encodeBytes(result.value));
              default:
                throw new Error("unknown enum variant");
            }
          })(),
        );
      } catch (e) {
        return encodeResultErr(encodeInvalidPayload());
      }
    },
  ],
  [
    0x5c8707f5ae4ccbccn,
    async (handler, payload) => {
      try {
        const buf = payload;
        let offset = 0;
        const _count_r = decodeU32(buf, offset);
        const count = _count_r.value;
        offset = _count_r.next;
        if (offset !== buf.length) throw new Error("args: trailing bytes");
        const result = await handler.getPoints(count);
        return encodeResultOk(
          encodeVec(result, (item) => concat(encodeI32(item.x), encodeI32(item.y))),
        );
      } catch (e) {
        return encodeResultErr(encodeInvalidPayload());
      }
    },
  ],
  [
    0xacd19a29fe0d470cn,
    async (handler, payload) => {
      try {
        const buf = payload;
        let offset = 0;
        const _pair_0_r = decodeI32(buf, offset);
        const pair_0 = _pair_0_r.value;
        offset = _pair_0_r.next;
        const _pair_1_r = decodeString(buf, offset);
        const pair_1 = _pair_1_r.value;
        offset = _pair_1_r.next;
        const pair = [pair_0, pair_1] as [number, string];
        if (offset !== buf.length) throw new Error("args: trailing bytes");
        const result = await handler.swapPair(pair);
        return encodeResultOk(concat(encodeString(result[0]), encodeI32(result[1])));
      } catch (e) {
        return encodeResultErr(encodeInvalidPayload());
      }
    },
  ],
]);

// Streaming method handler type for Testbed
export type ChannelingMethodHandler<H> = (
  handler: H,
  payload: Uint8Array,
  requestId: bigint,
  registry: ChannelRegistry,
  taskSender: TaskSender,
) => Promise<void>;

// Streaming method handlers for Testbed
export const testbed_streamingHandlers = new Map<bigint, ChannelingMethodHandler<TestbedHandler>>([
  [
    0x9aabc4ba61fd5df3n,
    async (handler, payload, requestId, registry, taskSender) => {
      try {
        const buf = payload;
        let offset = 0;
        const _message_r = decodeString(buf, offset);
        const message = _message_r.value;
        offset = _message_r.next;
        if (offset !== buf.length) throw new Error("args: trailing bytes");
        const result = await handler.echo(message);
        taskSender({ kind: "response", requestId, payload: encodeResultOk(encodeString(result)) });
      } catch (e) {
        taskSender({
          kind: "response",
          requestId,
          payload: encodeResultErr(encodeInvalidPayload()),
        });
      }
    },
  ],
  [
    0xcba154600f640175n,
    async (handler, payload, requestId, registry, taskSender) => {
      try {
        const buf = payload;
        let offset = 0;
        const _message_r = decodeString(buf, offset);
        const message = _message_r.value;
        offset = _message_r.next;
        if (offset !== buf.length) throw new Error("args: trailing bytes");
        const result = await handler.reverse(message);
        taskSender({ kind: "response", requestId, payload: encodeResultOk(encodeString(result)) });
      } catch (e) {
        taskSender({
          kind: "response",
          requestId,
          payload: encodeResultErr(encodeInvalidPayload()),
        });
      }
    },
  ],
  [
    0x855b3a25d97bfefdn,
    async (handler, payload, requestId, registry, taskSender) => {
      try {
        const buf = payload;
        let offset = 0;
        const _numbers_r = decodeU64(buf, offset);
        const _numbers_receiver = registry.registerIncoming(_numbers_r.value);
        const numbers = createServerRx<number>(
          _numbers_r.value,
          _numbers_receiver,
          (bytes: Uint8Array) => decodeI32(bytes, 0).value,
        );
        offset = _numbers_r.next;
        if (offset !== buf.length) throw new Error("args: trailing bytes");
        const result = await handler.sum(numbers);
        taskSender({ kind: "response", requestId, payload: encodeResultOk(encodeI64(result)) });
      } catch (e) {
        taskSender({
          kind: "response",
          requestId,
          payload: encodeResultErr(encodeInvalidPayload()),
        });
      }
    },
  ],
  [
    0x54d2273d8cdb9c38n,
    async (handler, payload, requestId, registry, taskSender) => {
      try {
        const buf = payload;
        let offset = 0;
        const _count_r = decodeU32(buf, offset);
        const count = _count_r.value;
        offset = _count_r.next;
        const _output_r = decodeU64(buf, offset);
        const output = createServerTx<number>(_output_r.value, taskSender, (v: number) =>
          encodeI32(v),
        );
        offset = _output_r.next;
        if (offset !== buf.length) throw new Error("args: trailing bytes");
        const result = await handler.generate(count, output);
        output.close();
        taskSender({ kind: "response", requestId, payload: encodeResultOk(new Uint8Array(0)) });
      } catch (e) {
        taskSender({
          kind: "response",
          requestId,
          payload: encodeResultErr(encodeInvalidPayload()),
        });
      }
    },
  ],
  [
    0x5d9895604eb18b19n,
    async (handler, payload, requestId, registry, taskSender) => {
      try {
        const buf = payload;
        let offset = 0;
        const _input_r = decodeU64(buf, offset);
        const _input_receiver = registry.registerIncoming(_input_r.value);
        const input = createServerRx<string>(
          _input_r.value,
          _input_receiver,
          (bytes: Uint8Array) => decodeString(bytes, 0).value,
        );
        offset = _input_r.next;
        const _output_r = decodeU64(buf, offset);
        const output = createServerTx<string>(_output_r.value, taskSender, (v: string) =>
          encodeString(v),
        );
        offset = _output_r.next;
        if (offset !== buf.length) throw new Error("args: trailing bytes");
        const result = await handler.transform(input, output);
        output.close();
        taskSender({ kind: "response", requestId, payload: encodeResultOk(new Uint8Array(0)) });
      } catch (e) {
        taskSender({
          kind: "response",
          requestId,
          payload: encodeResultErr(encodeInvalidPayload()),
        });
      }
    },
  ],
  [
    0x453fa9bf6932528cn,
    async (handler, payload, requestId, registry, taskSender) => {
      try {
        const buf = payload;
        let offset = 0;
        const _point_f0_r = decodeI32(buf, offset);
        const point_f0 = _point_f0_r.value;
        offset = _point_f0_r.next;
        const _point_f1_r = decodeI32(buf, offset);
        const point_f1 = _point_f1_r.value;
        offset = _point_f1_r.next;
        const point = { x: point_f0, y: point_f1 };
        if (offset !== buf.length) throw new Error("args: trailing bytes");
        const result = await handler.echoPoint(point);
        taskSender({
          kind: "response",
          requestId,
          payload: encodeResultOk(concat(encodeI32(result.x), encodeI32(result.y))),
        });
      } catch (e) {
        taskSender({
          kind: "response",
          requestId,
          payload: encodeResultErr(encodeInvalidPayload()),
        });
      }
    },
  ],
  [
    0x3dd231f57b1bca21n,
    async (handler, payload, requestId, registry, taskSender) => {
      try {
        const buf = payload;
        let offset = 0;
        const _name_r = decodeString(buf, offset);
        const name = _name_r.value;
        offset = _name_r.next;
        const _age_r = decodeU8(buf, offset);
        const age = _age_r.value;
        offset = _age_r.next;
        const _email_r = decodeOption(buf, offset, (buf, off) => decodeString(buf, off));
        const email = _email_r.value;
        offset = _email_r.next;
        if (offset !== buf.length) throw new Error("args: trailing bytes");
        const result = await handler.createPerson(name, age, email);
        taskSender({
          kind: "response",
          requestId,
          payload: encodeResultOk(
            concat(
              encodeString(result.name),
              encodeU8(result.age),
              encodeOption(result.email, (v) => encodeString(v)),
            ),
          ),
        });
      } catch (e) {
        taskSender({
          kind: "response",
          requestId,
          payload: encodeResultErr(encodeInvalidPayload()),
        });
      }
    },
  ],
  [
    0xba75c48683f1d9e6n,
    async (handler, payload, requestId, registry, taskSender) => {
      try {
        const buf = payload;
        let offset = 0;
        const _rect_f0_f0_r = decodeI32(buf, offset);
        const rect_f0_f0 = _rect_f0_f0_r.value;
        offset = _rect_f0_f0_r.next;
        const _rect_f0_f1_r = decodeI32(buf, offset);
        const rect_f0_f1 = _rect_f0_f1_r.value;
        offset = _rect_f0_f1_r.next;
        const rect_f0 = { x: rect_f0_f0, y: rect_f0_f1 };
        const _rect_f1_f0_r = decodeI32(buf, offset);
        const rect_f1_f0 = _rect_f1_f0_r.value;
        offset = _rect_f1_f0_r.next;
        const _rect_f1_f1_r = decodeI32(buf, offset);
        const rect_f1_f1 = _rect_f1_f1_r.value;
        offset = _rect_f1_f1_r.next;
        const rect_f1 = { x: rect_f1_f0, y: rect_f1_f1 };
        const _rect_f2_r = decodeOption(buf, offset, (buf, off) => decodeString(buf, off));
        const rect_f2 = _rect_f2_r.value;
        offset = _rect_f2_r.next;
        const rect = { top_left: rect_f0, bottom_right: rect_f1, label: rect_f2 };
        if (offset !== buf.length) throw new Error("args: trailing bytes");
        const result = await handler.rectangleArea(rect);
        taskSender({ kind: "response", requestId, payload: encodeResultOk(encodeF64(result)) });
      } catch (e) {
        taskSender({
          kind: "response",
          requestId,
          payload: encodeResultErr(encodeInvalidPayload()),
        });
      }
    },
  ],
  [
    0xe285f31c6dfffbfcn,
    async (handler, payload, requestId, registry, taskSender) => {
      try {
        const buf = payload;
        let offset = 0;
        const _name_r = decodeString(buf, offset);
        const name = _name_r.value;
        offset = _name_r.next;
        if (offset !== buf.length) throw new Error("args: trailing bytes");
        const result = await handler.parseColor(name);
        taskSender({
          kind: "response",
          requestId,
          payload: encodeResultOk(
            encodeOption(result, (v) =>
              (() => {
                switch (v.tag) {
                  case "Red":
                    return encodeEnumVariant(0);
                  case "Green":
                    return encodeEnumVariant(1);
                  case "Blue":
                    return encodeEnumVariant(2);
                  default:
                    throw new Error("unknown enum variant");
                }
              })(),
            ),
          ),
        });
      } catch (e) {
        taskSender({
          kind: "response",
          requestId,
          payload: encodeResultErr(encodeInvalidPayload()),
        });
      }
    },
  ],
  [
    0x6e706354167c00c2n,
    async (handler, payload, requestId, registry, taskSender) => {
      try {
        const buf = payload;
        let offset = 0;
        const _shape_disc = decodeEnumVariant(buf, offset);
        offset = _shape_disc.next;
        let shape: Shape;
        switch (_shape_disc.value) {
          case 0: {
            const _shape_f0_r = decodeF64(buf, offset);
            const shape_f0 = _shape_f0_r.value;
            offset = _shape_f0_r.next;
            shape = { tag: "Circle", radius: shape_f0 };
            break;
          }
          case 1: {
            const _shape_f0_r = decodeF64(buf, offset);
            const shape_f0 = _shape_f0_r.value;
            offset = _shape_f0_r.next;
            const _shape_f1_r = decodeF64(buf, offset);
            const shape_f1 = _shape_f1_r.value;
            offset = _shape_f1_r.next;
            shape = { tag: "Rectangle", width: shape_f0, height: shape_f1 };
            break;
          }
          case 2: {
            shape = { tag: "Point" };
            break;
          }
          default:
            throw new Error(`unknown enum variant ${_shape_disc.value}`);
        }
        if (offset !== buf.length) throw new Error("args: trailing bytes");
        const result = await handler.shapeArea(shape);
        taskSender({ kind: "response", requestId, payload: encodeResultOk(encodeF64(result)) });
      } catch (e) {
        taskSender({
          kind: "response",
          requestId,
          payload: encodeResultErr(encodeInvalidPayload()),
        });
      }
    },
  ],
  [
    0xa914982e7d3c7b55n,
    async (handler, payload, requestId, registry, taskSender) => {
      try {
        const buf = payload;
        let offset = 0;
        const _name_r = decodeString(buf, offset);
        const name = _name_r.value;
        offset = _name_r.next;
        const _shapes_r = decodeVec(
          buf,
          offset,
          (buf: Uint8Array, off: number): DecodeResult<any> => {
            let o = off;
            const disc = decodeEnumVariant(buf, o);
            o = disc.next;
            switch (disc.value) {
              case 0: {
                const _f0_r = decodeF64(buf, o);
                const f0 = _f0_r.value;
                o = _f0_r.next;
                return { value: { tag: "Circle", radius: f0 }, next: o };
              }
              case 1: {
                const _f0_r = decodeF64(buf, o);
                const f0 = _f0_r.value;
                o = _f0_r.next;
                const _f1_r = decodeF64(buf, o);
                const f1 = _f1_r.value;
                o = _f1_r.next;
                return { value: { tag: "Rectangle", width: f0, height: f1 }, next: o };
              }
              case 2:
                return { value: { tag: "Point" }, next: o };
              default:
                throw new Error(`unknown enum variant: ${disc.value}`);
            }
          },
        );
        const shapes = _shapes_r.value;
        offset = _shapes_r.next;
        const _background_disc = decodeEnumVariant(buf, offset);
        offset = _background_disc.next;
        let background: Color;
        switch (_background_disc.value) {
          case 0: {
            background = { tag: "Red" };
            break;
          }
          case 1: {
            background = { tag: "Green" };
            break;
          }
          case 2: {
            background = { tag: "Blue" };
            break;
          }
          default:
            throw new Error(`unknown enum variant ${_background_disc.value}`);
        }
        if (offset !== buf.length) throw new Error("args: trailing bytes");
        const result = await handler.createCanvas(name, shapes, background);
        taskSender({
          kind: "response",
          requestId,
          payload: encodeResultOk(
            concat(
              encodeString(result.name),
              encodeVec(result.shapes, (item) =>
                (() => {
                  switch (item.tag) {
                    case "Circle":
                      return concat(encodeEnumVariant(0), encodeF64(item.radius));
                    case "Rectangle":
                      return concat(
                        encodeEnumVariant(1),
                        encodeF64(item.width),
                        encodeF64(item.height),
                      );
                    case "Point":
                      return encodeEnumVariant(2);
                    default:
                      throw new Error("unknown enum variant");
                  }
                })(),
              ),
              (() => {
                switch (result.background.tag) {
                  case "Red":
                    return encodeEnumVariant(0);
                  case "Green":
                    return encodeEnumVariant(1);
                  case "Blue":
                    return encodeEnumVariant(2);
                  default:
                    throw new Error("unknown enum variant");
                }
              })(),
            ),
          ),
        });
      } catch (e) {
        taskSender({
          kind: "response",
          requestId,
          payload: encodeResultErr(encodeInvalidPayload()),
        });
      }
    },
  ],
  [
    0xed1dc0c625889d30n,
    async (handler, payload, requestId, registry, taskSender) => {
      try {
        const buf = payload;
        let offset = 0;
        const _msg_disc = decodeEnumVariant(buf, offset);
        offset = _msg_disc.next;
        let msg: Message;
        switch (_msg_disc.value) {
          case 0: {
            const _msg_inner_r = decodeString(buf, offset);
            const msg_inner = _msg_inner_r.value;
            offset = _msg_inner_r.next;
            msg = { tag: "Text", value: msg_inner };
            break;
          }
          case 1: {
            const _msg_inner_r = decodeI64(buf, offset);
            const msg_inner = _msg_inner_r.value;
            offset = _msg_inner_r.next;
            msg = { tag: "Number", value: msg_inner };
            break;
          }
          case 2: {
            const _msg_inner_r = decodeBytes(buf, offset);
            const msg_inner = _msg_inner_r.value;
            offset = _msg_inner_r.next;
            msg = { tag: "Data", value: msg_inner };
            break;
          }
          default:
            throw new Error(`unknown enum variant ${_msg_disc.value}`);
        }
        if (offset !== buf.length) throw new Error("args: trailing bytes");
        const result = await handler.processMessage(msg);
        taskSender({
          kind: "response",
          requestId,
          payload: encodeResultOk(
            (() => {
              switch (result.tag) {
                case "Text":
                  return concat(encodeEnumVariant(0), encodeString(result.value));
                case "Number":
                  return concat(encodeEnumVariant(1), encodeI64(result.value));
                case "Data":
                  return concat(encodeEnumVariant(2), encodeBytes(result.value));
                default:
                  throw new Error("unknown enum variant");
              }
            })(),
          ),
        });
      } catch (e) {
        taskSender({
          kind: "response",
          requestId,
          payload: encodeResultErr(encodeInvalidPayload()),
        });
      }
    },
  ],
  [
    0x5c8707f5ae4ccbccn,
    async (handler, payload, requestId, registry, taskSender) => {
      try {
        const buf = payload;
        let offset = 0;
        const _count_r = decodeU32(buf, offset);
        const count = _count_r.value;
        offset = _count_r.next;
        if (offset !== buf.length) throw new Error("args: trailing bytes");
        const result = await handler.getPoints(count);
        taskSender({
          kind: "response",
          requestId,
          payload: encodeResultOk(
            encodeVec(result, (item) => concat(encodeI32(item.x), encodeI32(item.y))),
          ),
        });
      } catch (e) {
        taskSender({
          kind: "response",
          requestId,
          payload: encodeResultErr(encodeInvalidPayload()),
        });
      }
    },
  ],
  [
    0xacd19a29fe0d470cn,
    async (handler, payload, requestId, registry, taskSender) => {
      try {
        const buf = payload;
        let offset = 0;
        const _pair_0_r = decodeI32(buf, offset);
        const pair_0 = _pair_0_r.value;
        offset = _pair_0_r.next;
        const _pair_1_r = decodeString(buf, offset);
        const pair_1 = _pair_1_r.value;
        offset = _pair_1_r.next;
        const pair = [pair_0, pair_1] as [number, string];
        if (offset !== buf.length) throw new Error("args: trailing bytes");
        const result = await handler.swapPair(pair);
        taskSender({
          kind: "response",
          requestId,
          payload: encodeResultOk(concat(encodeString(result[0]), encodeI32(result[1]))),
        });
      } catch (e) {
        taskSender({
          kind: "response",
          requestId,
          payload: encodeResultErr(encodeInvalidPayload()),
        });
      }
    },
  ],
]);

// Method schemas for runtime channel binding
export const testbed_schemas: Record<string, MethodSchema> = {
  echo: { args: [{ kind: "string" }] },
  reverse: { args: [{ kind: "string" }] },
  sum: { args: [{ kind: "rx", element: { kind: "i32" } }] },
  generate: { args: [{ kind: "u32" }, { kind: "tx", element: { kind: "i32" } }] },
  transform: {
    args: [
      { kind: "rx", element: { kind: "string" } },
      { kind: "tx", element: { kind: "string" } },
    ],
  },
  echoPoint: { args: [{ kind: "struct", fields: { x: { kind: "i32" }, y: { kind: "i32" } } }] },
  createPerson: {
    args: [{ kind: "string" }, { kind: "u8" }, { kind: "option", inner: { kind: "string" } }],
  },
  rectangleArea: {
    args: [
      {
        kind: "struct",
        fields: {
          top_left: { kind: "struct", fields: { x: { kind: "i32" }, y: { kind: "i32" } } },
          bottom_right: { kind: "struct", fields: { x: { kind: "i32" }, y: { kind: "i32" } } },
          label: { kind: "option", inner: { kind: "string" } },
        },
      },
    ],
  },
  parseColor: { args: [{ kind: "string" }] },
  shapeArea: {
    args: [
      {
        kind: "enum",
        variants: [
          { name: "Circle", fields: { radius: { kind: "f64" } } },
          { name: "Rectangle", fields: { width: { kind: "f64" }, height: { kind: "f64" } } },
          { name: "Point", fields: null },
        ],
      },
    ],
  },
  createCanvas: {
    args: [
      { kind: "string" },
      {
        kind: "vec",
        element: {
          kind: "enum",
          variants: [
            { name: "Circle", fields: { radius: { kind: "f64" } } },
            { name: "Rectangle", fields: { width: { kind: "f64" }, height: { kind: "f64" } } },
            { name: "Point", fields: null },
          ],
        },
      },
      {
        kind: "enum",
        variants: [
          { name: "Red", fields: null },
          { name: "Green", fields: null },
          { name: "Blue", fields: null },
        ],
      },
    ],
  },
  processMessage: {
    args: [
      {
        kind: "enum",
        variants: [
          { name: "Text", fields: { kind: "string" } },
          { name: "Number", fields: { kind: "i64" } },
          { name: "Data", fields: { kind: "bytes" } },
        ],
      },
    ],
  },
  getPoints: { args: [{ kind: "u32" }] },
  swapPair: { args: [{ kind: "tuple", elements: [{ kind: "i32" }, { kind: "string" }] }] },
};

// Serializers for runtime channel binding
export const testbed_serializers: BindingSerializers = {
  getTxSerializer(schema: Schema): (value: unknown) => Uint8Array {
    switch (schema.kind) {
      case "bool":
        return (v) => encodeBool(v as boolean);
      case "u8":
        return (v) => encodeU8(v as number);
      case "i8":
        return (v) => encodeI8(v as number);
      case "u16":
        return (v) => encodeU16(v as number);
      case "i16":
        return (v) => encodeI16(v as number);
      case "u32":
        return (v) => encodeU32(v as number);
      case "i32":
        return (v) => encodeI32(v as number);
      case "u64":
        return (v) => encodeU64(v as bigint);
      case "i64":
        return (v) => encodeI64(v as bigint);
      case "f32":
        return (v) => encodeF32(v as number);
      case "f64":
        return (v) => encodeF64(v as number);
      case "string":
        return (v) => encodeString(v as string);
      case "bytes":
        return (v) => encodeBytes(v as Uint8Array);
      default:
        throw new Error(`Unsupported schema kind for Tx: ${schema.kind}`);
    }
  },
  getRxDeserializer(schema: Schema): (bytes: Uint8Array) => unknown {
    switch (schema.kind) {
      case "bool":
        return (b) => decodeBool(b, 0).value;
      case "u8":
        return (b) => decodeU8(b, 0).value;
      case "i8":
        return (b) => decodeI8(b, 0).value;
      case "u16":
        return (b) => decodeU16(b, 0).value;
      case "i16":
        return (b) => decodeI16(b, 0).value;
      case "u32":
        return (b) => decodeU32(b, 0).value;
      case "i32":
        return (b) => decodeI32(b, 0).value;
      case "u64":
        return (b) => decodeU64(b, 0).value;
      case "i64":
        return (b) => decodeI64(b, 0).value;
      case "f32":
        return (b) => decodeF32(b, 0).value;
      case "f64":
        return (b) => decodeF64(b, 0).value;
      case "string":
        return (b) => decodeString(b, 0).value;
      case "bytes":
        return (b) => decodeBytes(b, 0).value;
      default:
        throw new Error(`Unsupported schema kind for Rx: ${schema.kind}`);
    }
  },
};
