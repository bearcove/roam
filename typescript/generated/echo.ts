// @generated by roam-codegen
// DO NOT EDIT - regenerate with `cargo xtask codegen --typescript`

import type { MethodHandler, Connection, MessageTransport, DecodeResult } from "@bearcove/roam-core";
import {
  encodeResultOk, encodeResultErr, encodeInvalidPayload,
  concat, encodeVarint, decodeVarintNumber,
  encodeBool, decodeBool,
  encodeU8, decodeU8, encodeI8, decodeI8,
  encodeU16, decodeU16, encodeI16, decodeI16,
  encodeU32, decodeU32, encodeI32, decodeI32,
  encodeU64, decodeU64, encodeI64, decodeI64,
  encodeF32, decodeF32, encodeF64, decodeF64,
  encodeString, decodeString,
  encodeBytes, decodeBytes,
  encodeOption, decodeOption,
  encodeVec, decodeVec,
  encodeTuple2, decodeTuple2, encodeTuple3, decodeTuple3,
  encodeEnumVariant, decodeEnumVariant,
} from "@bearcove/roam-core";

export const METHOD_ID = {
  echo: 0x3d66dd9ee36b4240n,
  reverse: 0x268246d3219503fbn,
} as const;

// Type definitions
export type EchoRequest = [string];
export type EchoResponse = string;

export type ReverseRequest = [string];
export type ReverseResponse = string;

// Caller interface for Echo
export interface EchoCaller {
  /**  Echoes the message back. */
  echo(message: string): Promise<string>;
  /**  Returns the message reversed. */
  reverse(message: string): Promise<string>;
}

// Client implementation for Echo
export class EchoClient<T extends MessageTransport = MessageTransport> implements EchoCaller {
  private conn: Connection<T>;

  constructor(conn: Connection<T>) {
    this.conn = conn;
  }

  /**  Echoes the message back. */
  async echo(message: string): Promise<string> {
    const payload = encodeString(message);
    const response = await this.conn.call(0x3d66dd9ee36b4240n, payload);
    const buf = response;
    const variant = decodeVarintNumber(buf, 0);
    if (variant.value !== 0) {
      throw new Error("RPC returned error");
    }
    let offset = variant.next;
    const _result_r = decodeString(buf, offset); const result = _result_r.value; offset = _result_r.next;
    return result;
  }

  /**  Returns the message reversed. */
  async reverse(message: string): Promise<string> {
    const payload = encodeString(message);
    const response = await this.conn.call(0x268246d3219503fbn, payload);
    const buf = response;
    const variant = decodeVarintNumber(buf, 0);
    if (variant.value !== 0) {
      throw new Error("RPC returned error");
    }
    let offset = variant.next;
    const _result_r = decodeString(buf, offset); const result = _result_r.value; offset = _result_r.next;
    return result;
  }

}

// Handler interface for Echo
export interface EchoHandler {
  echo(message: string): Promise<string> | string;
  reverse(message: string): Promise<string> | string;
}

// Method handlers for Echo
export const echo_methodHandlers = new Map<bigint, MethodHandler<EchoHandler>>([
  [0x3d66dd9ee36b4240n, async (handler, payload) => {
    try {
      const buf = payload;
      let offset = 0;
      const _message_r = decodeString(buf, offset); const message = _message_r.value; offset = _message_r.next;
      if (offset !== buf.length) throw new Error("args: trailing bytes");
      const result = await handler.echo(message);
      return encodeResultOk(encodeString(result));
    } catch (e) {
      return encodeResultErr(encodeInvalidPayload());
    }
  }],
  [0x268246d3219503fbn, async (handler, payload) => {
    try {
      const buf = payload;
      let offset = 0;
      const _message_r = decodeString(buf, offset); const message = _message_r.value; offset = _message_r.next;
      if (offset !== buf.length) throw new Error("args: trailing bytes");
      const result = await handler.reverse(message);
      return encodeResultOk(encodeString(result));
    } catch (e) {
      return encodeResultErr(encodeInvalidPayload());
    }
  }],
]);
