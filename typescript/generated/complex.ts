// @generated by roam-codegen
// DO NOT EDIT - regenerate with `cargo xtask codegen --typescript`

import type { MethodHandler, Connection, MessageTransport, DecodeResult } from "@bearcove/roam-core";
import {
  encodeResultOk, encodeResultErr, encodeInvalidPayload,
  concat, encodeVarint, decodeVarintNumber,
  encodeBool, decodeBool,
  encodeU8, decodeU8, encodeI8, decodeI8,
  encodeU16, decodeU16, encodeI16, decodeI16,
  encodeU32, decodeU32, encodeI32, decodeI32,
  encodeU64, decodeU64, encodeI64, decodeI64,
  encodeF32, decodeF32, encodeF64, decodeF64,
  encodeString, decodeString,
  encodeBytes, decodeBytes,
  encodeOption, decodeOption,
  encodeVec, decodeVec,
  encodeTuple2, decodeTuple2, encodeTuple3, decodeTuple3,
  encodeEnumVariant, decodeEnumVariant,
} from "@bearcove/roam-core";

export const METHOD_ID = {
  echoPoint: 0x2d63c506560d6860n,
  createPerson: 0xd46ebd8ccb8451aan,
  rectangleArea: 0xe0cabf6ffa942e2dn,
  parseColor: 0xe60617451e5db639n,
  shapeArea: 0x274adbd1d89c41a2n,
  createCanvas: 0x81920263f3a7f479n,
  processMessage: 0xf500f958b345a863n,
  getPoints: 0x627cd544915da400n,
  swapPair: 0x7c3d0ae4f0433b6bn,
} as const;

// Type definitions
export type EchoPointRequest = [{ x: number; y: number }];
export type EchoPointResponse = { x: number; y: number };

export type CreatePersonRequest = [
  string, // name
  number, // age
  string | null, // email
];
export type CreatePersonResponse = { name: string; age: number; email: string | null };

export type RectangleAreaRequest = [{ top_left: { x: number; y: number }; bottom_right: { x: number; y: number }; label: string | null }];
export type RectangleAreaResponse = number;

export type ParseColorRequest = [string];
export type ParseColorResponse = { tag: 'Red' } | { tag: 'Green' } | { tag: 'Blue' } | null;

export type ShapeAreaRequest = [{ tag: 'Circle'; radius: number } | { tag: 'Rectangle'; width: number; height: number } | { tag: 'Point' }];
export type ShapeAreaResponse = number;

export type CreateCanvasRequest = [
  string, // name
  ({ tag: 'Circle'; radius: number } | { tag: 'Rectangle'; width: number; height: number } | { tag: 'Point' })[], // shapes
  { tag: 'Red' } | { tag: 'Green' } | { tag: 'Blue' }, // background
];
export type CreateCanvasResponse = { name: string; shapes: ({ tag: 'Circle'; radius: number } | { tag: 'Rectangle'; width: number; height: number } | { tag: 'Point' })[]; background: { tag: 'Red' } | { tag: 'Green' } | { tag: 'Blue' } };

export type ProcessMessageRequest = [{ tag: 'Text'; value: string } | { tag: 'Number'; value: bigint } | { tag: 'Data'; value: Uint8Array }];
export type ProcessMessageResponse = { tag: 'Text'; value: string } | { tag: 'Number'; value: bigint } | { tag: 'Data'; value: Uint8Array };

export type GetPointsRequest = [number];
export type GetPointsResponse = { x: number; y: number }[];

export type SwapPairRequest = [[number, string]];
export type SwapPairResponse = [string, number];

// Caller interface for Complex
export interface ComplexCaller {
  /**  Echo a point back. */
  echoPoint(point: { x: number; y: number }): Promise<{ x: number; y: number }>;
  /**  Create a person and return it. */
  createPerson(name: string, age: number, email: string | null): Promise<{ name: string; age: number; email: string | null }>;
  /**  Calculate the area of a rectangle. */
  rectangleArea(rect: { top_left: { x: number; y: number }; bottom_right: { x: number; y: number }; label: string | null }): Promise<number>;
  /**  Get a color by name. */
  parseColor(name: string): Promise<{ tag: 'Red' } | { tag: 'Green' } | { tag: 'Blue' } | null>;
  /**  Calculate the area of a shape. */
  shapeArea(shape: { tag: 'Circle'; radius: number } | { tag: 'Rectangle'; width: number; height: number } | { tag: 'Point' }): Promise<number>;
  /**  Create a canvas with given shapes. */
  createCanvas(name: string, shapes: ({ tag: 'Circle'; radius: number } | { tag: 'Rectangle'; width: number; height: number } | { tag: 'Point' })[], background: { tag: 'Red' } | { tag: 'Green' } | { tag: 'Blue' }): Promise<{ name: string; shapes: ({ tag: 'Circle'; radius: number } | { tag: 'Rectangle'; width: number; height: number } | { tag: 'Point' })[]; background: { tag: 'Red' } | { tag: 'Green' } | { tag: 'Blue' } }>;
  /**  Process a message and return a response. */
  processMessage(msg: { tag: 'Text'; value: string } | { tag: 'Number'; value: bigint } | { tag: 'Data'; value: Uint8Array }): Promise<{ tag: 'Text'; value: string } | { tag: 'Number'; value: bigint } | { tag: 'Data'; value: Uint8Array }>;
  /**  Return multiple points. */
  getPoints(count: number): Promise<{ x: number; y: number }[]>;
  /**  Test tuple types. */
  swapPair(pair: [number, string]): Promise<[string, number]>;
}

// Client implementation for Complex
export class ComplexClient<T extends MessageTransport = MessageTransport> implements ComplexCaller {
  private conn: Connection<T>;

  constructor(conn: Connection<T>) {
    this.conn = conn;
  }

  /**  Echo a point back. */
  async echoPoint(point: { x: number; y: number }): Promise<{ x: number; y: number }> {
    const payload = concat(encodeI32(point.x), encodeI32(point.y));
    const response = await this.conn.call(0x2d63c506560d6860n, payload);
    const buf = response;
    const variant = decodeVarintNumber(buf, 0);
    if (variant.value !== 0) {
      throw new Error("RPC returned error");
    }
    let offset = variant.next;
    const _result_f0_r = decodeI32(buf, offset); const result_f0 = _result_f0_r.value; offset = _result_f0_r.next;
const _result_f1_r = decodeI32(buf, offset); const result_f1 = _result_f1_r.value; offset = _result_f1_r.next;
const result = { x: result_f0, y: result_f1 };
    return result;
  }

  /**  Create a person and return it. */
  async createPerson(name: string, age: number, email: string | null): Promise<{ name: string; age: number; email: string | null }> {
    const payload = concat(encodeString(name), encodeU8(age), encodeOption(email, (v) => encodeString(v)));
    const response = await this.conn.call(0xd46ebd8ccb8451aan, payload);
    const buf = response;
    const variant = decodeVarintNumber(buf, 0);
    if (variant.value !== 0) {
      throw new Error("RPC returned error");
    }
    let offset = variant.next;
    const _result_f0_r = decodeString(buf, offset); const result_f0 = _result_f0_r.value; offset = _result_f0_r.next;
const _result_f1_r = decodeU8(buf, offset); const result_f1 = _result_f1_r.value; offset = _result_f1_r.next;
const _result_f2_r = decodeOption(buf, offset, (buf, off) => decodeString(buf, off)); const result_f2 = _result_f2_r.value; offset = _result_f2_r.next;
const result = { name: result_f0, age: result_f1, email: result_f2 };
    return result;
  }

  /**  Calculate the area of a rectangle. */
  async rectangleArea(rect: { top_left: { x: number; y: number }; bottom_right: { x: number; y: number }; label: string | null }): Promise<number> {
    const payload = concat(concat(encodeI32(rect.top_left.x), encodeI32(rect.top_left.y)), concat(encodeI32(rect.bottom_right.x), encodeI32(rect.bottom_right.y)), encodeOption(rect.label, (v) => encodeString(v)));
    const response = await this.conn.call(0xe0cabf6ffa942e2dn, payload);
    const buf = response;
    const variant = decodeVarintNumber(buf, 0);
    if (variant.value !== 0) {
      throw new Error("RPC returned error");
    }
    let offset = variant.next;
    const _result_r = decodeF64(buf, offset); const result = _result_r.value; offset = _result_r.next;
    return result;
  }

  /**  Get a color by name. */
  async parseColor(name: string): Promise<{ tag: 'Red' } | { tag: 'Green' } | { tag: 'Blue' } | null> {
    const payload = encodeString(name);
    const response = await this.conn.call(0xe60617451e5db639n, payload);
    const buf = response;
    const variant = decodeVarintNumber(buf, 0);
    if (variant.value !== 0) {
      throw new Error("RPC returned error");
    }
    let offset = variant.next;
    const _result_r = decodeOption(buf, offset, (buf: Uint8Array, off: number): DecodeResult<any> => { let o = off;
  const disc = decodeEnumVariant(buf, o); o = disc.next;
  switch (disc.value) {
    case 0: return { value: { tag: 'Red' }, next: o };
    case 1: return { value: { tag: 'Green' }, next: o };
    case 2: return { value: { tag: 'Blue' }, next: o };
    default: throw new Error(`unknown enum variant: ${disc.value}`);
  }
}); const result = _result_r.value; offset = _result_r.next;
    return result;
  }

  /**  Calculate the area of a shape. */
  async shapeArea(shape: { tag: 'Circle'; radius: number } | { tag: 'Rectangle'; width: number; height: number } | { tag: 'Point' }): Promise<number> {
    const payload = (() => { switch (shape.tag) {
      case 'Circle': return concat(encodeEnumVariant(0), encodeF64(shape.radius));
      case 'Rectangle': return concat(encodeEnumVariant(1), encodeF64(shape.width), encodeF64(shape.height));
      case 'Point': return encodeEnumVariant(2);
      default: throw new Error('unknown enum variant'); } })();
    const response = await this.conn.call(0x274adbd1d89c41a2n, payload);
    const buf = response;
    const variant = decodeVarintNumber(buf, 0);
    if (variant.value !== 0) {
      throw new Error("RPC returned error");
    }
    let offset = variant.next;
    const _result_r = decodeF64(buf, offset); const result = _result_r.value; offset = _result_r.next;
    return result;
  }

  /**  Create a canvas with given shapes. */
  async createCanvas(name: string, shapes: ({ tag: 'Circle'; radius: number } | { tag: 'Rectangle'; width: number; height: number } | { tag: 'Point' })[], background: { tag: 'Red' } | { tag: 'Green' } | { tag: 'Blue' }): Promise<{ name: string; shapes: ({ tag: 'Circle'; radius: number } | { tag: 'Rectangle'; width: number; height: number } | { tag: 'Point' })[]; background: { tag: 'Red' } | { tag: 'Green' } | { tag: 'Blue' } }> {
    const payload = concat(encodeString(name), encodeVec(shapes, (item) => (() => { switch (item.tag) {
      case 'Circle': return concat(encodeEnumVariant(0), encodeF64(item.radius));
      case 'Rectangle': return concat(encodeEnumVariant(1), encodeF64(item.width), encodeF64(item.height));
      case 'Point': return encodeEnumVariant(2);
      default: throw new Error('unknown enum variant'); } })()), (() => { switch (background.tag) {
      case 'Red': return encodeEnumVariant(0);
      case 'Green': return encodeEnumVariant(1);
      case 'Blue': return encodeEnumVariant(2);
      default: throw new Error('unknown enum variant'); } })());
    const response = await this.conn.call(0x81920263f3a7f479n, payload);
    const buf = response;
    const variant = decodeVarintNumber(buf, 0);
    if (variant.value !== 0) {
      throw new Error("RPC returned error");
    }
    let offset = variant.next;
    const _result_f0_r = decodeString(buf, offset); const result_f0 = _result_f0_r.value; offset = _result_f0_r.next;
const _result_f1_r = decodeVec(buf, offset, (buf: Uint8Array, off: number): DecodeResult<any> => { let o = off;
  const disc = decodeEnumVariant(buf, o); o = disc.next;
  switch (disc.value) {
    case 0: {
      const _f0_r = decodeF64(buf, o); const f0 = _f0_r.value; o = _f0_r.next;
      return { value: { tag: 'Circle', radius: f0 }, next: o };
    }
    case 1: {
      const _f0_r = decodeF64(buf, o); const f0 = _f0_r.value; o = _f0_r.next;
      const _f1_r = decodeF64(buf, o); const f1 = _f1_r.value; o = _f1_r.next;
      return { value: { tag: 'Rectangle', width: f0, height: f1 }, next: o };
    }
    case 2: return { value: { tag: 'Point' }, next: o };
    default: throw new Error(`unknown enum variant: ${disc.value}`);
  }
}); const result_f1 = _result_f1_r.value; offset = _result_f1_r.next;
const _result_f2_disc = decodeEnumVariant(buf, offset); offset = _result_f2_disc.next;
let result_f2: { tag: 'Red' } | { tag: 'Green' } | { tag: 'Blue' };
switch (_result_f2_disc.value) {
  case 0: {
    result_f2 = { tag: 'Red' } as any;
    break;
  }
  case 1: {
    result_f2 = { tag: 'Green' } as any;
    break;
  }
  case 2: {
    result_f2 = { tag: 'Blue' } as any;
    break;
  }
  default: throw new Error(`unknown enum variant: ${_result_f2_disc.value}`);
}
const result = { name: result_f0, shapes: result_f1, background: result_f2 };
    return result;
  }

  /**  Process a message and return a response. */
  async processMessage(msg: { tag: 'Text'; value: string } | { tag: 'Number'; value: bigint } | { tag: 'Data'; value: Uint8Array }): Promise<{ tag: 'Text'; value: string } | { tag: 'Number'; value: bigint } | { tag: 'Data'; value: Uint8Array }> {
    const payload = (() => { switch (msg.tag) {
      case 'Text': return concat(encodeEnumVariant(0), encodeString(msg.value));
      case 'Number': return concat(encodeEnumVariant(1), encodeI64(msg.value));
      case 'Data': return concat(encodeEnumVariant(2), encodeBytes(msg.value));
      default: throw new Error('unknown enum variant'); } })();
    const response = await this.conn.call(0xf500f958b345a863n, payload);
    const buf = response;
    const variant = decodeVarintNumber(buf, 0);
    if (variant.value !== 0) {
      throw new Error("RPC returned error");
    }
    let offset = variant.next;
    const _result_disc = decodeEnumVariant(buf, offset); offset = _result_disc.next;
let result: { tag: 'Text'; value: string } | { tag: 'Number'; value: bigint } | { tag: 'Data'; value: Uint8Array };
switch (_result_disc.value) {
  case 0: {
    const _result_val_r = decodeString(buf, offset); const result_val = _result_val_r.value; offset = _result_val_r.next;
    result = { tag: 'Text', value: result_val } as any;
    break;
  }
  case 1: {
    const _result_val_r = decodeI64(buf, offset); const result_val = _result_val_r.value; offset = _result_val_r.next;
    result = { tag: 'Number', value: result_val } as any;
    break;
  }
  case 2: {
    const _result_val_r = decodeBytes(buf, offset); const result_val = _result_val_r.value; offset = _result_val_r.next;
    result = { tag: 'Data', value: result_val } as any;
    break;
  }
  default: throw new Error(`unknown enum variant: ${_result_disc.value}`);
}
    return result;
  }

  /**  Return multiple points. */
  async getPoints(count: number): Promise<{ x: number; y: number }[]> {
    const payload = encodeU32(count);
    const response = await this.conn.call(0x627cd544915da400n, payload);
    const buf = response;
    const variant = decodeVarintNumber(buf, 0);
    if (variant.value !== 0) {
      throw new Error("RPC returned error");
    }
    let offset = variant.next;
    const _result_r = decodeVec(buf, offset, (buf: Uint8Array, off: number) => { let o = off;
  const _f0_r = decodeI32(buf, o); const f0 = _f0_r.value; o = _f0_r.next;
  const _f1_r = decodeI32(buf, o); const f1 = _f1_r.value; o = _f1_r.next;
  return { value: { x: f0, y: f1 }, next: o };
}); const result = _result_r.value; offset = _result_r.next;
    return result;
  }

  /**  Test tuple types. */
  async swapPair(pair: [number, string]): Promise<[string, number]> {
    const payload = concat(encodeI32(pair[0]), encodeString(pair[1]));
    const response = await this.conn.call(0x7c3d0ae4f0433b6bn, payload);
    const buf = response;
    const variant = decodeVarintNumber(buf, 0);
    if (variant.value !== 0) {
      throw new Error("RPC returned error");
    }
    let offset = variant.next;
    const _result_r = decodeTuple2(buf, offset, (buf, off) => decodeString(buf, off), (buf, off) => decodeI32(buf, off)); const result = _result_r.value; offset = _result_r.next;
    return result;
  }

}

// Handler interface for Complex
export interface ComplexHandler {
  echoPoint(point: { x: number; y: number }): Promise<{ x: number; y: number }> | { x: number; y: number };
  createPerson(name: string, age: number, email: string | null): Promise<{ name: string; age: number; email: string | null }> | { name: string; age: number; email: string | null };
  rectangleArea(rect: { top_left: { x: number; y: number }; bottom_right: { x: number; y: number }; label: string | null }): Promise<number> | number;
  parseColor(name: string): Promise<{ tag: 'Red' } | { tag: 'Green' } | { tag: 'Blue' } | null> | { tag: 'Red' } | { tag: 'Green' } | { tag: 'Blue' } | null;
  shapeArea(shape: { tag: 'Circle'; radius: number } | { tag: 'Rectangle'; width: number; height: number } | { tag: 'Point' }): Promise<number> | number;
  createCanvas(name: string, shapes: ({ tag: 'Circle'; radius: number } | { tag: 'Rectangle'; width: number; height: number } | { tag: 'Point' })[], background: { tag: 'Red' } | { tag: 'Green' } | { tag: 'Blue' }): Promise<{ name: string; shapes: ({ tag: 'Circle'; radius: number } | { tag: 'Rectangle'; width: number; height: number } | { tag: 'Point' })[]; background: { tag: 'Red' } | { tag: 'Green' } | { tag: 'Blue' } }> | { name: string; shapes: ({ tag: 'Circle'; radius: number } | { tag: 'Rectangle'; width: number; height: number } | { tag: 'Point' })[]; background: { tag: 'Red' } | { tag: 'Green' } | { tag: 'Blue' } };
  processMessage(msg: { tag: 'Text'; value: string } | { tag: 'Number'; value: bigint } | { tag: 'Data'; value: Uint8Array }): Promise<{ tag: 'Text'; value: string } | { tag: 'Number'; value: bigint } | { tag: 'Data'; value: Uint8Array }> | { tag: 'Text'; value: string } | { tag: 'Number'; value: bigint } | { tag: 'Data'; value: Uint8Array };
  getPoints(count: number): Promise<{ x: number; y: number }[]> | { x: number; y: number }[];
  swapPair(pair: [number, string]): Promise<[string, number]> | [string, number];
}

// Method handlers for Complex
export const complex_methodHandlers = new Map<bigint, MethodHandler<ComplexHandler>>([
  [0x2d63c506560d6860n, async (handler, payload) => {
    try {
      const buf = payload;
      let offset = 0;
      const _point_f0_r = decodeI32(buf, offset); const point_f0 = _point_f0_r.value; offset = _point_f0_r.next;
const _point_f1_r = decodeI32(buf, offset); const point_f1 = _point_f1_r.value; offset = _point_f1_r.next;
const point = { x: point_f0, y: point_f1 };
      if (offset !== buf.length) throw new Error("args: trailing bytes");
      const result = await handler.echoPoint(point);
      return encodeResultOk(concat(encodeI32(result.x), encodeI32(result.y)));
    } catch (e) {
      return encodeResultErr(encodeInvalidPayload());
    }
  }],
  [0xd46ebd8ccb8451aan, async (handler, payload) => {
    try {
      const buf = payload;
      let offset = 0;
      const _name_r = decodeString(buf, offset); const name = _name_r.value; offset = _name_r.next;
      const _age_r = decodeU8(buf, offset); const age = _age_r.value; offset = _age_r.next;
      const _email_r = decodeOption(buf, offset, (buf, off) => decodeString(buf, off)); const email = _email_r.value; offset = _email_r.next;
      if (offset !== buf.length) throw new Error("args: trailing bytes");
      const result = await handler.createPerson(name, age, email);
      return encodeResultOk(concat(encodeString(result.name), encodeU8(result.age), encodeOption(result.email, (v) => encodeString(v))));
    } catch (e) {
      return encodeResultErr(encodeInvalidPayload());
    }
  }],
  [0xe0cabf6ffa942e2dn, async (handler, payload) => {
    try {
      const buf = payload;
      let offset = 0;
      const _rect_f0_f0_r = decodeI32(buf, offset); const rect_f0_f0 = _rect_f0_f0_r.value; offset = _rect_f0_f0_r.next;
const _rect_f0_f1_r = decodeI32(buf, offset); const rect_f0_f1 = _rect_f0_f1_r.value; offset = _rect_f0_f1_r.next;
const rect_f0 = { x: rect_f0_f0, y: rect_f0_f1 };
const _rect_f1_f0_r = decodeI32(buf, offset); const rect_f1_f0 = _rect_f1_f0_r.value; offset = _rect_f1_f0_r.next;
const _rect_f1_f1_r = decodeI32(buf, offset); const rect_f1_f1 = _rect_f1_f1_r.value; offset = _rect_f1_f1_r.next;
const rect_f1 = { x: rect_f1_f0, y: rect_f1_f1 };
const _rect_f2_r = decodeOption(buf, offset, (buf, off) => decodeString(buf, off)); const rect_f2 = _rect_f2_r.value; offset = _rect_f2_r.next;
const rect = { top_left: rect_f0, bottom_right: rect_f1, label: rect_f2 };
      if (offset !== buf.length) throw new Error("args: trailing bytes");
      const result = await handler.rectangleArea(rect);
      return encodeResultOk(encodeF64(result));
    } catch (e) {
      return encodeResultErr(encodeInvalidPayload());
    }
  }],
  [0xe60617451e5db639n, async (handler, payload) => {
    try {
      const buf = payload;
      let offset = 0;
      const _name_r = decodeString(buf, offset); const name = _name_r.value; offset = _name_r.next;
      if (offset !== buf.length) throw new Error("args: trailing bytes");
      const result = await handler.parseColor(name);
      return encodeResultOk(encodeOption(result, (v) => (() => { switch (v.tag) {
      case 'Red': return encodeEnumVariant(0);
      case 'Green': return encodeEnumVariant(1);
      case 'Blue': return encodeEnumVariant(2);
      default: throw new Error('unknown enum variant'); } })()));
    } catch (e) {
      return encodeResultErr(encodeInvalidPayload());
    }
  }],
  [0x274adbd1d89c41a2n, async (handler, payload) => {
    try {
      const buf = payload;
      let offset = 0;
      const _shape_disc = decodeEnumVariant(buf, offset); offset = _shape_disc.next;
let shape: { tag: 'Circle'; radius: number } | { tag: 'Rectangle'; width: number; height: number } | { tag: 'Point' };
switch (_shape_disc.value) {
  case 0: {
    const _shape_v0f0_r = decodeF64(buf, offset); const shape_v0f0 = _shape_v0f0_r.value; offset = _shape_v0f0_r.next;
    shape = { tag: 'Circle', radius: shape_v0f0 } as any;
    break;
  }
  case 1: {
    const _shape_v1f0_r = decodeF64(buf, offset); const shape_v1f0 = _shape_v1f0_r.value; offset = _shape_v1f0_r.next;
    const _shape_v1f1_r = decodeF64(buf, offset); const shape_v1f1 = _shape_v1f1_r.value; offset = _shape_v1f1_r.next;
    shape = { tag: 'Rectangle', width: shape_v1f0, height: shape_v1f1 } as any;
    break;
  }
  case 2: {
    shape = { tag: 'Point' } as any;
    break;
  }
  default: throw new Error(`unknown enum variant: ${_shape_disc.value}`);
}
      if (offset !== buf.length) throw new Error("args: trailing bytes");
      const result = await handler.shapeArea(shape);
      return encodeResultOk(encodeF64(result));
    } catch (e) {
      return encodeResultErr(encodeInvalidPayload());
    }
  }],
  [0x81920263f3a7f479n, async (handler, payload) => {
    try {
      const buf = payload;
      let offset = 0;
      const _name_r = decodeString(buf, offset); const name = _name_r.value; offset = _name_r.next;
      const _shapes_r = decodeVec(buf, offset, (buf: Uint8Array, off: number): DecodeResult<any> => { let o = off;
  const disc = decodeEnumVariant(buf, o); o = disc.next;
  switch (disc.value) {
    case 0: {
      const _f0_r = decodeF64(buf, o); const f0 = _f0_r.value; o = _f0_r.next;
      return { value: { tag: 'Circle', radius: f0 }, next: o };
    }
    case 1: {
      const _f0_r = decodeF64(buf, o); const f0 = _f0_r.value; o = _f0_r.next;
      const _f1_r = decodeF64(buf, o); const f1 = _f1_r.value; o = _f1_r.next;
      return { value: { tag: 'Rectangle', width: f0, height: f1 }, next: o };
    }
    case 2: return { value: { tag: 'Point' }, next: o };
    default: throw new Error(`unknown enum variant: ${disc.value}`);
  }
}); const shapes = _shapes_r.value; offset = _shapes_r.next;
      const _background_disc = decodeEnumVariant(buf, offset); offset = _background_disc.next;
let background: { tag: 'Red' } | { tag: 'Green' } | { tag: 'Blue' };
switch (_background_disc.value) {
  case 0: {
    background = { tag: 'Red' } as any;
    break;
  }
  case 1: {
    background = { tag: 'Green' } as any;
    break;
  }
  case 2: {
    background = { tag: 'Blue' } as any;
    break;
  }
  default: throw new Error(`unknown enum variant: ${_background_disc.value}`);
}
      if (offset !== buf.length) throw new Error("args: trailing bytes");
      const result = await handler.createCanvas(name, shapes, background);
      return encodeResultOk(concat(encodeString(result.name), encodeVec(result.shapes, (item) => (() => { switch (item.tag) {
      case 'Circle': return concat(encodeEnumVariant(0), encodeF64(item.radius));
      case 'Rectangle': return concat(encodeEnumVariant(1), encodeF64(item.width), encodeF64(item.height));
      case 'Point': return encodeEnumVariant(2);
      default: throw new Error('unknown enum variant'); } })()), (() => { switch (result.background.tag) {
      case 'Red': return encodeEnumVariant(0);
      case 'Green': return encodeEnumVariant(1);
      case 'Blue': return encodeEnumVariant(2);
      default: throw new Error('unknown enum variant'); } })()));
    } catch (e) {
      return encodeResultErr(encodeInvalidPayload());
    }
  }],
  [0xf500f958b345a863n, async (handler, payload) => {
    try {
      const buf = payload;
      let offset = 0;
      const _msg_disc = decodeEnumVariant(buf, offset); offset = _msg_disc.next;
let msg: { tag: 'Text'; value: string } | { tag: 'Number'; value: bigint } | { tag: 'Data'; value: Uint8Array };
switch (_msg_disc.value) {
  case 0: {
    const _msg_val_r = decodeString(buf, offset); const msg_val = _msg_val_r.value; offset = _msg_val_r.next;
    msg = { tag: 'Text', value: msg_val } as any;
    break;
  }
  case 1: {
    const _msg_val_r = decodeI64(buf, offset); const msg_val = _msg_val_r.value; offset = _msg_val_r.next;
    msg = { tag: 'Number', value: msg_val } as any;
    break;
  }
  case 2: {
    const _msg_val_r = decodeBytes(buf, offset); const msg_val = _msg_val_r.value; offset = _msg_val_r.next;
    msg = { tag: 'Data', value: msg_val } as any;
    break;
  }
  default: throw new Error(`unknown enum variant: ${_msg_disc.value}`);
}
      if (offset !== buf.length) throw new Error("args: trailing bytes");
      const result = await handler.processMessage(msg);
      return encodeResultOk((() => { switch (result.tag) {
      case 'Text': return concat(encodeEnumVariant(0), encodeString(result.value));
      case 'Number': return concat(encodeEnumVariant(1), encodeI64(result.value));
      case 'Data': return concat(encodeEnumVariant(2), encodeBytes(result.value));
      default: throw new Error('unknown enum variant'); } })());
    } catch (e) {
      return encodeResultErr(encodeInvalidPayload());
    }
  }],
  [0x627cd544915da400n, async (handler, payload) => {
    try {
      const buf = payload;
      let offset = 0;
      const _count_r = decodeU32(buf, offset); const count = _count_r.value; offset = _count_r.next;
      if (offset !== buf.length) throw new Error("args: trailing bytes");
      const result = await handler.getPoints(count);
      return encodeResultOk(encodeVec(result, (item) => concat(encodeI32(item.x), encodeI32(item.y))));
    } catch (e) {
      return encodeResultErr(encodeInvalidPayload());
    }
  }],
  [0x7c3d0ae4f0433b6bn, async (handler, payload) => {
    try {
      const buf = payload;
      let offset = 0;
      const _pair_r = decodeTuple2(buf, offset, (buf, off) => decodeI32(buf, off), (buf, off) => decodeString(buf, off)); const pair = _pair_r.value; offset = _pair_r.next;
      if (offset !== buf.length) throw new Error("args: trailing bytes");
      const result = await handler.swapPair(pair);
      return encodeResultOk(concat(encodeString(result[0]), encodeI32(result[1])));
    } catch (e) {
      return encodeResultErr(encodeInvalidPayload());
    }
  }],
]);
