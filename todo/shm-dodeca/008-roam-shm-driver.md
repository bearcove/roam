# Phase 008: Roam Driver over SHM (No Hello/Credit Frames)

## Goal

Enable roam RPC services (generated by `#[roam::service]`) to run over `roam-shm`
without relying on `roam-stream`'s byte-stream protocol behaviors.

Concretely: provide the equivalent of “`ConnectionHandle` + driver task” for SHM.

## Current State

- `roam-stream::Driver` assumes a **Hello exchange** and explicit **Credit**
  messages.
- `roam-shm` intentionally rejects `Message::Hello` and `Message::Credit`
  (handshake via segment header, flow control via shared counters / channel table).
- Result: we cannot currently drive a roam connection over SHM while using the
  existing `ConnectionHandle`/client generation story.

## Target API

Host side (one guest):

```rust
use roam_shm::{ShmHost, PeerId};
use roam_shm::driver::{establish_host_peer, ShmDriver};

let (handle, driver) = establish_host_peer(&mut host, peer_id, dispatcher)?;
tokio::spawn(driver.run());
// `handle` is the thing generated roam clients wrap
```

Guest side:

```rust
use roam_shm::driver::{establish_guest, ShmDriver};

let (handle, driver) = establish_guest(guest_transport, dispatcher)?;
tokio::spawn(driver.run());
```

## Design Direction

Refactor to share logic with `roam-stream` by splitting the driver into:

1. **Driver core** (transport-agnostic):
   - request dispatch, response routing, in-flight dedupe
   - task ordering (Data/Close before Response)
   - channel registry integration
2. **Handshake backend**:
   - Stream: Hello exchange → Negotiated
   - SHM: read segment header → Negotiated (implicit handshake)
3. **Flow-control backend**:
   - Stream: explicit `Message::Credit`
   - SHM: channel table counters + wakeups (no `Message::Credit`)

This avoids duplicating the bulk of the driver while keeping SHM semantics
correct.

## Implementation Plan

### 1. Extract Driver Core

- Move the message-loop core out of `roam-stream` into a reusable module
  (likely `roam-session` or a new `roam-driver` crate).
- Make the core generic over:
  - `MessageTransport` (already exists in `roam-stream`)
  - a `Handshake` provider (produces `Negotiated`)
  - a `FlowControl` provider (credit accounting + wakeups)

### 2. Add SHM Handshake Provider

- Construct `Negotiated` from SHM header values:
  - `initial_credit`
  - `max_channels`
  - any other negotiated constants needed by `ChannelRegistry`
- Ensure SHM connections do **not** send or require `Message::Hello`.

### 3. Add SHM Flow-Control Provider

- Implement credit/wakeup semantics using `ChannelEntry` shared counters.
- Ensure `ChannelRegistry` remains the source of truth for stream/channel IDs
  and ordering; only the credit *mechanism* differs.

### 4. Wire Into roam-shm

- Add `roam_shm::driver::{establish_guest, establish_host_peer}` convenience
  functions that return:
  - `roam_session::ConnectionHandle`
  - a driver future/task (`ShmDriver`) that can be spawned
- Use:
  - `roam_shm::transport::ShmGuestTransport` (guest)
  - a host-side per-peer transport wrapper (host)

## Tasks

- [x] Decide where driver core lives (`roam-session` vs new crate)
  - Decision: Keep drivers separate for now. `roam-session` provides shared
    infrastructure (`ConnectionHandle`, `ChannelRegistry`, `Tx`/`Rx`, `dispatch_call`).
    Each transport has its own driver that uses these building blocks.
- [x] Refactor `roam-stream::Driver` to use driver core
  - Note: Rather than refactoring, we kept `roam-stream::Driver` as-is and
    created `roam-shm::ShmDriver` using the same shared infrastructure.
- [x] Implement SHM handshake provider (no Hello)
  - `ShmNegotiated` reads config from segment header (no wire exchange)
  - Driver rejects `Message::Hello` with `goodbye("shm.handshake")`
- [x] Implement SHM flow-control provider (no Credit messages)
  - Driver rejects `Message::Credit` with `goodbye("shm.flow.no-credit-message")`
  - Uses infinite credit for now (real channel-table flow control in Phase 012)
- [x] Add `roam_shm::driver` module + public API
  - `establish_guest(transport, dispatcher) -> (ConnectionHandle, ShmDriver)`
  - `establish_host_peer(host, peer_id, dispatcher) -> (ConnectionHandle, ShmDriver)`
- [x] Add integration tests: roam service call over SHM with streams (Tx/Rx)
  - Unary calls: `guest_calls_host_echo`, `guest_calls_host_add`, `host_calls_guest`
  - Client streaming: `client_streaming_sum` (client sends `Rx<i32>`, server aggregates)
  - Server streaming: `server_streaming_generate` (server sends via `Tx<i32>`)

## Notes

- This phase is the main “RPC runtime gap” between rapace and roam for dodeca.
- Do **not** “fix” this by making SHM accept `Hello`/`Credit` frames; that
  violates the SHM spec’s implicit handshake and flow control model.

