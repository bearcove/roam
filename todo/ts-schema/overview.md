# TypeScript Schema-Driven Wire Types

## Goal

Implement schema-driven encoding/decoding for roam wire protocol types in TypeScript,
matching the Rust implementation in `roam-wire`. This eliminates hand-coded serialization
and ensures wire compatibility through golden vector testing.

**Key insight**: We should use `roam-codegen` to generate the TypeScript types and schemas
for wire types, just like we do for service types. This ensures consistency and reduces
manual work.

## Current State

| Component | Rust | TypeScript |
|-----------|------|------------|
| Wire types (`Message`, `Hello`, `MetadataValue`) | ✅ `roam-wire/src/lib.rs` with `#[derive(Facet)]` | ✅ `roam-wire/src/types.ts` |
| Serialization | ✅ `facet_postcard::to_vec()` - schema-driven | ✅ `encodeWithSchema()`/`decodeWithSchema()` in `roam-postcard` |
| Schema system | ✅ `facet::Shape` - full type introspection | ✅ `Schema` in `roam-postcard/src/schema.ts` with EnumSchema, TupleSchema, RefSchema |
| Golden vectors | ✅ Generated by `golden_vectors.rs` | ⚠️ Tests primitives only, not wire types |
| Wire codec | ✅ Via `facet_postcard` | ✅ `encodeMessage()`/`decodeMessage()` in `roam-wire/src/codec.ts` |

## Architecture

```
┌─────────────────────────────────────────────────────────────────┐
│                       roam-codegen                               │
│  ┌─────────────────────────────────────────────────────────────┐│
│  │ targets/typescript/                                         ││
│  │ - types.rs     → generates TS types from Shape              ││
│  │ - schema.rs    → generates runtime schemas from Shape       ││
│  │ - encode.rs    → generates encode expressions               ││
│  │ - decode.rs    → generates decode statements                ││
│  │                                                             ││
│  │ NEW: wire.rs   → generates wire types (Message, Hello, etc)││
│  └─────────────────────────────────────────────────────────────┘│
└─────────────────────────────────────────────────────────────────┘
          │
          │ cargo xtask codegen --typescript
          ▼
┌─────────────────────────────────────────────────────────────────┐
│                         roam-wire                                │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────────────────┐  │
│  │ types.ts    │  │ schemas.ts  │  │ codec.ts                │  │
│  │ (GENERATED) │  │ (GENERATED) │  │ encodeMessage()         │  │
│  │ Message     │  │ MessageSchema│ │ decodeMessage()         │  │
│  │ Hello       │  │ HelloSchema  │ │ (uses schema-driven)    │  │
│  │ MetadataVal │  │ etc.        │  │                         │  │
│  └─────────────┘  └─────────────┘  └─────────────────────────┘  │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│                       roam-postcard                              │
│  ┌─────────────────────────────────────────────────────────────┐│
│  │ schema.ts                                                   ││
│  │ - Extended Schema type (tagged enums, tuples)               ││
│  │ - encodeWithSchema(schema, value) → Uint8Array              ││
│  │ - decodeWithSchema(schema, buf, offset) → DecodeResult<T>   ││
│  └─────────────────────────────────────────────────────────────┘│
│  ┌─────────────────────────────────────────────────────────────┐│
│  │ index.ts (existing)                                         ││
│  │ - Primitive encode/decode (encodeU32, decodeString, etc.)   ││
│  └─────────────────────────────────────────────────────────────┘│
└─────────────────────────────────────────────────────────────────┘
```

## Phases

| Phase | File | Status | Description |
|-------|------|--------|-------------|
| 001 | [001-DONE-schema-types.md](./001-DONE-schema-types.md) | ✅ DONE | Extend Schema type (EnumSchema with discriminants, TupleSchema, RefSchema) |
| 002 | [002-DONE-schema-encode.md](./002-DONE-schema-encode.md) | ✅ DONE | Schema-driven encode function (`encodeWithSchema`) |
| 003 | [003-DONE-schema-decode.md](./003-DONE-schema-decode.md) | ✅ DONE | Schema-driven decode function (`decodeWithSchema`) |
| 004 | [004-DONE-codegen-wire.md](./004-DONE-codegen-wire.md) | ✅ DONE | Wire types, schemas, and registry in `roam-wire` |
| 005 | [005-DONE-wire-codec.md](./005-DONE-wire-codec.md) | ✅ DONE | Wire type encode/decode wrapper functions |
| 006 | [006-TODO-golden-tests.md](./006-TODO-golden-tests.md) | TODO | Golden vector tests for wire types |
| 007 | [007-TODO-migrate-connection.md](./007-TODO-migrate-connection.md) | TODO | Migrate connection.ts to use generated types |

## Key Design Decisions

### 1. Use Codegen for Wire Types

Instead of hand-writing TypeScript types and schemas for `Message`, `Hello`, `MetadataValue`:

**Generate them using roam-codegen**, just like we generate service types.

Benefits:
- Single source of truth (Rust types)
- Automatic schema generation from `facet::Shape`
- Consistent with service type generation
- Less manual work, fewer bugs

Implementation:
- Add `generate_wire_types()` function to `roam-codegen/src/targets/typescript/`
- Wire types already have `#[derive(Facet)]`, so we have full `Shape` information
- Generate to `roam-wire/src/generated/` (or similar)

### 2. Schema Location

The extended `Schema` type goes in `roam-postcard` because:
- It's the serialization layer
- `roam-core` depends on `roam-postcard`, not vice versa
- The channeling `Schema` in `roam-core` can import from `roam-postcard`

### 3. Tagged Enum Representation

Rust `#[repr(u8)]` enums with explicit discriminants:
```rust
#[repr(u8)]
pub enum Message {
    Hello(Hello) = 0,
    Goodbye { reason: String } = 1,
    // ...
}
```

Generated TypeScript (discriminated union):
```typescript
export type Message =
  | { tag: 'Hello'; hello: Hello }
  | { tag: 'Goodbye'; reason: string }
  // ...
```

Generated schema (with explicit discriminants):
```typescript
export const MessageSchema: EnumSchema = {
  kind: 'enum',
  variants: [
    { name: 'Hello', discriminant: 0, fields: HelloSchema },
    { name: 'Goodbye', discriminant: 1, fields: { reason: { kind: 'string' } } },
  ]
};
```

Note: `EnumSchema` is unified - the `discriminant` field is optional. When omitted,
the variant's index in the array is used. Wire types use explicit discriminants;
service types can omit them.

### 5. Type References (RefSchema)

Complex/nested types use references instead of inlining:

```typescript
// Instead of duplicating schema inline:
{ name: "Hello", discriminant: 0, fields: { kind: "enum", variants: [...] } }

// Use a reference:
{ name: "Hello", discriminant: 0, fields: { kind: "ref", name: "Hello" } }
```

Benefits:
- **Deduplication**: Same schema isn't repeated inline multiple times
- **Circular types**: A type can reference itself (e.g., linked list nodes)
- **Readability**: Generated schemas are easier to understand

A `SchemaRegistry` maps type names to their schemas:

```typescript
export const wireSchemaRegistry: SchemaRegistry = new Map([
  ["Hello", HelloSchema],
  ["MetadataValue", MetadataValueSchema],
  ["Message", MessageSchema],
]);

// Encode/decode pass the registry to resolve refs
encodeWithSchema(MessageSchema, msg, wireSchemaRegistry);
decodeWithSchema(MessageSchema, buf, 0, wireSchemaRegistry);
```

Type names use facet's `module_path::type_identifier` (or just `type_identifier`
for types in the current module).

### 4. No Hand-Written Constructors

The generated types are plain TypeScript interfaces/type aliases.
Users construct values directly:

```typescript
// Direct construction - no helper functions needed
const msg: Message = {
  tag: 'Request',
  requestId: 1n,
  methodId: 42n,
  metadata: [],
  payload: new Uint8Array([]),
};
```

Type guards can be generated if useful, but constructors add little value.

### 5. Postcard Format Details

- Enum discriminant: varint (not raw byte, even with `#[repr(u8)]`)
- Strings: length-prefixed (varint length + UTF-8 bytes)
- Vecs: length-prefixed (varint count + elements)
- Structs: fields concatenated in order
- Options: 0x00 for None, 0x01 + value for Some
- Tuples: elements concatenated in order

## Success Criteria (Overall)

1. ✅ All wire types (`Message`, `Hello`, `MetadataValue`) have TypeScript definitions
2. ✅ All wire types have schema definitions with explicit discriminants
3. ⬜ `encodeMessage()` produces bytes identical to Rust `facet_postcard::to_vec()` (needs golden tests)
4. ⬜ `decodeMessage()` correctly parses bytes produced by Rust (needs golden tests)
5. ⬜ Golden vector tests pass for all message variants
6. ⬜ `connection.ts` uses generated types (no hand-coded wire format)
7. ✅ Roundtrip tests: encode → decode → compare passes for all variants (177 tests passing)

## Related Files

### Rust (source of truth)
- `rust/roam-wire/src/lib.rs` - Wire type definitions (with `#[derive(Facet)]`)
- `rust/roam-wire/src/bin/golden_vectors.rs` - Golden vector generator
- `rust/roam-codegen/src/targets/typescript/` - Existing TS codegen

### TypeScript (implemented)
- `typescript/packages/roam-postcard/src/schema.ts` - ✅ Extended Schema types (EnumSchema, TupleSchema, RefSchema, SchemaRegistry)
- `typescript/packages/roam-postcard/src/schema_codec.ts` - ✅ `encodeWithSchema()` / `decodeWithSchema()`
- `typescript/packages/roam-wire/src/types.ts` - ✅ Wire type definitions (Message, Hello, MetadataValue)
- `typescript/packages/roam-wire/src/schemas.ts` - ✅ Wire type schemas with explicit discriminants
- `typescript/packages/roam-wire/src/codec.ts` - ✅ encode/decode wrapper functions
- `typescript/packages/roam-wire/src/wire.test.ts` - ✅ Roundtrip tests (67 tests)
- `typescript/packages/roam-core/src/connection.ts` - ⬜ TODO: Migrate to use generated types

### Test fixtures
- `test-fixtures/golden-vectors/wire/` - Binary test vectors from Rust

## Phase Dependencies

```
001 Schema Types
      │
      ├──────────────┐
      ▼              ▼
002 Encode      003 Decode
      │              │
      └──────┬───────┘
             │
             ▼
004 Codegen Wire Types (uses 001 schema types)
             │
             ▼
005 Wire Codec (thin wrappers around generated code)
             │
             ▼
006 Golden Tests
             │
             ▼
007 Migrate connection.ts
```

**Parallelization opportunities:**
- Phases 002 and 003 can be done in parallel after 001

## Quick Reference

### Commands

```bash
# Regenerate golden vectors (after changing Rust wire types)
cargo run -p roam-wire --bin golden_vectors

# Regenerate TypeScript code (after adding wire codegen)
cargo xtask codegen --typescript

# Run TypeScript tests
cd typescript && pnpm test

# Run specific package tests
cd typescript/packages/roam-wire && pnpm test

# Type check
cd typescript && pnpm check
```

### Key Files (Implemented)

| Purpose | File |
|---------|------|
| Schema types | `roam-postcard/src/schema.ts` ✅ |
| Schema encode | `roam-postcard/src/schema_codec.ts` → `encodeWithSchema()` ✅ |
| Schema decode | `roam-postcard/src/schema_codec.ts` → `decodeWithSchema()` ✅ |
| Wire types | `roam-wire/src/types.ts` ✅ |
| Wire schemas | `roam-wire/src/schemas.ts` ✅ |
| Wire codec | `roam-wire/src/codec.ts` ✅ |
| Wire tests | `roam-wire/src/wire.test.ts` ✅ |
| Golden tests | `roam-wire/src/wire.test.ts` (TODO: add golden vectors) |

### Estimated Effort

| Phase | Complexity | Est. Time | Status |
|-------|------------|-----------|--------|
| 001 | Medium | 1-2 hours | ✅ DONE |
| 002 | Medium | 2-3 hours | ✅ DONE |
| 003 | Medium | 2-3 hours | ✅ DONE |
| 004 | Medium | 2-3 hours | ✅ DONE |
| 005 | Low | 1 hour | ✅ DONE |
| 006 | Medium | 2 hours | TODO |
| 007 | Medium | 2-3 hours | TODO |
| **Total** | | **12-17 hours** | ~70% complete |

### Test Summary

- `roam-postcard`: 98 tests (16 postcard + 36 schema + 46 schema_codec)
- `roam-wire`: 73 tests (6 rpc_error + 67 wire)
- `roam-core`: 6 tests (schema re-exports)
- **Total**: 177 tests passing