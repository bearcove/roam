# Phase 006: Golden Vector Tests

**Status**: TODO

## Objective

Implement comprehensive golden vector tests that verify TypeScript wire encoding/decoding
produces bytes identical to Rust's `facet_postcard` serialization. This ensures wire
compatibility between Rust and TypeScript implementations.

Tests use the **generated** types and schemas from Phase 004.

## Background

Golden vectors are pre-computed binary test fixtures generated by the Rust implementation.
They serve as the canonical reference for correct wire format encoding.

Existing infrastructure:
- `rust/roam-wire/src/bin/golden_vectors.rs` generates binary fixtures
- `test-fixtures/golden-vectors/wire/` contains wire message fixtures
- `typescript/packages/roam-postcard/src/postcard.test.ts` tests primitives against fixtures

We need to extend this to cover all wire message types.

## Design

### Test Structure

Create `roam-wire/src/wire.test.ts`:

```typescript
import { describe, it, expect } from "vitest";
import { readFileSync } from "node:fs";
import { join, dirname } from "node:path";
import { fileURLToPath } from "node:url";

import {
  encodeMessage,
  decodeMessage,
  encodeHello,
  decodeHello,
  type Message,
  type Hello,
  type MetadataValue,
} from "@bearcove/roam-wire";

const __dirname = dirname(fileURLToPath(import.meta.url));

/** Load a golden vector from the test-fixtures directory */
function loadGoldenVector(path: string): Uint8Array {
  const projectRoot = join(__dirname, "..", "..", "..", "..");
  const vectorPath = join(projectRoot, "test-fixtures", "golden-vectors", path);
  return new Uint8Array(readFileSync(vectorPath));
}
```

### Test Categories

#### 1. Hello Message Tests

```typescript
describe("Hello encoding", () => {
  it("encodes Hello V1 (small values)", () => {
    const hello: Hello = { tag: "V1", maxPayloadSize: 1024, initialChannelCredit: 64 };
    const encoded = encodeHello(hello);
    const expected = loadGoldenVector("wire/hello_v1_small.bin");
    expect(Array.from(encoded)).toEqual(Array.from(expected));
  });

  it("encodes Hello V1 (typical values)", () => {
    const hello: Hello = { tag: "V1", maxPayloadSize: 1024 * 1024, initialChannelCredit: 64 * 1024 };
    const encoded = encodeHello(hello);
    const expected = loadGoldenVector("wire/hello_v1_typical.bin");
    expect(Array.from(encoded)).toEqual(Array.from(expected));
  });

  it("decodes Hello V1 from Rust bytes", () => {
    const bytes = loadGoldenVector("wire/hello_v1_small.bin");
    const decoded = decodeHello(bytes);
    expect(decoded.value).toEqual({ tag: "V1", maxPayloadSize: 1024, initialChannelCredit: 64 });
    expect(decoded.next).toBe(bytes.length);
  });
});
```

#### 2. Message::Hello Tests

```typescript
describe("Message::Hello encoding", () => {
  it("encodes Message::Hello (small)", () => {
    const msg: Message = { tag: "Hello", hello: { tag: "V1", maxPayloadSize: 1024, initialChannelCredit: 64 } };
    const encoded = encodeMessage(msg);
    const expected = loadGoldenVector("wire/message_hello_small.bin");
    expect(Array.from(encoded)).toEqual(Array.from(expected));
  });

  it("encodes Message::Hello (typical)", () => {
    const msg: Message = { tag: "Hello", hello: { tag: "V1", maxPayloadSize: 1024 * 1024, initialChannelCredit: 64 * 1024 } };
    const encoded = encodeMessage(msg);
    const expected = loadGoldenVector("wire/message_hello_typical.bin");
    expect(Array.from(encoded)).toEqual(Array.from(expected));
  });

  it("decodes Message::Hello from Rust bytes", () => {
    const bytes = loadGoldenVector("wire/message_hello_typical.bin");
    const decoded = decodeMessage(bytes);
    expect(decoded.value.tag).toBe("Hello");
    if (decoded.value.tag === "Hello") {
      expect(decoded.value.hello).toEqual({ tag: "V1", maxPayloadSize: 1024 * 1024, initialChannelCredit: 64 * 1024 });
    }
  });
});
```

#### 3. Message::Goodbye Tests

```typescript
describe("Message::Goodbye encoding", () => {
  it("encodes Message::Goodbye", () => {
    const msg: Message = { tag: "Goodbye", reason: "test" };
    const encoded = encodeMessage(msg);
    const expected = loadGoldenVector("wire/message_goodbye.bin");
    expect(Array.from(encoded)).toEqual(Array.from(expected));
  });

  it("decodes Message::Goodbye from Rust bytes", () => {
    const bytes = loadGoldenVector("wire/message_goodbye.bin");
    const decoded = decodeMessage(bytes);
    expect(decoded.value).toEqual({ tag: "Goodbye", reason: "test" });
  });
});
```

#### 4. Message::Request Tests

```typescript
describe("Message::Request encoding", () => {
  it("encodes empty Request", () => {
    const msg: Message = { tag: "Request", requestId: 1n, methodId: 42n, metadata: [], payload: new Uint8Array([]) };
    const encoded = encodeMessage(msg);
    const expected = loadGoldenVector("wire/message_request_empty.bin");
    expect(Array.from(encoded)).toEqual(Array.from(expected));
  });

  it("encodes Request with payload", () => {
    const msg: Message = { tag: "Request", requestId: 1n, methodId: 42n, metadata: [], payload: new Uint8Array([0xDE, 0xAD, 0xBE, 0xEF]) };
    const encoded = encodeMessage(msg);
    const expected = loadGoldenVector("wire/message_request_with_payload.bin");
    expect(Array.from(encoded)).toEqual(Array.from(expected));
  });

  it("encodes Request with metadata", () => {
    const metadata: [string, MetadataValue][] = [["key", { tag: "String", value: "value" }]];
    const msg: Message = { tag: "Request", requestId: 5n, methodId: 100n, metadata, payload: new Uint8Array([]) };
    const encoded = encodeMessage(msg);
    const expected = loadGoldenVector("wire/message_request_with_metadata.bin");
    expect(Array.from(encoded)).toEqual(Array.from(expected));
  });

  it("decodes Request from Rust bytes", () => {
    const bytes = loadGoldenVector("wire/message_request_with_metadata.bin");
    const decoded = decodeMessage(bytes);
    expect(decoded.value.tag).toBe("Request");
    if (decoded.value.tag === "Request") {
      expect(decoded.value.requestId).toBe(5n);
      expect(decoded.value.methodId).toBe(100n);
      expect(decoded.value.metadata.length).toBe(1);
      expect(decoded.value.metadata[0][0]).toBe("key");
    }
  });
});
```

#### 5. Message::Response Tests

```typescript
describe("Message::Response encoding", () => {
  it("encodes Response", () => {
    const msg: Message = { tag: "Response", requestId: 1n, metadata: [], payload: new Uint8Array([0x42]) };
    const encoded = encodeMessage(msg);
    const expected = loadGoldenVector("wire/message_response.bin");
    expect(Array.from(encoded)).toEqual(Array.from(expected));
  });

  it("decodes Response from Rust bytes", () => {
    const bytes = loadGoldenVector("wire/message_response.bin");
    const decoded = decodeMessage(bytes);
    expect(decoded.value.tag).toBe("Response");
    if (decoded.value.tag === "Response") {
      expect(decoded.value.requestId).toBe(1n);
      expect(Array.from(decoded.value.payload)).toEqual([0x42]);
    }
  });
});
```

#### 6. Channel Message Tests

```typescript
describe("Channel message encoding", () => {
  it("encodes Message::Cancel", () => {
    const msg: Message = { tag: "Cancel", requestId: 99n };
    const encoded = encodeMessage(msg);
    const expected = loadGoldenVector("wire/message_cancel.bin");
    expect(Array.from(encoded)).toEqual(Array.from(expected));
  });

  it("encodes Message::Data", () => {
    const msg: Message = { tag: "Data", channelId: 1n, payload: new Uint8Array([1, 2, 3]) };
    const encoded = encodeMessage(msg);
    const expected = loadGoldenVector("wire/message_data.bin");
    expect(Array.from(encoded)).toEqual(Array.from(expected));
  });

  it("encodes Message::Close", () => {
    const msg: Message = { tag: "Close", channelId: 7n };
    const encoded = encodeMessage(msg);
    const expected = loadGoldenVector("wire/message_close.bin");
    expect(Array.from(encoded)).toEqual(Array.from(expected));
  });

  it("encodes Message::Reset", () => {
    const msg: Message = { tag: "Reset", channelId: 5n };
    const encoded = encodeMessage(msg);
    const expected = loadGoldenVector("wire/message_reset.bin");
    expect(Array.from(encoded)).toEqual(Array.from(expected));
  });

  it("encodes Message::Credit", () => {
    const msg: Message = { tag: "Credit", channelId: 3n, bytes: 4096 };
    const encoded = encodeMessage(msg);
    const expected = loadGoldenVector("wire/message_credit.bin");
    expect(Array.from(encoded)).toEqual(Array.from(expected));
  });

  it("decodes all channel messages from Rust bytes", () => {
    expect(decodeMessage(loadGoldenVector("wire/message_cancel.bin")).value)
      .toEqual({ tag: "Cancel", requestId: 99n });
    
    const data = decodeMessage(loadGoldenVector("wire/message_data.bin")).value;
    expect(data.tag).toBe("Data");
    if (data.tag === "Data") {
      expect(data.channelId).toBe(1n);
    }
    
    expect(decodeMessage(loadGoldenVector("wire/message_close.bin")).value)
      .toEqual({ tag: "Close", channelId: 7n });
    
    expect(decodeMessage(loadGoldenVector("wire/message_reset.bin")).value)
      .toEqual({ tag: "Reset", channelId: 5n });
    
    expect(decodeMessage(loadGoldenVector("wire/message_credit.bin")).value)
      .toEqual({ tag: "Credit", channelId: 3n, bytes: 4096 });
  });
});
```

#### 7. Roundtrip Tests

```typescript
describe("Roundtrip tests", () => {
  const testCases: Message[] = [
    { tag: "Hello", hello: { tag: "V1", maxPayloadSize: 1024, initialChannelCredit: 64 } },
    { tag: "Hello", hello: { tag: "V1", maxPayloadSize: 1024 * 1024, initialChannelCredit: 64 * 1024 } },
    { tag: "Goodbye", reason: "connection closed" },
    { tag: "Goodbye", reason: "" },
    { tag: "Request", requestId: 1n, methodId: 1n, metadata: [], payload: new Uint8Array([]) },
    { tag: "Request", requestId: 1n, methodId: 42n, metadata: [], payload: new Uint8Array([1, 2, 3, 4]) },
    { tag: "Request", requestId: 100n, methodId: 200n, metadata: [["x", { tag: "String", value: "y" }]], payload: new Uint8Array([]) },
    { tag: "Response", requestId: 1n, metadata: [], payload: new Uint8Array([]) },
    { tag: "Response", requestId: 1n, metadata: [], payload: new Uint8Array([0xFF]) },
    { tag: "Cancel", requestId: 1n },
    { tag: "Cancel", requestId: 999999n },
    { tag: "Data", channelId: 1n, payload: new Uint8Array([]) },
    { tag: "Data", channelId: 1n, payload: new Uint8Array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9]) },
    { tag: "Close", channelId: 1n },
    { tag: "Reset", channelId: 1n },
    { tag: "Credit", channelId: 1n, bytes: 0 },
    { tag: "Credit", channelId: 1n, bytes: 65535 },
  ];

  for (const msg of testCases) {
    it(`roundtrips ${msg.tag}`, () => {
      const encoded = encodeMessage(msg);
      const decoded = decodeMessage(encoded);
      expect(decoded.value).toEqual(msg);
      expect(decoded.next).toBe(encoded.length);
    });
  }
});
```

### Extending Golden Vectors

If additional test cases are needed, update `golden_vectors.rs`:

```rust
// Add to golden_vectors.rs as needed:

// MetadataValue variants
let mv_string = MetadataValue::String("test".to_string());
write_vector(&wire_dir, "metadata_value_string", &facet_postcard::to_vec(&mv_string).unwrap());

let mv_bytes = MetadataValue::Bytes(vec![1, 2, 3]);
write_vector(&wire_dir, "metadata_value_bytes", &facet_postcard::to_vec(&mv_bytes).unwrap());

let mv_u64 = MetadataValue::U64(42);
write_vector(&wire_dir, "metadata_value_u64", &facet_postcard::to_vec(&mv_u64).unwrap());
```

Then regenerate with:
```bash
cargo run --bin golden_vectors
```

## Implementation Steps

1. Create `roam-wire/src/wire.test.ts`
2. Add tests for all existing golden vectors
3. Verify encoding matches golden vectors exactly
4. Verify decoding produces correct TypeScript values
5. Add roundtrip tests for edge cases
6. Run tests and fix any discrepancies
7. If needed, add more golden vectors to Rust and regenerate

## Files to Create/Modify

| File | Action |
|------|--------|
| `typescript/packages/roam-wire/src/wire.test.ts` | CREATE |
| `rust/roam-wire/src/bin/golden_vectors.rs` | MODIFY (if more vectors needed) |

## Dependencies

- Phase 001-005 must be complete (schema, codegen, codec)
- Golden vectors must exist in `test-fixtures/golden-vectors/wire/`

## Success Criteria

1. ✅ All existing wire golden vectors have corresponding TypeScript tests
2. ✅ Encoding tests pass: TypeScript produces identical bytes to Rust
3. ✅ Decoding tests pass: TypeScript correctly parses Rust-generated bytes
4. ✅ Roundtrip tests pass for all message variants
5. ✅ Tests cover edge cases:
   - Empty payloads
   - Empty metadata
   - Large values (multi-byte varints)
   - Unicode strings
   - All discriminant values

## Golden Vector Coverage

| Vector File | TypeScript Test | Status |
|-------------|-----------------|--------|
| `hello_v1_small.bin` | `encodes Hello V1 (small values)` | TODO |
| `hello_v1_typical.bin` | `encodes Hello V1 (typical values)` | TODO |
| `message_hello_small.bin` | `encodes Message::Hello (small)` | TODO |
| `message_hello_typical.bin` | `encodes Message::Hello (typical)` | TODO |
| `message_goodbye.bin` | `encodes Message::Goodbye` | TODO |
| `message_request_empty.bin` | `encodes empty Request` | TODO |
| `message_request_with_payload.bin` | `encodes Request with payload` | TODO |
| `message_request_with_metadata.bin` | `encodes Request with metadata` | TODO |
| `message_response.bin` | `encodes Response` | TODO |
| `message_cancel.bin` | `encodes Message::Cancel` | TODO |
| `message_data.bin` | `encodes Message::Data` | TODO |
| `message_close.bin` | `encodes Message::Close` | TODO |
| `message_reset.bin` | `encodes Message::Reset` | TODO |
| `message_credit.bin` | `encodes Message::Credit` | TODO |

## Debugging Failures

If a test fails:

1. **Print both byte arrays**:
   ```typescript
   console.log("Expected:", Array.from(expected).map(b => b.toString(16).padStart(2, '0')).join(' '));
   console.log("Actual:  ", Array.from(encoded).map(b => b.toString(16).padStart(2, '0')).join(' '));
   ```

2. **Check discriminant values**: Verify they match Rust `#[repr(u8)]`

3. **Check field order**: Postcard encodes fields in declaration order

4. **Check varint encoding**: Verify zigzag for signed, plain for unsigned

5. **Check string encoding**: Length-prefixed UTF-8

6. **Regenerate golden vectors** if Rust types changed:
   ```bash
   cargo run --bin golden_vectors
   ```

## Notes

- Golden vectors are the source of truth for wire format correctness
- If TypeScript encoding differs from Rust, the TypeScript code is wrong
- Tests should fail loudly with clear byte-level diff output
- Consider adding hex dump helper for debugging
- Run tests in CI to catch regressions