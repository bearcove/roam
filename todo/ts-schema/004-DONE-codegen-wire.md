# Phase 004: Extend roam-codegen for Wire Types

**Status**: TODO

## Objective

Extend `roam-codegen` to generate TypeScript types and schemas for wire protocol types
(`Message`, `Hello`, `MetadataValue`) from their Rust definitions, using the same
infrastructure that generates service types.

## Background

The existing TypeScript codegen in `roam-codegen/src/targets/typescript/` generates:
- TypeScript types from `facet::Shape` (`types.rs`)
- Runtime schemas for channel binding (`schema.rs`)
- Encode expressions (`encode.rs`)
- Decode statements (`decode.rs`)

Wire types in `roam-wire` already have `#[derive(Facet)]`:

```rust
#[repr(u8)]
#[derive(Debug, Clone, PartialEq, Eq, Facet)]
pub enum Message {
    Hello(Hello) = 0,
    Goodbye { reason: String } = 1,
    Request { request_id: u64, method_id: u64, metadata: Vec<(String, MetadataValue)>, payload: Vec<u8> } = 2,
    // ...
}
```

We can leverage the existing codegen infrastructure to generate TypeScript equivalents.

## Design

### New Module: `roam-codegen/src/targets/typescript/wire.rs`

```rust
//! Wire type generation for TypeScript.
//!
//! Generates TypeScript types and schemas for roam-wire types (Message, Hello, etc.)

use facet::Facet;
use facet_core::Shape;

/// Generate TypeScript wire types and schemas.
pub fn generate_wire_types() -> String {
    let mut output = String::new();
    
    output.push_str("// @generated by roam-codegen\n");
    output.push_str("// DO NOT EDIT - regenerate with `cargo xtask codegen --typescript`\n\n");
    
    output.push_str("import type { EnumSchema, TupleSchema, Schema, SchemaRegistry } from \"@bearcove/roam-postcard\";\n\n");
    
    // Generate types
    output.push_str(&generate_type_for_shape::<roam_wire::Hello>());
    output.push_str(&generate_type_for_shape::<roam_wire::MetadataValue>());
    output.push_str(&generate_type_for_shape::<roam_wire::Message>());
    
    // Generate schemas (using refs for nested named types)
    output.push_str(&generate_schema_for_shape::<roam_wire::Hello>("HelloSchema"));
    output.push_str(&generate_schema_for_shape::<roam_wire::MetadataValue>("MetadataValueSchema"));
    output.push_str(&generate_schema_for_shape::<roam_wire::Message>("MessageSchema"));
    
    // Generate schema registry for resolving refs
    output.push_str(&generate_schema_registry());
    
    output
}

/// Generate the schema registry that maps type names to schemas.
fn generate_schema_registry() -> String {
    r#"
// Schema registry for resolving RefSchema references
export const wireSchemaRegistry: SchemaRegistry = new Map([
  ["Hello", HelloSchema],
  ["MetadataValue", MetadataValueSchema],
  ["Message", MessageSchema],
]);
"#.to_string()
}

fn generate_type_for_shape<T: Facet>() -> String {
    let shape = T::SHAPE;
    // Use existing types.rs infrastructure
    super::types::generate_named_types(&[(shape.type_identifier.to_string(), shape)])
}

fn generate_schema_for_shape<T: Facet>(name: &str) -> String {
    let shape = T::SHAPE;
    // Generate EnumSchema with discriminants
    generate_enum_schema(shape, name)
}
```

### Key Challenge: Discriminant Extraction

The current codegen doesn't handle `#[repr(u8)]` discriminants. We need to extract them.

Facet provides variant information via `Shape`. For `#[repr(u8)]` enums, the discriminant
is available in the variant's `discriminant` field (if facet exposes it).

**If facet exposes discriminants:**
```rust
fn get_discriminant(variant: &facet_core::Variant) -> Option<u8> {
    variant.discriminant.map(|d| d as u8)
}
```

**If facet doesn't expose discriminants:**
We may need to:
1. Add discriminant support to facet (preferred)
2. Hard-code discriminants for wire types (temporary workaround)
3. Use a separate mechanism to extract discriminants

### Generated Output

The codegen should produce files like:

**`roam-wire/src/generated/types.ts`:**
```typescript
// @generated by roam-codegen
// DO NOT EDIT - regenerate with `cargo xtask codegen --typescript`

/** Hello message for handshake. */
export type Hello =
  | { tag: 'V1'; maxPayloadSize: number; initialChannelCredit: number };

/** Metadata value. */
export type MetadataValue =
  | { tag: 'String'; value: string }
  | { tag: 'Bytes'; value: Uint8Array }
  | { tag: 'U64'; value: bigint };

/** Protocol message. */
export type Message =
  | { tag: 'Hello'; hello: Hello }
  | { tag: 'Goodbye'; reason: string }
  | { tag: 'Request'; requestId: bigint; methodId: bigint; metadata: [string, MetadataValue][]; payload: Uint8Array }
  | { tag: 'Response'; requestId: bigint; metadata: [string, MetadataValue][]; payload: Uint8Array }
  | { tag: 'Cancel'; requestId: bigint }
  | { tag: 'Data'; channelId: bigint; payload: Uint8Array }
  | { tag: 'Close'; channelId: bigint }
  | { tag: 'Reset'; channelId: bigint }
  | { tag: 'Credit'; channelId: bigint; bytes: number };
```

**`roam-wire/src/generated/schemas.ts`:**
```typescript
// @generated by roam-codegen
// DO NOT EDIT - regenerate with `cargo xtask codegen --typescript`

import type { EnumSchema, TupleSchema, Schema, SchemaRegistry } from "@bearcove/roam-postcard";

export const HelloSchema: EnumSchema = {
  kind: "enum",
  variants: [
    { name: "V1", discriminant: 0, fields: { maxPayloadSize: { kind: "u32" }, initialChannelCredit: { kind: "u32" } } },
  ],
};

export const MetadataValueSchema: EnumSchema = {
  kind: "enum",
  variants: [
    { name: "String", discriminant: 0, fields: { kind: "string" } },
    { name: "Bytes", discriminant: 1, fields: { kind: "bytes" } },
    { name: "U64", discriminant: 2, fields: { kind: "u64" } },
  ],
};

// Tuple schema for metadata entries: (String, MetadataValue)
// Uses ref to avoid duplicating MetadataValueSchema
const MetadataEntrySchema: TupleSchema = {
  kind: "tuple",
  elements: [{ kind: "string" }, { kind: "ref", name: "MetadataValue" }],
};

export const MessageSchema: EnumSchema = {
  kind: "enum",
  variants: [
    // Newtype variant uses ref to Hello
    { name: "Hello", discriminant: 0, fields: { kind: "ref", name: "Hello" } },
    { name: "Goodbye", discriminant: 1, fields: { reason: { kind: "string" } } },
    { name: "Request", discriminant: 2, fields: {
      requestId: { kind: "u64" },
      methodId: { kind: "u64" },
      metadata: { kind: "vec", element: MetadataEntrySchema },
      payload: { kind: "bytes" },
    } },
    { name: "Response", discriminant: 3, fields: {
      requestId: { kind: "u64" },
      metadata: { kind: "vec", element: MetadataEntrySchema },
      payload: { kind: "bytes" },
    } },
    { name: "Cancel", discriminant: 4, fields: { requestId: { kind: "u64" } } },
    { name: "Data", discriminant: 5, fields: { channelId: { kind: "u64" }, payload: { kind: "bytes" } } },
    { name: "Close", discriminant: 6, fields: { channelId: { kind: "u64" } } },
    { name: "Reset", discriminant: 7, fields: { channelId: { kind: "u64" } } },
    { name: "Credit", discriminant: 8, fields: { channelId: { kind: "u64" }, bytes: { kind: "u32" } } },
  ],
};

// Schema registry for resolving RefSchema references
export const wireSchemaRegistry: SchemaRegistry = new Map([
  ["Hello", HelloSchema],
  ["MetadataValue", MetadataValueSchema],
  ["Message", MessageSchema],
]);
```

## Implementation Steps

1. **Check facet discriminant support**
   - Verify if `facet_core::Variant` exposes discriminant values
   - If not, file an issue or add the feature

2. **Create `wire.rs` module**
   - Add `roam-codegen/src/targets/typescript/wire.rs`
   - Export from `mod.rs`

3. **Implement type generation**
   - Reuse existing `generate_named_types()` for enum type generation
   - Ensure field names use camelCase (existing code handles this)

4. **Implement schema generation**
   - Create `generate_enum_schema()` function
   - Handle newtype, struct, and unit variants
   - Include discriminant values
   - Use `{ kind: "ref", name: "TypeName" }` for nested named types

5. **Generate schema registry**
   - Create `wireSchemaRegistry: SchemaRegistry` mapping type names to schemas
   - Export alongside individual schemas

6. **Integrate with xtask**
   - Add `--wire` flag or include wire types in `--typescript` output
   - Write to `roam-wire/src/generated/`

7. **Add roam-wire dependency**
   - `roam-codegen` needs to depend on `roam-wire` to access the types

## Files to Create/Modify

| File | Action |
|------|--------|
| `rust/roam-codegen/src/targets/typescript/wire.rs` | CREATE |
| `rust/roam-codegen/src/targets/typescript/mod.rs` | MODIFY (add `pub mod wire`) |
| `rust/roam-codegen/Cargo.toml` | MODIFY (add roam-wire dependency) |
| `rust/xtask/src/codegen.rs` | MODIFY (call wire type generation) |
| `typescript/packages/roam-wire/src/generated/types.ts` | GENERATED |
| `typescript/packages/roam-wire/src/generated/schemas.ts` | GENERATED (includes wireSchemaRegistry) |
| `typescript/packages/roam-wire/src/index.ts` | MODIFY (export generated types + registry) |

## Dependencies

- Phase 001 (Schema types) must be complete - we need `EnumSchema` with discriminant support
- `roam-wire` must have `#[derive(Facet)]` on all types (already done)

## Success Criteria

1. ✅ `cargo xtask codegen --typescript` generates wire types
2. ✅ Generated `types.ts` compiles without errors
3. ✅ Generated `schemas.ts` compiles without errors
4. ✅ Generated types match Rust structure:
   - Same variant names
   - Same field names (camelCase)
   - Same field types (u64 → bigint, Vec<u8> → Uint8Array, etc.)
5. ✅ Generated schemas have correct discriminant values
6. ✅ Nested named types use `RefSchema` (e.g., `{ kind: "ref", name: "Hello" }`)
7. ✅ `wireSchemaRegistry` is generated with all named types
8. ✅ Schemas can be used with `encodeWithSchema()` and `decodeWithSchema()` (passing registry)

## Test Cases

```typescript
// Type structure tests (compile-time verification)
import type { Message, Hello, MetadataValue } from "./generated/types.ts";

const hello: Hello = { tag: "V1", maxPayloadSize: 1024, initialChannelCredit: 64 };

const msg: Message = {
  tag: "Request",
  requestId: 1n,
  methodId: 42n,
  metadata: [],
  payload: new Uint8Array([]),
};

// Schema tests
import { MessageSchema, HelloSchema, wireSchemaRegistry } from "./generated/schemas.ts";

expect(MessageSchema.kind).toBe("enum");
expect(MessageSchema.variants.length).toBe(9);

// Hello variant uses ref, not inline schema
expect(MessageSchema.variants[0]).toEqual({
  name: "Hello",
  discriminant: 0,
  fields: { kind: "ref", name: "Hello" },
});

// Registry contains all named types
expect(wireSchemaRegistry.get("Hello")).toBe(HelloSchema);
expect(wireSchemaRegistry.get("Message")).toBe(MessageSchema);
expect(wireSchemaRegistry.size).toBe(3); // Hello, MetadataValue, Message
```

## Potential Issues

### 1. Facet Discriminant Access

If facet doesn't expose enum discriminants, we have options:

a) **Add to facet** (preferred): PR to add `discriminant: Option<i128>` to `Variant`
b) **Hard-code**: Define a separate map of discriminants in roam-codegen
c) **Derive macro**: Use a separate derive macro to extract discriminants

### 2. Newtype vs Struct Variant Detection

Need to distinguish:
- `Hello(Hello)` → newtype, `fields` is a schema reference
- `Goodbye { reason: String }` → struct, `fields` is a record

The existing `classify_variant()` function in `roam-schema` handles this.

### 3. Tuple Types (Metadata)

`Vec<(String, MetadataValue)>` requires tuple schema support.
Phase 001 must add `TupleSchema` type.

### 4. Field Ordering

Postcard encodes fields in declaration order. The generated schema must preserve
this order. JavaScript object key order is preserved for string keys (ES2015+).

## Notes

- This follows the project's "no shortcuts" rule: generate, don't hand-write
- Wire types are the single source of truth in Rust
- TypeScript types and schemas are derived artifacts
- Regenerate after any change to roam-wire types