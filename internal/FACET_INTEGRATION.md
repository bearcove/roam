# Facet Integration Guide

This document explains where and how [facet](https://crates.io/rust/facet) integrates
with rapace. The key insight: **facet is not a transport concern**—it's your schema,
reflection, and tooling layer that sits at the "body" level and above.

## Layer Cake: Where Facet Lives

```
┌─────────────────────────────────────────────────────────────────┐
│  5. Cell API Layer                                               │  ← FACET
│     HtmlDiffService, TemplateService, configs, AST types         │
├─────────────────────────────────────────────────────────────────┤
│  4. Service / RPC Layer                                          │  ← FACET
│     Service traits, registry, introspection, method dispatch     │
├─────────────────────────────────────────────────────────────────┤
│  3. Encoding Layer                                               │  ← FACET
│     facet-format-postcard encode/decode, Schema ↔ bytes                 │
├─────────────────────────────────────────────────────────────────┤
│  2. Framing Layer                                                │
│     MsgHeader, Encoding enum, header_len, body boundaries        │
├─────────────────────────────────────────────────────────────────┤
│  1. Transport Layer                                              │
│     DescRing, MsgDescHot, DataSegment, SlotMeta, doorbells       │
│     All repr(C), POD, no generics, no facet                      │
└─────────────────────────────────────────────────────────────────┘
```

**facet starts to matter at layer 3, and is heavily used at layers 4–5.**

The transport layer (rings, slots, doorbells) only sees `payload_len` as "opaque byte length".
It doesn't know or care that facet exists.

---

## Integration Points

### 1. Request/Response Types

All cell API types derive `Facet`:

```rust
use facet::Facet;

#[derive(Facet)]
pub struct HtmlDoc {
    pub source: String,
    pub ast: HtmlAst,
}

#[derive(Facet)]
pub struct DiffResult {
    pub patches: Vec<Patch>,
    pub stats: DiffStats,
}

#[derive(Facet)]
pub struct Patch {
    pub path: Vec<usize>,
    pub kind: PatchKind,
}
```

The RPC layer then uses facet-format-postcard for encoding:

```rust
use facet_format_postcard::{to_vec, from_slice};

// Sending
let body = to_vec(&request)?;
frame_builder.inline_payload(&body)?;

// Receiving
let response: DiffResult = from_slice(&payload.body())?;
```

**What facet gives you here:**
- Reflection metadata for every type (fields, variants, docs)
- Dynamic `Value` representation (like typed JSON DOM)
- Schema derivation for introspection

---

### 2. Service Registry & Schema Blobs

The spec defines schema storage in `ServiceEntry` and `MethodEntry`:

```rust
struct MethodEntry {
    // ...
    request_schema_offset: u32,
    response_schema_offset: u32,
}
```

Populate these from facet:

```rust
use facet::Facet;

fn register_method<Req: Facet, Resp: Facet>(
    registry: &mut ServiceRegistry,
    name: &str,
) {
    // Get schemas from facet
    let req_schema = Req::SHAPE;   // facet's type shape
    let resp_schema = Resp::SHAPE;

    // Serialize schemas into registry's blob storage
    let req_bytes = facet_format_postcard::to_vec(&req_schema)?;
    let resp_bytes = facet_format_postcard::to_vec(&resp_schema)?;

    registry.add_method(MethodEntry {
        name,
        request_schema: req_bytes,
        response_schema: resp_bytes,
        // ...
    });
}
```

Now introspection methods (`GET_SCHEMA`, `GET_METHOD`) can return these schema bytes directly.

---

### 3. Introspection Payloads

Channel 0 introspection responses are facet types:

```rust
#[derive(Facet)]
pub struct ServiceInfo {
    pub name: String,
    pub version: (u16, u16),
    pub methods: Vec<MethodInfo>,
}

#[derive(Facet)]
pub struct MethodInfo {
    pub name: String,
    pub method_id: u32,
    pub request_schema: Schema,
    pub response_schema: Schema,
    pub flags: MethodFlags,
}

#[derive(Facet)]
pub enum IntrospectionResponse {
    ServiceList { services: Vec<ServiceInfo> },
    Service(ServiceInfo),
    Method(MethodInfo),
    Schema(Schema),
}
```

This turns rapace into a **self-describing protocol**:
- Tools can connect as observer processes
- Auto-generate documentation, CLIs, test harnesses
- Walk schemas and dynamic values without knowing Rust types

---

### 4. Service Traits with Facet

Define cell interfaces as traits with facet-annotated types:

```rust
/// HTML diff service provided by cells.
pub trait HtmlDiffService: Send + Sync {
    /// Compute structural diff between two HTML documents.
    async fn diff(&self, req: DiffRequest) -> Result<DiffResult, ServiceError>;
}

#[derive(Facet)]
pub struct DiffRequest {
    pub old: HtmlDoc,
    pub new: HtmlDoc,
    pub options: DiffOptions,
}

#[derive(Facet)]
pub struct DiffOptions {
    pub ignore_whitespace: bool,
    pub semantic_diff: bool,
}
```

A proc-macro can generate the rapace plumbing:

```rust
// Generated by #[rapace::service]
impl HtmlDiffService for RemoteCell {
    async fn diff(&self, req: DiffRequest) -> Result<DiffResult, ServiceError> {
        self.session
            .call::<DiffRequest, DiffResult>("html.diff", "Diff", req)
            .await
    }
}
```

---

### 5. Configuration as Dynamic Values

Cell configs can be facet values for flexibility:

```rust
use facet::Value;

#[derive(Facet)]
pub struct CellConfig {
    pub name: String,
    pub version: String,
    pub settings: Value,  // Dynamic, schema-validated
}

impl CellHost {
    /// Update cell configuration.
    pub fn configure(&mut self, cell: &str, config: Value) -> Result<(), ConfigError> {
        // Validate against cell's config schema
        let schema = self.get_cell_schema(cell)?;
        schema.validate(&config)?;

        // Send to cell
        self.send_control(ControlPayload::Configure {
            cell: cell.to_string(),
            config,
        })
    }
}
```

This enables:
- "Show all configurable options for all cells" → introspection
- Accept config as dynamic `Value`, validate against schema
- Config diffing between old and new values

---

### 6. Structural Diff and Debugging

Facet has built-in structural diff over reflected values. Use cases:

**HTML diff cell:**
```rust
use facet::diff::{diff, Diff};

// Cell can use facet's diff internally
fn compute_diff(old: &HtmlAst, new: &HtmlAst) -> Vec<Diff> {
    diff(old, new)
}
```

**Config diffing:**
```rust
// Track config changes
let old_config = self.last_config.clone();
let changes = facet::diff::diff(&old_config, &new_config);
log::info!("Config changes: {:?}", changes);
```

**Telemetry debugging:**
```rust
// At high debug levels, mirror bodies as Value for inspection
if debug_level >= 2 {
    let value: Value = facet_format_postcard::from_slice(&body)?;
    telemetry.record_value(trace_id, value);
}
```

---

### 7. Version Compatibility

Facet schemas enable compatibility checking:

```rust
impl CellHost {
    fn check_compatibility(
        &self,
        cell: &str,
        old_schema: &Schema,
        new_schema: &Schema,
    ) -> CompatResult {
        // Compare schemas
        let changes = facet::schema::diff(old_schema, new_schema);

        for change in &changes {
            match change {
                SchemaChange::FieldAdded { optional: true, .. } => {
                    // OK: additive, optional field
                }
                SchemaChange::FieldRemoved { .. } => {
                    return CompatResult::Breaking(change.clone());
                }
                SchemaChange::TypeChanged { .. } => {
                    return CompatResult::Breaking(change.clone());
                }
                // ...
            }
        }

        CompatResult::Compatible
    }
}
```

This makes "static SSG with dynamic cell versions" realistic:
- Host doesn't need to know every concrete Rust type
- Reason about compatibility via facet metadata
- Potentially auto-generate adapters for small schema changes

---

### 8. Dynamic Cell Host

A host that doesn't know concrete types can still route calls:

```rust
impl DynamicHost {
    async fn handle_call(
        &self,
        service: &str,
        method: &str,
        request: Value,
    ) -> Result<Value, ServiceError> {
        // Look up method in registry
        let method_info = self.registry.get_method(service, method)?;

        // Validate request against schema
        method_info.request_schema.validate(&request)?;

        // For known methods, convert to concrete type
        if let Some(handler) = self.known_handlers.get(&(service, method)) {
            return handler.call(request).await;
        }

        // For unknown methods, forward to cell dynamically
        let response = self.forward_to_cell(service, method, request).await?;

        // Validate response
        method_info.response_schema.validate(&response)?;

        Ok(response)
    }
}
```

This enables:
- Wildcard cells that add new methods
- Logging/forwarding unknown methods
- External tooling via introspection + JSON

---

### 9. Field-Aware Fault Injection

With facet, fault injection can be semantic:

```rust
#[derive(Facet)]
pub struct FaultRule {
    pub service: String,
    pub method: String,
    pub condition: FaultCondition,
    pub action: FaultAction,
}

#[derive(Facet)]
pub enum FaultAction {
    Drop,
    Delay { ms: u32 },
    Error { code: ErrorCode },
    /// Modify a field in the request/response
    SetField { path: String, value: Value },
}

impl FaultInjector {
    fn apply_semantic_fault(
        &self,
        rule: &FaultRule,
        body: &mut Value,
    ) -> Result<(), FaultError> {
        if let FaultAction::SetField { path, value } = &rule.action {
            // Use facet's path navigation
            let target = body.get_path_mut(path)?;
            *target = value.clone();
        }
        Ok(())
    }
}
```

Example rule: "null out HTML body in 10% of diff requests"
```rust
FaultRule {
    service: "html.diff".into(),
    method: "Diff".into(),
    condition: FaultCondition::Probability(0.10),
    action: FaultAction::SetField {
        path: "new.body".into(),
        value: Value::String("".into()),
    },
}
```

This is heavier than raw SHM faults, so only enable for debugging/chaos testing.

---

## What Facet Does NOT Touch

Keep these facet-free:

| Component | Why |
|-----------|-----|
| `MsgDescHot`, `DescRing` | repr(C), POD, hot path |
| `DataSegment`, `SlotMeta` | Low-level allocator |
| `SegmentHeader` | Protocol primitive |
| `MsgHeader` | Framing, manual packing |
| Doorbells (FD-based wakeups) | OS primitives |

These are enforced by:
- Newtype wrappers and typestates (see IMPLEMENTATION.md)
- Unsafe contained behind safe constructors
- No generics, no reflection overhead

**Facet kicks in after you have a contiguous payload slice.**

---

## Crate Structure

```
rust/
├── rapace/                    # Main crate, re-exports
│
├── rapace-transport/          # Rings, allocator, doorbells, session
│                              # NO facet dependency
│
├── rapace-wire/               # MsgHeader, Encoding, framing
│                              # NO facet dependency
│
├── rapace-facet/              # Facet integration
│   ├── schema.rs              # Schema ↔ registry glue
│   ├── introspect.rs          # Channel 0 introspection impls
│   ├── value.rs               # Value-based metadata helpers
│   └── call.rs                # Typed call::<Req, Resp>() helpers
│
├── rapace-service/            # Service traits, dispatch
│                              # Uses rapace-facet
│
├── rapace-macros/             # #[rapace::service] proc-macro
│                              # Generates facet-aware service impls
│
└── rapace-cell-api/           # SSG cell contracts
                               # All types #[derive(Facet)]
```

**Dependency flow:**
```
rapace-transport  ←─────────────────────────────────┐
       │                                            │
       ▼                                            │
rapace-wire                                         │
       │                                            │
       ▼                                            │
rapace-facet  ───► facet, facet-format-postcard            │
       │                                            │
       ▼                                            │
rapace-service                                      │
       │                                            │
       ▼                                            │
rapace-cell-api                                     │
       │                                            │
       ▼                                            │
rapace (re-exports) ────────────────────────────────┘
```

`rapace-transport` and `rapace-wire` have **zero** facet dependency.
The facet integration is entirely additive.

---

## Type Constraints

Enforce that only facet types can be RPC payloads:

```rust
// In rapace-facet/src/call.rs

use facet::Facet;

impl<R: SessionRole> Session<R> {
    /// Call an RPC method with typed request/response.
    ///
    /// Both types must implement Facet for schema validation.
    pub async fn call<Req, Resp>(
        &self,
        service: &str,
        method: &str,
        request: Req,
    ) -> Result<Resp, CallError>
    where
        Req: Facet + serde::Serialize,
        Resp: Facet + serde::de::DeserializeOwned,
    {
        // Encode request
        let body = facet_format_postcard::to_vec(&request)?;

        // Send and receive
        let response_body = self.raw_call(service, method, &body).await?;

        // Decode response
        let response: Resp = facet_format_postcard::from_slice(&response_body)?;

        Ok(response)
    }
}
```

Now the type system enforces:
- Only `T: Facet` allowed as RPC payload types
- Schema always derivable from the type
- Introspection always possible

---

## Summary

| Layer | Facet Role |
|-------|------------|
| Transport (rings, slots) | None |
| Framing (MsgHeader) | None |
| Encoding | `facet-format-postcard` for body bytes |
| Service Registry | Schema blobs from `Facet::SHAPE` |
| Introspection | Responses are facet types |
| Cell API | All types `#[derive(Facet)]` |
| Tooling | Dynamic `Value`, diff, validation |

**Facet makes rapace self-describing, versionable, and debuggable—while keeping the hot path as dumb and fast as the design requires.**
