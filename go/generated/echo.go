// Code generated by roam-codegen. DO NOT EDIT.

package roam

import (
	"context"
	"encoding/binary"
	"errors"
	"math"
)

// Method IDs
const (
	EchoMethodEcho uint64 = 0x3d66dd9ee36b4240
	EchoMethodReverse uint64 = 0x268246d3219503fb
)

// EchoCaller -  Simple echo service for conformance testing.
type EchoCaller interface {
	// Echo -  Echoes the message back.
	Echo(ctx context.Context, message string) (string, error)
	// Reverse -  Returns the message reversed.
	Reverse(ctx context.Context, message string) (string, error)
}

// EchoClient implements EchoCaller.
type EchoClient struct {
	conn Connection
}

// NewEchoClient creates a new client.
func NewEchoClient(conn Connection) *EchoClient {
	return &EchoClient{conn: conn}
}

// Echo -  Echoes the message back.
func (c *EchoClient) Echo(ctx context.Context, message string) (string, error) {
	var payload []byte
	payload = append(payload, encodeString(message)...)
	response, err := c.conn.Call(ctx, 0x3d66dd9ee36b4240, payload)
	if err != nil {
		var zero string
		return zero, err
	}
	off := 0
	resultTag, err := readUvarint(response, &off)
	if err != nil {
		var zero string
		return zero, err
	}
	if resultTag == 0 {
		// Ok variant
		result, err := readString(response, &off)
		if err != nil {
			var zero string
			return zero, err
		}
		return result, nil
	}
	// Err variant - decode RoamError
	errorTag, err := readUvarint(response, &off)
	if err != nil {
		var zero string
		return zero, err
	}
	switch errorTag {
	case 0:
		var zero string
		return zero, errors.New("user error")
	case 1:
		var zero string
		return zero, errors.New("unknown method")
	case 2:
		var zero string
		return zero, errors.New("invalid payload")
	case 3:
		var zero string
		return zero, errors.New("cancelled")
	default:
		var zero string
		return zero, errors.New("unknown error")
	}
}

// Reverse -  Returns the message reversed.
func (c *EchoClient) Reverse(ctx context.Context, message string) (string, error) {
	var payload []byte
	payload = append(payload, encodeString(message)...)
	response, err := c.conn.Call(ctx, 0x268246d3219503fb, payload)
	if err != nil {
		var zero string
		return zero, err
	}
	off := 0
	resultTag, err := readUvarint(response, &off)
	if err != nil {
		var zero string
		return zero, err
	}
	if resultTag == 0 {
		// Ok variant
		result, err := readString(response, &off)
		if err != nil {
			var zero string
			return zero, err
		}
		return result, nil
	}
	// Err variant - decode RoamError
	errorTag, err := readUvarint(response, &off)
	if err != nil {
		var zero string
		return zero, err
	}
	switch errorTag {
	case 0:
		var zero string
		return zero, errors.New("user error")
	case 1:
		var zero string
		return zero, errors.New("unknown method")
	case 2:
		var zero string
		return zero, errors.New("invalid payload")
	case 3:
		var zero string
		return zero, errors.New("cancelled")
	default:
		var zero string
		return zero, errors.New("unknown error")
	}
}

// EchoHandler handles server-side method calls.
// Note: Streaming types are inverted from the schema definition
// per r[streaming.caller-pov].
type EchoHandler interface {
	Echo(ctx context.Context, message string) (string, error)
	Reverse(ctx context.Context, message string) (string, error)
}

// NewEchoDispatcher creates a dispatcher for the service.
func NewEchoDispatcher(handler EchoHandler) func(ctx context.Context, methodID uint64, payload []byte) ([]byte, error) {
	return func(ctx context.Context, methodID uint64, payload []byte) ([]byte, error) {
		switch methodID {
		case 0x3d66dd9ee36b4240:
			off := 0
			message, err := readString(payload, &off)
			if err != nil {
				return encodeInvalidPayloadError(), nil
			}
			result, err := handler.Echo(ctx, message)
			if err != nil {
				return encodeResultErr(err), nil
			}
			return encodeResultOk(encodeString(result)), nil
		case 0x268246d3219503fb:
			off := 0
			message, err := readString(payload, &off)
			if err != nil {
				return encodeInvalidPayloadError(), nil
			}
			result, err := handler.Reverse(ctx, message)
			if err != nil {
				return encodeResultErr(err), nil
			}
			return encodeResultOk(encodeString(result)), nil
		default:
			return encodeUnknownMethodError(), nil
		}
	}
}

// Runtime helper functions

// Connection represents a roam connection for making calls.
type Connection interface {
	Call(ctx context.Context, methodID uint64, payload []byte) ([]byte, error)
}

// StreamID represents a stream identifier.
type StreamID uint64

func encodeUvarint(v uint64) []byte {
	var tmp [10]byte
	n := binary.PutUvarint(tmp[:], v)
	return append([]byte(nil), tmp[:n]...)
}

func readUvarint(buf []byte, off *int) (uint64, error) {
	v, n := binary.Uvarint(buf[*off:])
	if n <= 0 {
		return 0, errors.New("varint decode error")
	}
	*off += n
	return v, nil
}

func encodeBool(v bool) []byte {
	if v {
		return []byte{1}
	}
	return []byte{0}
}

func readBool(buf []byte, off *int) (bool, error) {
	if *off >= len(buf) {
		return false, errors.New("bool: buffer too short")
	}
	v := buf[*off] != 0
	*off++
	return v, nil
}

func encodeU8(v uint8) []byte {
	return []byte{byte(v)}
}

func readU8(buf []byte, off *int) (uint8, error) {
	if *off >= len(buf) {
		return 0, errors.New("uint8: buffer too short")
	}
	v := uint8(buf[*off])
	*off++
	return v, nil
}

func encodeI8(v int8) []byte {
	return []byte{byte(v)}
}

func readI8(buf []byte, off *int) (int8, error) {
	if *off >= len(buf) {
		return 0, errors.New("int8: buffer too short")
	}
	v := int8(buf[*off])
	*off++
	return v, nil
}

func encodeU16(v uint16) []byte {
	buf := make([]byte, 2)
	binary.LittleEndian.PutUint16(buf, v)
	return buf
}

func readU16(buf []byte, off *int) (uint16, error) {
	if *off + 2 > len(buf) {
		return 0, errors.New("uint16: buffer too short")
	}
	v := binary.LittleEndian.Uint16(buf[*off:])
	*off += 2
	return v, nil
}

func encodeI16(v int16) []byte {
	buf := make([]byte, 2)
	binary.LittleEndian.PutUint16(buf, uint16(v))
	return buf
}

func readI16(buf []byte, off *int) (int16, error) {
	if *off + 2 > len(buf) {
		return 0, errors.New("int16: buffer too short")
	}
	v := binary.LittleEndian.Uint16(buf[*off:])
	*off += 2
	return int16(v), nil
}

func encodeU32(v uint32) []byte {
	buf := make([]byte, 4)
	binary.LittleEndian.PutUint32(buf, v)
	return buf
}

func readU32(buf []byte, off *int) (uint32, error) {
	if *off + 4 > len(buf) {
		return 0, errors.New("uint32: buffer too short")
	}
	v := binary.LittleEndian.Uint32(buf[*off:])
	*off += 4
	return v, nil
}

func encodeI32(v int32) []byte {
	buf := make([]byte, 4)
	binary.LittleEndian.PutUint32(buf, uint32(v))
	return buf
}

func readI32(buf []byte, off *int) (int32, error) {
	if *off + 4 > len(buf) {
		return 0, errors.New("int32: buffer too short")
	}
	v := binary.LittleEndian.Uint32(buf[*off:])
	*off += 4
	return int32(v), nil
}

func encodeI64(v int64) []byte {
	// Zigzag encode
	u := uint64((v << 1) ^ (v >> 63))
	return encodeUvarint(u)
}

func readI64(buf []byte, off *int) (int64, error) {
	u, err := readUvarint(buf, off)
	if err != nil {
		return 0, err
	}
	// Zigzag decode
	return int64((u >> 1) ^ -(u & 1)), nil
}

func readU128(buf []byte, off *int) ([16]byte, error) {
	var v [16]byte
	if *off + 16 > len(buf) {
		return v, errors.New("u128: buffer too short")
	}
	copy(v[:], buf[*off:*off+16])
	*off += 16
	return v, nil
}

func readI128(buf []byte, off *int) ([16]byte, error) {
	return readU128(buf, off)
}

func encodeF32(v float32) []byte {
	buf := make([]byte, 4)
	binary.LittleEndian.PutUint32(buf, math.Float32bits(v))
	return buf
}

func readF32(buf []byte, off *int) (float32, error) {
	if *off + 4 > len(buf) {
		return 0, errors.New("f32: buffer too short")
	}
	v := binary.LittleEndian.Uint32(buf[*off:])
	*off += 4
	return math.Float32frombits(v), nil
}

func encodeF64(v float64) []byte {
	buf := make([]byte, 8)
	binary.LittleEndian.PutUint64(buf, math.Float64bits(v))
	return buf
}

func readF64(buf []byte, off *int) (float64, error) {
	if *off + 8 > len(buf) {
		return 0, errors.New("f64: buffer too short")
	}
	v := binary.LittleEndian.Uint64(buf[*off:])
	*off += 8
	return math.Float64frombits(v), nil
}

func encodeString(s string) []byte {
	b := []byte(s)
	return append(encodeUvarint(uint64(len(b))), b...)
}

func readString(buf []byte, off *int) (string, error) {
	v, err := readUvarint(buf, off)
	if err != nil {
		return "", err
	}
	if v > uint64(len(buf)-*off) {
		return "", errors.New("string: length out of range")
	}
	s := string(buf[*off : *off+int(v)])
	*off += int(v)
	return s, nil
}

func encodeBytes(b []byte) []byte {
	return append(encodeUvarint(uint64(len(b))), b...)
}

func readBytes(buf []byte, off *int) ([]byte, error) {
	v, err := readUvarint(buf, off)
	if err != nil {
		return nil, err
	}
	if v > uint64(len(buf)-*off) {
		return nil, errors.New("bytes: length out of range")
	}
	b := make([]byte, v)
	copy(b, buf[*off:*off+int(v)])
	*off += int(v)
	return b, nil
}

func encodeSlice[T any](items []T, encode func(T) []byte) []byte {
	out := encodeUvarint(uint64(len(items)))
	for _, item := range items {
		out = append(out, encode(item)...)
	}
	return out
}

func readSlice[T any](buf []byte, off *int, decode func([]byte, *int) (T, error)) ([]T, error) {
	count, err := readUvarint(buf, off)
	if err != nil {
		return nil, err
	}
	items := make([]T, count)
	for i := uint64(0); i < count; i++ {
		items[i], err = decode(buf, off)
		if err != nil {
			return nil, err
		}
	}
	return items, nil
}

func encodeArray[T any](items []T, encode func(T) []byte) []byte {
	return encodeSlice(items, encode)
}

func encodeOption[T any](v *T, encode func(*T) []byte) []byte {
	if v == nil {
		return []byte{0}
	}
	return append([]byte{1}, encode(v)...)
}

func readOption[T any](buf []byte, off *int, decode func([]byte, *int) (T, error)) (*T, error) {
	tag, err := readBool(buf, off)
	if err != nil {
		return nil, err
	}
	if !tag {
		return nil, nil
	}
	v, err := decode(buf, off)
	if err != nil {
		return nil, err
	}
	return &v, nil
}

func encodeMap[K comparable, V any](m map[K]V, encode func(K, V) []byte) []byte {
	out := encodeUvarint(uint64(len(m)))
	for k, v := range m {
		out = append(out, encode(k, v)...)
	}
	return out
}

func readMap[K comparable, V any](buf []byte, off *int, decodeKey func([]byte, *int) (K, error), decodeValue func([]byte, *int) (V, error)) (map[K]V, error) {
	count, err := readUvarint(buf, off)
	if err != nil {
		return nil, err
	}
	m := make(map[K]V, count)
	for i := uint64(0); i < count; i++ {
		k, err := decodeKey(buf, off)
		if err != nil {
			return nil, err
		}
		v, err := decodeValue(buf, off)
		if err != nil {
			return nil, err
		}
		m[k] = v
	}
	return m, nil
}

func encodeSet[K comparable](s map[K]struct{}, encode func(K) []byte) []byte {
	out := encodeUvarint(uint64(len(s)))
	for k := range s {
		out = append(out, encode(k)...)
	}
	return out
}

func readSet[K comparable](buf []byte, off *int, decode func([]byte, *int) (K, error)) (map[K]struct{}, error) {
	count, err := readUvarint(buf, off)
	if err != nil {
		return nil, err
	}
	s := make(map[K]struct{}, count)
	for i := uint64(0); i < count; i++ {
		k, err := decode(buf, off)
		if err != nil {
			return nil, err
		}
		s[k] = struct{}{}
	}
	return s, nil
}

func concat(parts ...[]byte) []byte {
	var out []byte
	for _, p := range parts {
		out = append(out, p...)
	}
	return out
}

func encodeResultOk(payload []byte) []byte {
	return append(encodeUvarint(0), payload...)
}

func encodeResultOkUnit() []byte {
	return encodeUvarint(0)
}

func encodeResultErr(err error) []byte {
	out := encodeUvarint(1) // Result::Err
	out = append(out, encodeUvarint(0)...) // RoamError::User
	out = append(out, encodeString(err.Error())...)
	return out
}

func encodeUnknownMethodError() []byte {
	out := encodeUvarint(1) // Result::Err
	out = append(out, encodeUvarint(1)...) // RoamError::UnknownMethod
	return out
}

func encodeInvalidPayloadError() []byte {
	out := encodeUvarint(1) // Result::Err
	out = append(out, encodeUvarint(2)...) // RoamError::InvalidPayload
	return out
}
