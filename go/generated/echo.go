// Code generated by roam-codegen. DO NOT EDIT.

package roam

import (
	"context"
	"encoding/binary"
	"errors"
)

// Method IDs
const (
	EchoMethodEcho    uint64 = 0x3d66dd9ee36b4240
	EchoMethodReverse uint64 = 0x268246d3219503fb
)

// EchoClient -  Simple echo service for conformance testing.
type EchoClient interface {
	// Echo -  Echoes the message back.
	Echo(ctx context.Context, message string) (string, error)
	// Reverse -  Returns the message reversed.
	Reverse(ctx context.Context, message string) (string, error)
}

// EchoHandler handles server-side method calls.
type EchoHandler interface {
	Echo(ctx context.Context, message string) (string, error)
	Reverse(ctx context.Context, message string) (string, error)
}

// NewEchoDispatcher creates a dispatcher for the service.
func NewEchoDispatcher(handler EchoHandler) func(ctx context.Context, methodID uint64, payload []byte) ([]byte, error) {
	return func(ctx context.Context, methodID uint64, payload []byte) ([]byte, error) {
		switch methodID {
		case 0x3d66dd9ee36b4240:
			off := 0
			message, err := readString(payload, &off)
			if err != nil {
				return encodeInvalidPayloadError(), nil
			}
			result, err := handler.Echo(ctx, message)
			if err != nil {
				return encodeResultErr(err), nil
			}
			return encodeResultOk(result, encodeString), nil
		case 0x268246d3219503fb:
			off := 0
			message, err := readString(payload, &off)
			if err != nil {
				return encodeInvalidPayloadError(), nil
			}
			result, err := handler.Reverse(ctx, message)
			if err != nil {
				return encodeResultErr(err), nil
			}
			return encodeResultOk(result, encodeString), nil
		default:
			return encodeUnknownMethodError(), nil
		}
	}
}

// Runtime helper functions

func appendUvarint(dst []byte, v uint64) []byte {
	var tmp [10]byte
	n := binary.PutUvarint(tmp[:], v)
	return append(dst, tmp[:n]...)
}

func readString(buf []byte, off *int) (string, error) {
	v, n := binary.Uvarint(buf[*off:])
	if n <= 0 {
		return "", errors.New("varint decode error")
	}
	*off += n
	if v > uint64(len(buf)-*off) {
		return "", errors.New("string: length out of range")
	}
	s := string(buf[*off : *off+int(v)])
	*off += int(v)
	return s, nil
}

func encodeString(s string) []byte {
	var out []byte
	b := []byte(s)
	out = appendUvarint(out, uint64(len(b)))
	return append(out, b...)
}

func encodeResultOk(value string, encoder func(string) []byte) []byte {
	var out []byte
	out = appendUvarint(out, 0) // Result::Ok
	out = append(out, encoder(value)...)
	return out
}

func encodeResultErr(err error) []byte {
	var out []byte
	out = appendUvarint(out, 1) // Result::Err
	out = appendUvarint(out, 0) // RoamError::User
	b := []byte(err.Error())
	out = appendUvarint(out, uint64(len(b)))
	out = append(out, b...)
	return out
}

func encodeUnknownMethodError() []byte {
	var out []byte
	out = appendUvarint(out, 1) // Result::Err
	out = appendUvarint(out, 1) // RoamError::UnknownMethod
	return out
}

func encodeInvalidPayloadError() []byte {
	var out []byte
	out = appendUvarint(out, 1) // Result::Err
	out = appendUvarint(out, 2) // RoamError::InvalidPayload
	return out
}
