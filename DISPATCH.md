# roam Dispatch Design

This document describes the bidirectional RPC dispatch architecture.

## Overview

A roam connection is **symmetric** - both peers can initiate calls to each other
over the same connection. This enables patterns like:

- Harness calls subject, subject calls harness back
- Nested RPC (mid-request callbacks)
- Bidirectional streaming

## Connection Establishment

Establishing a connection returns two things:

```rust
let (handle, driver) = establish_connection(transport, dispatcher).await?;

// Spawn the driver - it handles all I/O
tokio::spawn(driver);

// Use the handle to make calls (cloneable)
let client = FooClient::new(handle.clone());
```

### Driver

The `Driver` is a future that:

- Reads messages from the transport
- Dispatches incoming `Request` messages to the service (via `ServiceDispatcher`)
- Routes incoming `Response` messages to waiting callers
- Sends outgoing `Request` messages (from `ConnectionHandle`)
- Handles stream messages (`Data`, `Close`, `Reset`, `Credit`) bidirectionally
- Manages flow control

### ConnectionHandle

The `ConnectionHandle` is clonable and provides:

- `call_raw(method_id, args: Poke)` - Make an RPC call
- Stream ID allocation (respecting initiator/acceptor parity)
- Stream registration with the driver

## Channels (Tx/Rx)

Channels are created independently of connections:

```rust
let (tx, rx) = roam::channel::<i32>();

// tx/rx are not bound to any connection yet
// They can be passed to a call:
let result = client.some_method(arg1, tx).await?;

// After the call, tx is bound and can send data
tx.send(&42).await?;
```

### Channel Structure

```rust
pub struct Tx<T: Facet<'static>> {
    /// Stream ID - starts as u64::MAX (unbound)
    /// Gets set by call_raw before serialization
    stream_id: u64,
    
    /// Sender half of internal mpsc channel
    sender: mpsc::Sender<Vec<u8>>,
    
    _marker: PhantomData<fn(T)>,
}

pub struct Rx<T: Facet<'static>> {
    /// Stream ID - starts as u64::MAX (unbound)
    stream_id: u64,
    
    /// Receiver half of internal mpsc channel
    receiver: mpsc::Receiver<Vec<u8>>,
    
    _marker: PhantomData<fn() -> T>,
}
```

### Channel Creation

```rust
pub fn channel<T: Facet<'static>>() -> (Tx<T>, Rx<T>) {
    let (sender, receiver) = mpsc::channel(64);
    (
        Tx { stream_id: u64::MAX, sender, _marker: PhantomData },
        Rx { stream_id: u64::MAX, receiver, _marker: PhantomData },
    )
}
```

## The call_raw Flow

`call_raw` uses reflection (Poke/Peek) to avoid monomorphization:

```rust
impl ConnectionHandle {
    pub async fn call_raw(
        &self,
        method_id: u64,
        args: Poke<'_, '_>,
    ) -> Result<Vec<u8>, CallError> {
        // 1. Walk args via Poke, find Tx/Rx by shape
        // 2. For each Tx/Rx with stream_id == u64::MAX:
        //    a. Allocate stream ID from connection's allocator
        //    b. Poke the stream ID into the struct
        //    c. Get pointer to sender/receiver, register with driver
        // 3. Convert to Peek for serialization
        let peek = args.as_peek();
        let payload = facet_postcard::peek_to_vec(peek)?;
        // 4. Send Request, await Response
        ...
    }
}
```

### Tx/Rx Serialization (Proxy)

`Tx` and `Rx` use facet's `#[facet(opaque)]` with a proxy type so they
serialize as just their `u64` stream ID:

```rust
#[facet(opaque, proxy = "u64")]
pub struct Tx<T: Facet<'static>> { ... }
```

When serialized, only the `stream_id` field is written. The `sender` field
is not part of the wire format.

## Generated Clients

Generated clients wrap `ConnectionHandle`:

```rust
// Generated by roam-codegen
pub struct FooClient {
    handle: ConnectionHandle,
}

impl FooClient {
    pub fn new(handle: ConnectionHandle) -> Self {
        Self { handle }
    }

    pub async fn echo(&self, message: String) -> Result<String, RoamError<Never>> {
        let args = (message,);
        let payload = self.handle.call_raw(METHOD_ID_ECHO, Poke::new(&mut args)).await?;
        // Deserialize response
        ...
    }

    pub async fn stream_sum(&self, numbers: Tx<i32>) -> Result<i64, RoamError<Never>> {
        let mut args = (numbers,);
        // call_raw will:
        // - Find the Tx in args
        // - Allocate stream ID, poke it in
        // - Register the sender with the driver
        // - Serialize args (Tx becomes its stream_id)
        let payload = self.handle.call_raw(METHOD_ID_STREAM_SUM, Poke::new(&mut args)).await?;
        ...
    }
}
```

## Driver Message Routing

The driver maintains two stream registries:

1. **Server-side registry**: For streams in requests we're serving
   - Incoming `Tx<T>` → we receive Data, route to handler's `Rx<T>`
   - Incoming `Rx<T>` → handler's `Tx<T>` sends Data

2. **Client-side registry**: For streams in calls we're making
   - Our `Tx<T>` → we send Data
   - Our `Rx<T>` → we receive Data

When a `Data` message arrives, the driver checks both registries to route it.

## Stream ID Parity

Per spec `r[channeling.id.parity]`:

- **Initiator** (who opened the connection) uses **odd** IDs: 1, 3, 5, ...
- **Acceptor** (who accepted the connection) uses **even** IDs: 2, 4, 6, ...

This prevents collisions when both peers make concurrent calls.

## Testing Plan

1. **Unit test**: `roam::channel()` creates unbound Tx/Rx
2. **Unit test**: Poke can find and mutate Tx/Rx stream_id field
3. **Unit test**: Tx/Rx serialize as u64 via proxy
4. **Integration test**: Full call_raw flow with channel binding
5. **Integration test**: Bidirectional RPC (harness ↔ subject)
