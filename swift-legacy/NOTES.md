# rapace-swift Implementation Notes

## Project Goal

Implement rapace for Swift:
1. Postcard serialization format in Swift
2. Code generator for Swift Rapace TCP clients from proto crates

## Codegen Strategy

The approach for generating Swift code:

1. We have an `xxx-proto` crate (e.g., `browser-tests-proto`)
2. We create a second crate that depends on `xxx-proto` and `rapace-swift-codegen`
3. That second crate is a **Rust binary** that uses runtime reflection to generate Swift code
4. The generated Swift code gets compiled separately by swiftc

```
xxx-proto (defines types + service traits)
    ↓
xxx-swift-gen (Rust binary, depends on xxx-proto + rapace-swift-codegen)
    ↓ runs, outputs
xxx.swift (Swift source code)
    ↓ compiled by swiftc
Swift client library
```

### The Challenge

- **Struct types**: Easy! Facet already provides full runtime reflection (fields, types, etc.)
- **Service traits**: Harder. Traits aren't values we can reflect on.

### Solution for Service Traits

Have the `#[rapace::service]` macro export a **static** containing service metadata:

```rust
// Generated by #[rapace::service]
pub static BROWSER_DEMO_META: &ServiceMeta = &ServiceMeta {
    name: "BrowserDemo",
    methods: &[
        MethodMeta {
            name: "summarize_numbers",
            method_id: 0x12345678,
            request_shape: <NumbersRequest as Facet>::SHAPE,
            response_shape: <NumbersSummary as Facet>::SHAPE,
            is_streaming: false,
        },
        // ...
    ],
};
```

This static is directly accessible without instantiating any servers or calling registration functions.
The codegen binary can just access `browser_tests_proto::BROWSER_DEMO_META` and iterate over it.

## Rapace Architecture Summary

### Wire Protocol (TCP/Stream)

```
[4 bytes: frame_len (u32 LE)]
[64 bytes: MsgDescHot]
[0..N bytes: payload (if frame_len > 64)]
```

### MsgDescHot (64 bytes, cache-line aligned)

```rust
pub struct MsgDescHot {
    pub msg_id: u64,              // Message ID (monotonic per session)
    pub channel_id: u32,          // Logical stream (0 = control)
    pub method_id: u32,           // RPC method hash (FNV-1a of "Service.method")

    pub payload_slot: u32,        // u32::MAX = inline
    pub payload_generation: u32,  // ABA safety
    pub payload_offset: u32,      // Offset within slot
    pub payload_len: u32,         // Payload size

    pub flags: FrameFlags,        // EOS, ERROR, CANCEL, etc.
    pub credit_grant: u32,        // Flow control
    pub deadline_ns: u64,         // Deadline tracking

    pub inline_payload: [u8; 16], // Small messages fit inline
}
```

### Method ID Computation

FNV-1a hash of `"ServiceName.method_name"`:
```rust
const FNV_OFFSET: u32 = 2166136261;
const FNV_PRIME: u32 = 16777619;

fn fnv1a(s: &str) -> u32 {
    let mut hash = FNV_OFFSET;
    for byte in s.bytes() {
        hash ^= byte as u32;
        hash = hash.wrapping_mul(FNV_PRIME);
    }
    hash
}
```

### Proto Crate Pattern

Proto crates contain:
- `#[derive(facet::Facet)]` structs for request/response types
- `#[rapace::service]` trait definitions
- Streaming types via `Streaming<T>` return type

Example:
```rust
#[derive(Clone, Debug, facet::Facet)]
pub struct NumbersRequest {
    pub values: Vec<i32>,
}

#[rapace::service]
pub trait BrowserDemo {
    async fn summarize_numbers(&self, input: NumbersRequest) -> NumbersSummary;
    async fn countdown(&self, start: u32) -> Streaming<CountEvent>;
}
```

### Control Frames (Channel 0)

Control payload types for session management:
- OpenChannel, CloseChannel, CancelChannel
- GrantCredits (flow control)
- Ping/Pong

## Postcard Format

Postcard is a compact binary format. Key features:
- Variable-length integers (varint encoding)
- No schema in wire format (schema from types)
- Supports zero-copy deserialization

We need to implement postcard serialization/deserialization in Swift.

## Swift Implementation (The Hard Part)

What we need to implement in Swift:

### 1. Postcard Serialization

Postcard is a compact binary format. Key encoding rules:
- **Varints**: LEB128-style variable length integers
- **Booleans**: 1 byte (0 or 1)
- **Fixed integers**: Little-endian
- **Strings/bytes**: Length-prefixed (varint length + raw bytes)
- **Optionals**: 1 byte tag (0=None, 1=Some) + value if Some
- **Sequences**: Varint length + elements
- **Structs**: Fields in order, no tags (schema from types)
- **Enums**: Varint discriminant + variant payload

### 2. Wire Protocol

Frame format on TCP:
```
[4 bytes: frame_len (u32 LE)]     <- Total size including header
[64 bytes: MsgDescHot]            <- Fixed-size descriptor
[0..N bytes: payload]             <- If frame_len > 64
```

### 3. MsgDescHot (64 bytes)

Need to read/write this structure:
```
offset  size  field
0       8     msg_id: u64
8       4     channel_id: u32
12      4     method_id: u32
16      4     payload_slot: u32
20      4     payload_generation: u32
24      4     payload_offset: u32
28      4     payload_len: u32
32      4     flags: u32 (FrameFlags bitfield)
36      4     credit_grant: u32
40      8     deadline_ns: u64
48      16    inline_payload: [u8; 16]
```

### 4. FrameFlags

```
DATA           = 0x01
EOS            = 0x02
ERROR          = 0x04
CANCEL         = 0x08
NO_REPLY       = 0x10
CREDIT_UPDATE  = 0x20
```

### 5. Swift Client Structure

```swift
class RapaceClient {
    private var socket: NWConnection  // or similar
    private var nextChannelId: UInt32 = 1
    private var pendingCalls: [UInt32: CheckedContinuation<Frame, Error>]

    func call<Req: Encodable, Resp: Decodable>(
        methodId: UInt32,
        request: Req
    ) async throws -> Resp
}
```

### 6. Generated Code Structure

For each service, generate:
```swift
class BrowserDemoClient {
    private let client: RapaceClient

    func summarizeNumbers(_ input: NumbersRequest) async throws -> NumbersSummary {
        try await client.call(methodId: 0x12345678, request: input)
    }
}
```

For each struct type:
```swift
struct NumbersRequest: Codable {
    var values: [Int32]
}
```

## De-Risking Experiments

These are independent experiments we can run in parallel to validate each piece:

### Experiment 1: Postcard Varint Round-Trip (Swift ↔ Rust)

**Goal**: Validate Swift varint encoding matches Rust exactly

**Steps**:
1. Write Swift code that encodes varints (unsigned LEB128)
2. Write Swift code that decodes varints
3. Create a Rust test binary that:
   - Prints known values as hex: `[0, 1, 127, 128, 16383, 16384, u32::MAX, u64::MAX]`
4. Swift reads those bytes and decodes → compare values
5. Swift encodes those values → compare bytes

**Zigzag for signed**: `(value << 1) ^ (value >> 63)`

---

### Experiment 2: Postcard Struct Serialization (Swift → Rust)

**Goal**: Validate Swift can serialize a struct that Rust can deserialize

**Steps**:
1. Define a simple struct in Rust with facet:
   ```rust
   #[derive(Facet)]
   struct Point { x: i32, y: i32 }
   ```
2. Rust prints expected bytes for `Point { x: 10, y: -5 }`
3. Swift manually serializes: `zigzag(10) ++ zigzag(-5)`
4. Compare bytes
5. Bonus: Have Rust read Swift's bytes via stdin and deserialize

---

### Experiment 3: MsgDescHot Binary Layout (Swift ↔ Rust)

**Goal**: Validate Swift can read/write the 64-byte descriptor

**Steps**:
1. Rust writes a known MsgDescHot to stdout as 64 bytes
2. Swift reads 64 bytes, parses each field at correct offset
3. Swift writes a MsgDescHot, Rust reads and validates

**Key checks**:
- Endianness (all little-endian)
- Padding/alignment (none - tightly packed)
- Inline payload at offset 48

---

### Experiment 4: TCP Framing (Swift → Rust Server)

**Goal**: Validate Swift can send a frame that a Rust rapace server accepts

**Steps**:
1. Start a simple rapace server (use demos/basic or similar)
2. Swift connects via TCP
3. Swift sends: `[frame_len: u32 LE][64 bytes MsgDescHot][payload]`
4. Server receives and processes
5. Swift reads response frame

**This tests**:
- TCP connection handling in Swift
- Frame length encoding
- Full round-trip

---

### Experiment 5: Async/Await TCP in Swift

**Goal**: Validate Swift's async networking works for our use case

**Steps**:
1. Use NWConnection or similar for async TCP
2. Implement a simple echo client
3. Test concurrent requests with different channel IDs
4. Validate response demuxing works

---

### Experiment 6: Rust Codegen Access (Registry vs Static)

**Goal**: Validate we can access service metadata from a codegen binary

**Steps**:
1. Create `xxx-proto` crate with a simple service
2. Create `xxx-swift-gen` binary that:
   - Depends on `xxx-proto`
   - Calls `xxx_proto::browser_demo_register(&mut registry)` or similar
   - Queries registry for service/method info
   - Prints Swift code to stdout
3. Validate we get all needed info: method names, IDs, request/response shapes

---

### Experiment 7: Shape → Swift Type Mapping

**Goal**: Validate facet Shape gives us enough info to generate Swift types

**Steps**:
1. For a facet struct, access its Shape
2. Iterate fields, get field names and types
3. Map Rust types to Swift types:
   - `i32` → `Int32`
   - `String` → `String`
   - `Vec<T>` → `[T]`
   - `Option<T>` → `T?`
4. Print generated Swift struct

---

## Priority Order

1. **Experiment 1** (varints) - Foundation of everything
2. **Experiment 2** (structs) - Validates format understanding
3. **Experiment 3** (descriptor) - Wire protocol basics
4. **Experiment 5** (async TCP) - Swift networking baseline
5. **Experiment 4** (framing) - Full integration test
6. **Experiment 6** (codegen) - Rust side validation
7. **Experiment 7** (type mapping) - Code generation

---

## Postcard Format Reference (Verified from spec + impl)

| Type | Encoding |
|------|----------|
| `bool` | 1 byte: `0x00` or `0x01` |
| `u8` / `i8` | 1 byte raw (i8 is two's complement) |
| `u16`–`u64` | Varint (LEB128) |
| `i16`–`i64` | Zigzag + Varint |
| `f32` | 4 bytes little-endian |
| `f64` | 8 bytes little-endian |
| `String` / `&str` | Varint length + UTF-8 bytes |
| `Vec<u8>` / `&[u8]` | Varint length + raw bytes |
| `Vec<T>` | Varint length + elements |
| `[T; N]` | N elements (no length prefix) |
| `Option<T>` | `0x00` (None) or `0x01` + value (Some) |
| `struct` | Fields in order, no delimiters |
| `enum` | Varint discriminant + variant payload |

**Varint encoding** (unsigned):
```
loop {
    byte = value & 0x7F
    value >>= 7
    if value != 0 { byte |= 0x80 }
    emit(byte)
    if value == 0 { break }
}
```

**Zigzag encoding** (signed → unsigned):
```
encoded = (value << 1) ^ (value >> 63)  // for i64
// -1 → 1, 1 → 2, -2 → 3, 2 → 4, ...
```
