// Code generated by rapace-codegen. DO NOT EDIT.

import java.io.ByteArrayOutputStream;
import java.io.EOFException;
import java.nio.charset.StandardCharsets;
import java.util.concurrent.CompletableFuture;

final class EchoMethodId {
    private EchoMethodId() {}

    static final long ECHO = 0x3d66dd9ee36b4240L;
    static final long REVERSE = 0x268246d3219503fbL;
}

/**  Simple echo service for conformance testing. */
interface EchoClient {
    /**  Echoes the message back. */
    CompletableFuture<String> echo(String message);
    /**  Returns the message reversed. */
    CompletableFuture<String> reverse(String message);
}

/** Server handler interface for Echo. */
interface EchoHandler {
    CompletableFuture<String> echo(String message);
    CompletableFuture<String> reverse(String message);
}

/** Dispatcher for Echo service. */
final class EchoDispatcher {
    private final EchoHandler handler;

    public EchoDispatcher(EchoHandler handler) {
        this.handler = handler;
    }

    public CompletableFuture<byte[]> dispatch(long methodId, byte[] payload) {
        RuntimeHelpers.IntRef off = new RuntimeHelpers.IntRef(0);
        switch ((int) methodId) {
            case (int) 0x3d66dd9ee36b4240L:
                try {
                    String message = RuntimeHelpers.readString(payload, off);
                    return handler.echo(message)
                        .thenApply(result -> RuntimeHelpers.encodeResultOk(result, RuntimeHelpers::encodeString))
                        .exceptionally(err -> RuntimeHelpers.encodeResultErr(err));
                } catch (Exception e) {
                    return CompletableFuture.completedFuture(RuntimeHelpers.encodeInvalidPayloadError());
                }
            case (int) 0x268246d3219503fbL:
                try {
                    String message = RuntimeHelpers.readString(payload, off);
                    return handler.reverse(message)
                        .thenApply(result -> RuntimeHelpers.encodeResultOk(result, RuntimeHelpers::encodeString))
                        .exceptionally(err -> RuntimeHelpers.encodeResultErr(err));
                } catch (Exception e) {
                    return CompletableFuture.completedFuture(RuntimeHelpers.encodeInvalidPayloadError());
                }
            default:
                return CompletableFuture.completedFuture(RuntimeHelpers.encodeUnknownMethodError());
        }
    }
}
// Runtime helper functions

final class RuntimeHelpers {
    private RuntimeHelpers() {}

    static void writeUVarint(ByteArrayOutputStream out, long value) {
        long v = value;
        while (v >= 0x80) {
            out.write((int) (v & 0x7F) | 0x80);
            v >>>= 7;
        }
        out.write((int) v);
    }

    static long readUVarint(byte[] buf, IntRef off) throws EOFException {
        long result = 0;
        int shift = 0;
        while (true) {
            if (off.v >= buf.length) throw new EOFException("varint eof");
            int b = buf[off.v++] & 0xFF;
            if (shift >= 64) throw new EOFException("varint overflow");
            result |= (long) (b & 0x7F) << shift;
            if ((b & 0x80) == 0) return result;
            shift += 7;
        }
    }

    static String readString(byte[] buf, IntRef off) throws EOFException {
        long len = readUVarint(buf, off);
        if (len < 0 || len > (buf.length - off.v)) throw new EOFException("len out of range");
        String s = new String(buf, off.v, (int) len, StandardCharsets.UTF_8);
        off.v += (int) len;
        return s;
    }

    static byte[] encodeString(String s) {
        ByteArrayOutputStream out = new ByteArrayOutputStream();
        byte[] bytes = s.getBytes(StandardCharsets.UTF_8);
        writeUVarint(out, bytes.length);
        out.writeBytes(bytes);
        return out.toByteArray();
    }

    static byte[] encodeResultOk(String value, java.util.function.Function<String, byte[]> encoder) {
        ByteArrayOutputStream out = new ByteArrayOutputStream();
        writeUVarint(out, 0); // Result::Ok
        out.writeBytes(encoder.apply(value));
        return out.toByteArray();
    }

    static byte[] encodeResultErr(Throwable err) {
        ByteArrayOutputStream out = new ByteArrayOutputStream();
        writeUVarint(out, 1); // Result::Err
        writeUVarint(out, 0); // RapaceError::User
        byte[] msg = err.getMessage().getBytes(StandardCharsets.UTF_8);
        writeUVarint(out, msg.length);
        out.writeBytes(msg);
        return out.toByteArray();
    }

    static byte[] encodeUnknownMethodError() {
        ByteArrayOutputStream out = new ByteArrayOutputStream();
        writeUVarint(out, 1); // Result::Err
        writeUVarint(out, 1); // RapaceError::UnknownMethod
        return out.toByteArray();
    }

    static byte[] encodeInvalidPayloadError() {
        ByteArrayOutputStream out = new ByteArrayOutputStream();
        writeUVarint(out, 1); // Result::Err
        writeUVarint(out, 2); // RapaceError::InvalidPayload
        return out.toByteArray();
    }

    static final class IntRef {
        int v;
        IntRef(int v) { this.v = v; }
    }
}
