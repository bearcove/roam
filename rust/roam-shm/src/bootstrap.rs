//! High-level SHM bootstrap helpers over control connections.
//!
//! This module layers host orchestration (`HostHub`) on top of the shared
//! bootstrap wire primitives from `shm_primitives::bootstrap`.

use std::io;

use shm_primitives::PeerId;
pub use shm_primitives::bootstrap::{
    BOOTSTRAP_REQUEST_HEADER_LEN, BOOTSTRAP_REQUEST_MAGIC, BOOTSTRAP_RESPONSE_HEADER_LEN,
    BOOTSTRAP_RESPONSE_MAGIC, BootstrapError, BootstrapRequestRef, BootstrapResponseOwned,
    BootstrapResponseRef, BootstrapStatus, decode_request, decode_response, encode_request,
    encode_response,
};

use crate::host::{GuestSpawnTicket, HostHub, HostPeer};
use crate::segment::Segment;

pub use crate::host::{PreparedPeer, guest_link_from_raw, guest_link_from_ticket};

/// Result of preparing one bootstrap success response for a guest.
pub struct PreparedBootstrapPeer {
    pub host_peer: HostPeer,
    pub guest_ticket: GuestSpawnTicket,
    pub response_frame: Vec<u8>,
}

impl PreparedBootstrapPeer {
    pub fn peer_id(&self) -> PeerId {
        self.guest_ticket.peer_id
    }
}

impl HostHub {
    /// Reserve a peer and prepare a success response frame for bootstrap.
    ///
    /// `payload` is application-defined response data (typically the segment path).
    pub fn prepare_bootstrap_success(&self, payload: &[u8]) -> io::Result<PreparedBootstrapPeer> {
        let prepared = self.prepare_peer()?;
        let (host_peer, guest_ticket) = prepared.into_parts();
        let response_frame = encode_response(
            BootstrapStatus::Success,
            guest_ticket.peer_id.get() as u32,
            payload,
        )
        .map_err(|err| io::Error::other(format!("failed to encode bootstrap response: {err}")))?;

        Ok(PreparedBootstrapPeer {
            host_peer,
            guest_ticket,
            response_frame,
        })
    }

    /// Build an error response frame for bootstrap request rejection.
    pub fn bootstrap_error_response(&self, message: &[u8]) -> io::Result<Vec<u8>> {
        encode_response(BootstrapStatus::Error, 0, message)
            .map_err(|err| io::Error::other(format!("failed to encode bootstrap error: {err}")))
    }
}

#[cfg(unix)]
impl PreparedBootstrapPeer {
    /// Send the prepared success response and bootstrap fds on Unix.
    ///
    /// r[impl shm.bootstrap.success]
    /// r[impl shm.bootstrap.unix]
    pub fn send_success_unix(
        &self,
        control_fd: std::os::fd::RawFd,
        segment: &Segment,
        include_mmap_control: bool,
    ) -> Result<(), BootstrapError> {
        let mmap_control_fd = include_mmap_control.then_some(self.guest_ticket.mmap_rx.as_raw_fd());
        let fds = shm_primitives::bootstrap::BootstrapSuccessFds {
            doorbell_fd: self.guest_ticket.doorbell.as_raw_fd(),
            segment_fd: segment.as_raw_fd(),
            mmap_control_fd,
        };

        shm_primitives::bootstrap::send_response_unix(
            control_fd,
            BootstrapStatus::Success,
            self.guest_ticket.peer_id.get() as u32,
            // This was generated by prepare_bootstrap_success; decode+reuse keeps one source.
            decode_response(&self.response_frame)?.payload,
            Some(&fds),
        )
    }
}
