---
source: rust/roam-macros-core/src/lib.rs
expression: "generate(quote!\n{ pub trait Adder { async fn add(&self, a: i32, b: i32) -> i32; } })"
---
#[allow(non_snake_case, clippy::all)]
pub fn adder_service_descriptor() -> &'static ::roam::session::ServiceDescriptor {
    static DESCRIPTOR: std::sync::OnceLock<&'static ::roam::session::ServiceDescriptor> =
        std::sync::OnceLock::new();
    DESCRIPTOR.get_or_init(|| {
        let methods: Vec<&'static ::roam::session::MethodDescriptor> =
            vec![Box::leak(Box::new(::roam::session::MethodDescriptor {
                id: ::roam::hash::method_id_from_shapes(
                    "Adder",
                    "add",
                    &[
                        <i32 as ::roam::facet::Facet>::SHAPE,
                        <i32 as ::roam::facet::Facet>::SHAPE,
                    ],
                    <i32 as ::roam::facet::Facet>::SHAPE,
                ),
                service_name: "Adder",
                method_name: "add",
                args: &[
                    ::roam::session::ArgDescriptor {
                        name: "a",
                        shape: <i32 as ::roam::facet::Facet>::SHAPE,
                    },
                    ::roam::session::ArgDescriptor {
                        name: "b",
                        shape: <i32 as ::roam::facet::Facet>::SHAPE,
                    },
                ],
                return_shape: <i32 as ::roam::facet::Facet>::SHAPE,
                doc: None,
            }))];
        Box::leak(Box::new(::roam::session::ServiceDescriptor {
            service_name: "Adder",
            methods: Box::leak(methods.into_boxed_slice()),
            doc: None,
        }))
    })
}
pub trait AdderServer
where
    Self: Send + Sync,
{
    fn add(
        &self,
        call: impl ::roam::Call<i32, ::core::convert::Infallible>,
        a: i32,
        b: i32,
    ) -> impl std::future::Future<Output = ()> + Send;
}
#[doc = r" Dispatcher for this service."]
#[doc = r""]
#[doc = r" Wraps a handler and implements [`#roam::Handler`] by routing incoming"]
#[doc = r" calls to the appropriate trait method by method ID."]
#[derive(Clone)]
pub struct AdderDispatcher<H> {
    handler: H,
}
impl<H> AdderDispatcher<H>
where
    H: AdderServer + Clone + Send + Sync + 'static,
{
    #[doc = r" Create a new dispatcher wrapping the given handler."]
    pub fn new(handler: H) -> Self {
        Self { handler }
    }
}
impl<H, R> ::roam::Handler<R> for AdderDispatcher<H>
where
    H: AdderServer + Clone + Send + Sync + 'static,
    R: ::roam::ReplySink,
{
    async fn handle(&self, call: ::roam::SelfRef<::roam::RequestCall<'static>>, reply: R) {
        let method_id = call.method_id;
        if method_id == adder_service_descriptor().methods[0usize].id {
            let args_bytes = match &call.args {
                ::roam::Payload::Incoming(bytes) => bytes,
                _ => return,
            };
            let args: (i32, i32) = match ::roam::facet_postcard::from_slice_borrowed(args_bytes) {
                Ok(v) => v,
                Err(_) => return,
            };
            let (a, b) = args;
            let sink_call = ::roam::SinkCall::new(reply);
            self.handler.add(sink_call, a, b).await;
            return;
        }
    }
}
#[doc = "Client for the `Adder` service.\n\nGeneric over any [`Caller`](:: roam::Caller) implementation."]
#[derive(Clone)]
pub struct AdderClient<C: ::roam::Caller> {
    caller: C,
}
impl<C: ::roam::Caller> AdderClient<C> {
    #[doc = r" Create a new client wrapping the given caller."]
    pub fn new(caller: C) -> Self {
        Self { caller }
    }
    pub async fn add(
        &self,
        a: i32,
        b: i32,
    ) -> Result<::roam::SelfRef<::roam::ResponseParts<'static, i32>>, ::roam::RoamError> {
        static ARGS_PLAN_0: ::std::sync::OnceLock<&'static ::roam::RpcPlan> =
            ::std::sync::OnceLock::new();
        static OK_PLAN_0: ::std::sync::OnceLock<&'static ::roam::RpcPlan> =
            ::std::sync::OnceLock::new();
        static ERR_PLAN_0: ::std::sync::OnceLock<&'static ::roam::RpcPlan> =
            ::std::sync::OnceLock::new();
        let _args_plan = ARGS_PLAN_0.get_or_init(|| ::roam::RpcPlan::for_type::<(i32, i32)>());
        let _ok_plan = OK_PLAN_0.get_or_init(|| ::roam::RpcPlan::for_type::<i32>());
        let _err_plan =
            ERR_PLAN_0.get_or_init(|| ::roam::RpcPlan::for_type::<::core::convert::Infallible>());
        let args_tuple = (a, b);
        let method_id = adder_service_descriptor().methods[0usize].id;
        let args = ::roam::Payload::outgoing(&args_tuple);
        let req = ::roam::RequestCall {
            method_id,
            args,
            channels: &[],
            metadata: Default::default(),
        };
        let response = self.caller.call(req).await?;
        response.try_repack(|resp, _bytes| {
            let ret_bytes = match &resp.ret {
                ::roam::Payload::Incoming(bytes) => bytes,
                _ => return Err(::roam::RoamError::InvalidPayload),
            };
            let result: Result<i32, ::roam::RoamError<::core::convert::Infallible>> =
                ::roam::facet_postcard::from_slice_borrowed(ret_bytes)
                    .map_err(|_| ::roam::RoamError::InvalidPayload)?;
            let ret = result?;
            Ok(::roam::ResponseParts {
                ret,
                metadata: resp.metadata,
            })
        })
    }
}
#[doc = r" Returns the service detail for codegen."]
pub fn adder_service_detail() -> ::roam::schema::ServiceDetail {
    ::roam::schema::ServiceDetail {
        name: "Adder".into(),
        methods: vec![::roam::schema::MethodDetail {
            service_name: "Adder".into(),
            method_name: "add".into(),
            args: vec![
                ::roam::schema::ArgDetail {
                    name: "a".into(),
                    ty: <i32 as ::roam::facet::Facet>::SHAPE,
                },
                ::roam::schema::ArgDetail {
                    name: "b".into(),
                    ty: <i32 as ::roam::facet::Facet>::SHAPE,
                },
            ],
            return_type: <i32 as ::roam::facet::Facet>::SHAPE,
            doc: None,
        }],
        doc: None,
    }
}
