---
source: rust/roam-macros-core/src/lib.rs
expression: "generate(quote!\n{\n    trait Streamer\n    { async fn count_up(&self, start: i32, output: Tx<i32>) -> i32; }\n})"
---
#[allow(non_snake_case, clippy::all)]
pub fn streamer_service_descriptor() -> &'static ::roam::session::ServiceDescriptor {
    static DESCRIPTOR: std::sync::OnceLock<&'static ::roam::session::ServiceDescriptor> =
        std::sync::OnceLock::new();
    DESCRIPTOR.get_or_init(|| {
        let methods: Vec<&'static ::roam::session::MethodDescriptor> =
            vec![::roam::hash::method_descriptor::<(i32, Tx<i32>), i32>(
                "Streamer",
                "count_up",
                &["start", "output"],
                None,
            )];
        Box::leak(Box::new(::roam::session::ServiceDescriptor {
            service_name: "Streamer",
            methods: Box::leak(methods.into_boxed_slice()),
            doc: None,
        }))
    })
}
pub trait StreamerServer
where
    Self: Send + Sync,
{
    fn count_up(
        &self,
        call: impl ::roam::Call<i32, ::core::convert::Infallible>,
        start: i32,
        output: Tx<i32>,
    ) -> impl std::future::Future<Output = ()> + Send;
}
#[doc = r" Dispatcher for this service."]
#[doc = r""]
#[doc = r" Wraps a handler and implements [`#roam::Handler`] by routing incoming"]
#[doc = r" calls to the appropriate trait method by method ID."]
#[derive(Clone)]
pub struct StreamerDispatcher<H> {
    handler: H,
}
impl<H> StreamerDispatcher<H>
where
    H: StreamerServer + Clone + Send + Sync + 'static,
{
    #[doc = r" Create a new dispatcher wrapping the given handler."]
    pub fn new(handler: H) -> Self {
        Self { handler }
    }
}
impl<H, R> ::roam::Handler<R> for StreamerDispatcher<H>
where
    H: StreamerServer + Clone + Send + Sync + 'static,
    R: ::roam::ReplySink,
{
    async fn handle(&self, call: ::roam::SelfRef<::roam::RequestCall<'static>>, reply: R) {
        let method_id = call.method_id;
        let args_bytes = match &call.args {
            ::roam::Payload::Incoming(bytes) => bytes,
            _ => {
                reply
                    .send_error(::roam::RoamError::<::core::convert::Infallible>::InvalidPayload)
                    .await;
                return;
            }
        };
        if method_id == streamer_service_descriptor().methods[0usize].id {
            let mut args: (i32, Tx<i32>) =
                match ::roam::facet_postcard::from_slice_borrowed(args_bytes) {
                    Ok(v) => v,
                    Err(_) => {
                        reply
                            .send_error(
                                ::roam::RoamError::<::core::convert::Infallible>::InvalidPayload,
                            )
                            .await;
                        return;
                    }
                };
            #[cfg(not(target_arch = "wasm32"))]
            {
                if let Some(binder) = reply.channel_binder() {
                    let plan = ::roam::RpcPlan::for_type::<(i32, Tx<i32>)>();
                    if !plan.channel_locations.is_empty() {
                        #[allow(unsafe_code)]
                        unsafe {
                            ::roam::bind_channels_callee_args(
                                &mut args as *mut (i32, Tx<i32>) as *mut u8,
                                plan,
                                &call.channels,
                                binder,
                            );
                        }
                    }
                }
            }
            let (start, output) = args;
            let sink_call = ::roam::SinkCall::new(reply);
            self.handler.count_up(sink_call, start, output).await;
            return;
        }
        reply
            .send_error(::roam::RoamError::<::core::convert::Infallible>::UnknownMethod)
            .await;
    }
}
#[doc = "Client for the `Streamer` service.\n\nGeneric over any [`Caller`](:: roam::Caller) implementation."]
#[derive(Clone)]
pub struct StreamerClient<C: ::roam::Caller> {
    caller: C,
}
impl<C: ::roam::Caller> StreamerClient<C> {
    #[doc = r" Create a new client wrapping the given caller."]
    pub fn new(caller: C) -> Self {
        Self { caller }
    }
    pub async fn count_up(&self, start: i32, output: Tx<i32>) -> Result<i32, ::roam::RoamError> {
        let method_id = streamer_service_descriptor().methods[0usize].id;
        let mut args = (start, output);
        #[cfg(not(target_arch = "wasm32"))]
        let channels = if let Some(binder) = self.caller.channel_binder() {
            let plan = ::roam::RpcPlan::for_type::<(i32, Tx<i32>)>();
            #[allow(unsafe_code)]
            unsafe {
                ::roam::bind_channels_caller_args(
                    &mut args as *mut (i32, Tx<i32>) as *mut u8,
                    plan,
                    binder,
                )
            }
        } else {
            vec![]
        };
        #[cfg(target_arch = "wasm32")]
        let channels: Vec<::roam::ChannelId> = vec![];
        let req = ::roam::RequestCall {
            method_id,
            args: ::roam::Payload::outgoing(&args),
            channels,
            metadata: Default::default(),
        };
        let response = self.caller.call(req).await.map_err(|e| match e {
            ::roam::RoamError::UnknownMethod => {
                ::roam::RoamError::<::core::convert::Infallible>::UnknownMethod
            }
            ::roam::RoamError::InvalidPayload => {
                ::roam::RoamError::<::core::convert::Infallible>::InvalidPayload
            }
            ::roam::RoamError::Cancelled => {
                ::roam::RoamError::<::core::convert::Infallible>::Cancelled
            }
            ::roam::RoamError::User(never) => match never {},
        })?;
        let ret_bytes = match &response.ret {
            ::roam::Payload::Incoming(bytes) => bytes,
            _ => return Err(::roam::RoamError::<::core::convert::Infallible>::InvalidPayload),
        };
        let result: Result<i32, ::roam::RoamError<::core::convert::Infallible>> =
            ::roam::facet_postcard::from_slice(ret_bytes)
                .map_err(|_| ::roam::RoamError::<::core::convert::Infallible>::InvalidPayload)?;
        result
    }
}
