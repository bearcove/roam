---
source: rust/roam-macros-core/src/lib.rs
expression: "generate(quote!\n{\n    trait Calc\n    { async fn div(&self, a: f64, b: f64) -> Result<f64, DivError>; }\n})"
---
#[allow(non_snake_case, clippy::all)]
pub fn calc_service_descriptor() -> &'static ::roam::session::ServiceDescriptor {
    static DESCRIPTOR: std::sync::OnceLock<&'static ::roam::session::ServiceDescriptor> =
        std::sync::OnceLock::new();
    DESCRIPTOR.get_or_init(|| {
        let methods: Vec<&'static ::roam::session::MethodDescriptor> =
            vec![Box::leak(Box::new(::roam::session::MethodDescriptor {
                id: ::roam::hash::method_id_from_shapes(
                    "Calc",
                    "div",
                    &[
                        <f64 as ::roam::facet::Facet>::SHAPE,
                        <f64 as ::roam::facet::Facet>::SHAPE,
                    ],
                    <Result<f64, DivError> as ::roam::facet::Facet>::SHAPE,
                ),
                service_name: "Calc",
                method_name: "div",
                args: &[
                    ::roam::session::ArgDescriptor {
                        name: "a",
                        shape: <f64 as ::roam::facet::Facet>::SHAPE,
                    },
                    ::roam::session::ArgDescriptor {
                        name: "b",
                        shape: <f64 as ::roam::facet::Facet>::SHAPE,
                    },
                ],
                return_shape: <Result<f64, DivError> as ::roam::facet::Facet>::SHAPE,
                args_plan: Box::leak(Box::new(::roam::session::RpcPlan::for_type::<
                    (f64, f64),
                    ::roam::session::Tx<()>,
                    ::roam::session::Rx<()>,
                >())),
                ok_plan: Box::leak(Box::new(::roam::session::RpcPlan::for_type::<
                    f64,
                    ::roam::session::Tx<()>,
                    ::roam::session::Rx<()>,
                >())),
                err_plan: Box::leak(Box::new(::roam::session::RpcPlan::for_type::<
                    DivError,
                    ::roam::session::Tx<()>,
                    ::roam::session::Rx<()>,
                >())),
                doc: None,
            }))];
        Box::leak(Box::new(::roam::session::ServiceDescriptor {
            service_name: "Calc",
            methods: Box::leak(methods.into_boxed_slice()),
            doc: None,
        }))
    })
}
#[doc = r" Method IDs for the service (indexes into the service descriptor)."]
#[allow(non_snake_case, clippy::all, unused)]
pub mod calc_method_id {
    use super::*;
    pub fn div() -> ::roam::session::MethodId {
        super::calc_service_descriptor().methods[0usize].id
    }
}
pub trait Calc
where
    Self: Send + Sync,
{
    fn div(
        &self,
        cx: &::roam::Context,
        a: f64,
        b: f64,
    ) -> impl std::future::Future<Output = Result<f64, DivError>> + Send;
}
#[doc = r" Dispatcher for this service."]
#[doc = r""]
#[doc = r" Supports middleware that can inspect deserialized args before the handler runs."]
#[doc = r" Middleware is configured via [`with_middleware`](Self::with_middleware)."]
#[derive(Clone)]
pub struct CalcDispatcher<H> {
    handler: H,
    middleware: Vec<::std::sync::Arc<dyn ::roam::session::Middleware>>,
}
impl<H> CalcDispatcher<H>
where
    H: Calc + Clone + 'static,
{
    #[doc = r" Create a new dispatcher with no middleware."]
    pub fn new(handler: H) -> Self {
        Self {
            handler,
            middleware: Vec::new(),
        }
    }
    #[doc = r" Add middleware to this dispatcher."]
    #[doc = r""]
    #[doc = r" Middleware runs after deserialization but before the handler."]
    #[doc = r" It can inspect args via reflection and reject requests."]
    #[doc = r" Middleware runs in the order it was added."]
    pub fn with_middleware<M: ::roam::session::Middleware + 'static>(mut self, mw: M) -> Self {
        self.middleware.push(std::sync::Arc::new(mw));
        self
    }
    #[doc = r" Add already-Arc'd middleware to this dispatcher."]
    pub fn with_middleware_arc(
        mut self,
        mw: std::sync::Arc<dyn ::roam::session::Middleware>,
    ) -> Self {
        self.middleware.push(mw);
        self
    }
    #[allow(unsafe_code)]
    fn dispatch_div(
        &self,
        cx: ::roam::Context,
        payload: Vec<u8>,
        registry: &mut ::roam::session::ChannelRegistry,
    ) -> std::pin::Pin<Box<dyn std::future::Future<Output = ()> + Send + 'static>> {
        use std::mem::MaybeUninit;
        let desc = calc_service_descriptor().methods[0usize];
        let args_plan = desc.args_plan;
        let response_plan = desc.ok_plan;
        let handler = self.handler.clone();
        let middleware = self.middleware.clone();
        let driver_tx = registry.driver_tx();
        let response_channel_ids = registry.response_channel_ids();
        let channels = cx.channels.clone();
        let conn_id = cx.conn_id;
        let request_id = cx.request_id;
        let mut args_slot = MaybeUninit::<(f64, f64)>::uninit();
        if let Err(e) = unsafe {
            ::roam::session::prepare_sync(
                args_slot.as_mut_ptr().cast(),
                args_plan,
                &payload,
                &channels,
                registry,
            )
        } {
            return Box::pin(async move {
                ::roam::session::send_prepare_error(e, &driver_tx, conn_id, request_id).await;
            });
        }
        let args: (f64, f64) = unsafe { args_slot.assume_init_read() };
        Box::pin(async move {
            let mut cx = cx;
            cx.args = desc.args;
            if !middleware.is_empty() {
                let args_peek = unsafe {
                    let peek = ::roam::facet::Peek::unchecked_new(
                        ::roam::facet_core::PtrConst::new(
                            (&args as *const (f64, f64)).cast::<u8>(),
                        ),
                        <(f64, f64) as ::roam::facet::Facet>::SHAPE,
                    );
                    ::roam::session::SendPeek::new(peek)
                };
                if let Err(rejection) =
                    ::roam::session::run_pre_middleware(args_peek, &mut cx, &middleware).await
                {
                    ::roam::session::run_post_middleware(
                        &cx,
                        ::roam::session::MethodOutcome::Rejected(rejection.clone()),
                        &middleware,
                    )
                    .await;
                    ::roam::session::send_prepare_error(
                        ::roam::session::PrepareError::Rejected(rejection),
                        &driver_tx,
                        conn_id,
                        request_id,
                    )
                    .await;
                    return;
                }
            }
            let (a, b) = args;
            let dispatch_cx = ::roam::session::DispatchContext::new(
                conn_id,
                response_channel_ids,
                driver_tx.clone(),
            );
            let result = ::roam::session::DISPATCH_CONTEXT
                .scope(
                    dispatch_cx,
                    ::roam::session::CURRENT_EXTENSIONS
                        .scope(cx.extensions.clone(), handler.div(&cx, a, b)),
                )
                .await;
            match &result {
                Ok(value) => {
                    let send_peek = unsafe {
                        let peek = ::roam::facet::Peek::unchecked_new(
                            ::roam::facet_core::PtrConst::new((value as *const f64).cast::<u8>()),
                            <f64 as ::roam::facet::Facet>::SHAPE,
                        );
                        ::roam::session::SendPeek::new(peek)
                    };
                    if !middleware.is_empty() {
                        let outcome = ::roam::session::MethodOutcome::Ok(send_peek);
                        ::roam::session::run_post_middleware(&cx, outcome, &middleware).await;
                    }
                    ::roam::session::send_ok_response(
                        send_peek,
                        response_plan,
                        &driver_tx,
                        conn_id,
                        request_id,
                    )
                    .await;
                }
                Err(error) => {
                    let send_peek = unsafe {
                        let peek = ::roam::facet::Peek::unchecked_new(
                            ::roam::facet_core::PtrConst::new(
                                (error as *const DivError).cast::<u8>(),
                            ),
                            <DivError as ::roam::facet::Facet>::SHAPE,
                        );
                        ::roam::session::SendPeek::new(peek)
                    };
                    if !middleware.is_empty() {
                        let outcome = ::roam::session::MethodOutcome::Err(send_peek);
                        ::roam::session::run_post_middleware(&cx, outcome, &middleware).await;
                    }
                    ::roam::session::send_error_response(
                        send_peek, &driver_tx, conn_id, request_id,
                    )
                    .await;
                }
            }
        })
    }
}
impl<H> ::roam::session::ServiceDispatcher for CalcDispatcher<H>
where
    H: Calc + Clone + 'static,
{
    fn service_descriptor(&self) -> &'static ::roam::session::ServiceDescriptor {
        calc_service_descriptor()
    }
    fn dispatch(
        &self,
        cx: ::roam::Context,
        payload: Vec<u8>,
        registry: &mut ::roam::session::ChannelRegistry,
    ) -> std::pin::Pin<Box<dyn std::future::Future<Output = ()> + Send + 'static>> {
        let method_id = cx.method_id();
        if method_id == calc_method_id::div() {
            self.dispatch_div(cx, payload, registry)
        } else {
            ::roam::session::dispatch_unknown_method(&cx, registry)
        }
    }
}
#[doc = "Client for Calc service.\n\nGeneric over any [`Caller`](:: roam::session::Caller) implementation, allowing use with both [`ConnectionHandle`](:: roam::session::ConnectionHandle) and reconnecting clients."]
#[derive(Clone)]
pub struct CalcClient<C: ::roam::session::Caller = ::roam::session::ConnectionHandle> {
    caller: C,
}
impl<C: ::roam::session::Caller> CalcClient<C> {
    #[doc = r" Create a new client wrapping the given caller."]
    pub fn new(caller: C) -> Self {
        Self { caller }
    }
    pub fn div(&self, a: f64, b: f64) -> ::roam::session::CallFuture<C, (f64, f64), f64, DivError> {
        let desc = calc_service_descriptor().methods[0usize];
        ::roam::session::CallFuture::new(self.caller.clone(), desc, (a, b))
    }
}
#[doc = r" Returns the service detail for codegen."]
pub fn calc_service_detail() -> ::roam::schema::ServiceDetail {
    ::roam::schema::ServiceDetail {
        name: "Calc".into(),
        methods: vec![::roam::schema::MethodDetail {
            service_name: "Calc".into(),
            method_name: "div".into(),
            args: vec![
                ::roam::schema::ArgDetail {
                    name: "a".into(),
                    ty: <f64 as ::roam::facet::Facet>::SHAPE,
                },
                ::roam::schema::ArgDetail {
                    name: "b".into(),
                    ty: <f64 as ::roam::facet::Facet>::SHAPE,
                },
            ],
            return_type: <Result<f64, DivError> as ::roam::facet::Facet>::SHAPE,
            doc: None,
        }],
        doc: None,
    }
}
