---
source: rust/roam-macros-core/src/lib.rs
expression: "generate(quote! { trait Notifier { async fn notify(&self, msg: String); } })"
---
#[allow(non_snake_case, clippy::all)]
pub fn notifier_service_descriptor() -> &'static ::roam::session::ServiceDescriptor {
    static DESCRIPTOR: std::sync::OnceLock<&'static ::roam::session::ServiceDescriptor> =
        std::sync::OnceLock::new();
    DESCRIPTOR.get_or_init(|| {
        let methods: Vec<&'static ::roam::session::MethodDescriptor> =
            vec![Box::leak(Box::new(::roam::session::MethodDescriptor {
                id: ::roam::hash::method_id_from_shapes(
                    "Notifier",
                    "notify",
                    &[<String as ::roam::facet::Facet>::SHAPE],
                    <() as ::roam::facet::Facet>::SHAPE,
                ),
                service_name: "Notifier",
                method_name: "notify",
                args: &[::roam::session::ArgDescriptor {
                    name: "msg",
                    shape: <String as ::roam::facet::Facet>::SHAPE,
                }],
                return_shape: <() as ::roam::facet::Facet>::SHAPE,
                args_plan: ::roam::rpc_plan::<(String,)>(),
                ret_plan: ::roam::rpc_plan::<Result<(), ::roam::RoamError>>(),
                doc: None,
            }))];
        Box::leak(Box::new(::roam::session::ServiceDescriptor {
            service_name: "Notifier",
            methods: Box::leak(methods.into_boxed_slice()),
            doc: None,
        }))
    })
}
#[doc = r" Method IDs for the service (indexes into the service descriptor)."]
#[allow(non_snake_case, clippy::all, unused)]
pub mod notifier_method_id {
    use super::*;
    pub fn notify() -> ::roam::session::MethodId {
        super::notifier_service_descriptor().methods[0usize].id
    }
}
pub trait Notifier
where
    Self: Send + Sync,
{
    fn notify(
        &self,
        cx: &::roam::Context,
        msg: String,
    ) -> impl std::future::Future<Output = ()> + Send;
}
#[doc = r" Dispatcher for this service."]
#[doc = r""]
#[doc = r" Supports middleware that can inspect deserialized args before the handler runs."]
#[doc = r" Middleware is configured via [`with_middleware`](Self::with_middleware)."]
#[derive(Clone)]
pub struct NotifierDispatcher<H> {
    handler: H,
    middleware: Vec<::std::sync::Arc<dyn ::roam::session::Middleware>>,
}
impl<H> NotifierDispatcher<H>
where
    H: Notifier + Clone + 'static,
{
    #[doc = r" Create a new dispatcher with no middleware."]
    pub fn new(handler: H) -> Self {
        Self {
            handler,
            middleware: Vec::new(),
        }
    }
    #[doc = r" Add middleware to this dispatcher."]
    #[doc = r""]
    #[doc = r" Middleware runs after deserialization but before the handler."]
    #[doc = r" It can inspect args via reflection and reject requests."]
    #[doc = r" Middleware runs in the order it was added."]
    pub fn with_middleware<M: ::roam::session::Middleware + 'static>(mut self, mw: M) -> Self {
        self.middleware.push(std::sync::Arc::new(mw));
        self
    }
    #[doc = r" Add already-Arc'd middleware to this dispatcher."]
    pub fn with_middleware_arc(
        mut self,
        mw: std::sync::Arc<dyn ::roam::session::Middleware>,
    ) -> Self {
        self.middleware.push(mw);
        self
    }
    fn dispatch_notify(
        &self,
        cx: ::roam::Context,
        payload: Vec<u8>,
        registry: &mut ::roam::session::ChannelRegistry,
    ) -> std::pin::Pin<Box<dyn std::future::Future<Output = ()> + Send + 'static>> {
        todo!()
    }
}
impl<H> ::roam::session::ServiceDispatcher for NotifierDispatcher<H>
where
    H: Notifier + Clone + 'static,
{
    fn service_descriptor(&self) -> &'static ::roam::session::ServiceDescriptor {
        notifier_service_descriptor()
    }
    fn dispatch(
        &self,
        cx: ::roam::Context,
        payload: Vec<u8>,
        registry: &mut ::roam::session::ChannelRegistry,
    ) -> std::pin::Pin<Box<dyn std::future::Future<Output = ()> + Send + 'static>> {
        let method_id = cx.method_id();
        if method_id == notifier_method_id::notify() {
            self.dispatch_notify(cx, payload, registry)
        } else {
            ::roam::session::dispatch_unknown_method(&cx, registry)
        }
    }
}
#[doc = "Client for Notifier service.\n\nGeneric over any [`Caller`](:: roam::session::Caller) implementation, allowing use with both [`ConnectionHandle`](:: roam::session::ConnectionHandle) and reconnecting clients."]
#[derive(Clone)]
pub struct NotifierClient<C: ::roam::session::Caller = ::roam::session::ConnectionHandle> {
    caller: C,
}
impl<C: ::roam::session::Caller> NotifierClient<C> {
    #[doc = r" Create a new client wrapping the given caller."]
    pub fn new(caller: C) -> Self {
        Self { caller }
    }
    pub fn notify(
        &self,
        msg: String,
    ) -> ::roam::session::CallFuture<C, (String,), (), ::core::convert::Infallible> {
        let desc = notifier_service_descriptor().methods[0usize];
        ::roam::session::CallFuture::new(self.caller.clone(), desc, (msg,))
    }
}
#[doc = r" Returns the service detail for codegen."]
pub fn notifier_service_detail() -> ::roam::schema::ServiceDetail {
    ::roam::schema::ServiceDetail {
        name: "Notifier".into(),
        methods: vec![::roam::schema::MethodDetail {
            service_name: "Notifier".into(),
            method_name: "notify".into(),
            args: vec![::roam::schema::ArgDetail {
                name: "msg".into(),
                ty: <String as ::roam::facet::Facet>::SHAPE,
            }],
            return_type: <() as ::roam::facet::Facet>::SHAPE,
            doc: None,
        }],
        doc: None,
    }
}
