//! Rust code generation for roam services.
//!
//! Generates client traits and server dispatchers from ServiceDetail.
//! Intended for use in build.rs scripts.
//!
//! TODO: Switch from `push_str` to something that handles indentation properly
//! TODO: Use `::std` and `::core` paths consistently (not bare `std::`)
//! TODO: Better naming - "Client/Server" implies client/server topology but roam is peer-to-peer.
//!       Consider "Caller/Handler" or "Invoker/Dispatcher" instead.

use heck::{ToSnakeCase, ToUpperCamelCase};
use roam_schema::{MethodDetail, ServiceDetail, TypeDetail};

use crate::render::hex_u64;

/// Generate a complete Rust module for a service.
///
/// r[impl codegen.rust.service] - Generate client, server, and method IDs.
pub fn generate_service(service: &ServiceDetail) -> String {
    let mut out = String::new();
    out.push_str("// @generated by roam-codegen\n");
    out.push_str("// DO NOT EDIT - regenerate with build.rs\n\n");

    // Imports (with allow to suppress warnings when not all are used)
    out.push_str("#[allow(unused_imports)]\n");
    out.push_str("use ::roam::session::{Push, Pull, StreamId};\n");
    out.push_str("#[allow(unused_imports)]\n");
    out.push_str("use ::roam::__private::facet_postcard;\n\n");

    // Generate method IDs
    out.push_str(&generate_method_ids(service));

    // Generate client trait
    out.push_str(&generate_client_trait(service));

    // Generate server trait and dispatcher
    out.push_str(&generate_server_trait(service));
    out.push_str(&generate_dispatcher(service));

    out
}

/// Generate method ID constants.
fn generate_method_ids(service: &ServiceDetail) -> String {
    let mut out = String::new();
    out.push_str("/// Method IDs for this service.\n");
    out.push_str("pub mod method_id {\n");

    for method in &service.methods {
        let id = crate::method_id(method);
        let const_name = method.method_name.to_snake_case().to_uppercase();
        out.push_str(&format!(
            "    pub const {const_name}: u64 = {};\n",
            hex_u64(id)
        ));
    }

    out.push_str("}\n\n");
    out
}

/// Generate client trait.
///
/// r[impl streaming.caller-pov] - Client uses Push for args, Pull for returns.
fn generate_client_trait(service: &ServiceDetail) -> String {
    let mut out = String::new();
    let trait_name = format!("{}Client", service.name.to_upper_camel_case());

    if let Some(doc) = &service.doc {
        out.push_str(&format!("/// {}\n", doc));
    }
    out.push_str(&format!("pub trait {trait_name} {{\n"));

    for method in &service.methods {
        let method_name = method.method_name.to_snake_case();

        // Build argument list with streaming types for caller perspective
        let args = method
            .args
            .iter()
            .map(|a| {
                let ty = rust_type_client_arg(&a.type_info);
                format!("{}: {}", a.name.to_snake_case(), ty)
            })
            .collect::<Vec<_>>()
            .join(", ");

        // Return type from caller perspective
        let ret_ty = rust_type_client_return(&method.return_type);

        if let Some(doc) = &method.doc {
            out.push_str(&format!("    /// {}\n", doc));
        }
        out.push_str(&format!(
            "    fn {method_name}(&self, {args}) -> impl std::future::Future<Output = Result<{ret_ty}, Box<dyn std::error::Error + Send + Sync>>> + Send;\n"
        ));
    }

    out.push_str("}\n\n");
    out
}

/// Generate server trait.
///
/// r[impl streaming.caller-pov] - Server uses Pull for args, Push for returns.
fn generate_server_trait(service: &ServiceDetail) -> String {
    let mut out = String::new();
    let trait_name = format!("{}Server", service.name.to_upper_camel_case());

    if let Some(doc) = &service.doc {
        out.push_str(&format!("/// Server implementation for: {}\n", doc));
    } else {
        out.push_str("/// Server implementation trait.\n");
    }
    out.push_str(&format!("pub trait {trait_name}: Send + Sync {{\n"));

    for method in &service.methods {
        let method_name = method.method_name.to_snake_case();

        // Build argument list with streaming types for callee perspective
        let args = method
            .args
            .iter()
            .map(|a| {
                let ty = rust_type_server_arg(&a.type_info);
                format!("{}: {}", a.name.to_snake_case(), ty)
            })
            .collect::<Vec<_>>()
            .join(", ");

        // Return type from callee perspective
        let ret_ty = rust_type_server_return(&method.return_type);

        if let Some(doc) = &method.doc {
            out.push_str(&format!("    /// {}\n", doc));
        }
        out.push_str(&format!(
            "    fn {method_name}(&self, {args}) -> impl std::future::Future<Output = Result<{ret_ty}, Box<dyn std::error::Error + Send + Sync>>> + Send;\n"
        ));
    }

    out.push_str("}\n\n");
    out
}

/// Generate dispatcher implementation.
///
/// r[impl core.call] - Route requests to appropriate method handlers.
fn generate_dispatcher(service: &ServiceDetail) -> String {
    let mut out = String::new();
    let service_name = service.name.to_upper_camel_case();
    let server_trait = format!("{service_name}Server");

    out.push_str(&format!("/// Dispatcher for {service_name} service.\n"));
    out.push_str(&format!("pub struct {service_name}Dispatcher<S> {{\n"));
    out.push_str("    service: S,\n");
    out.push_str("}\n\n");

    out.push_str(&format!("impl<S> {service_name}Dispatcher<S> {{\n"));
    out.push_str("    pub fn new(service: S) -> Self {\n");
    out.push_str("        Self { service }\n");
    out.push_str("    }\n");
    out.push_str("}\n\n");

    // Implement ServiceDispatcher trait
    out.push_str(&format!(
        "impl<S: {server_trait}> ::roam_tcp::ServiceDispatcher for {service_name}Dispatcher<S> {{\n"
    ));
    out.push_str("    fn dispatch_unary(\n");
    out.push_str("        &self,\n");
    out.push_str("        method_id: u64,\n");
    out.push_str("        payload: &[u8],\n");
    out.push_str("    ) -> impl std::future::Future<Output = Result<Vec<u8>, String>> + Send {\n");
    out.push_str("        // Copy payload to avoid lifetime issues in async block\n");
    out.push_str("        let payload = payload.to_vec();\n");
    out.push_str("        async move {\n");
    out.push_str("            match method_id {\n");

    for method in &service.methods {
        let id = crate::method_id(method);
        let method_name = method.method_name.to_snake_case();

        out.push_str(&format!("                {} => {{\n", hex_u64(id)));

        // Check if this is a unary method (no streaming)
        let has_streaming =
            method.args.iter().any(|a| is_stream(&a.type_info)) || is_stream(&method.return_type);

        if has_streaming {
            out.push_str(&format!(
                "                    // TODO: streaming dispatch for {method_name}\n"
            ));
            out.push_str(
                "                    Err(\"streaming methods not yet implemented\".into())\n",
            );
        } else {
            // Generate unary dispatch
            out.push_str(&generate_unary_dispatch(method));
        }

        out.push_str("                }\n");
    }

    out.push_str("                _ => Err(format!(\"unknown method: {method_id}\")),\n");
    out.push_str("            }\n");
    out.push_str("        }\n");
    out.push_str("    }\n");
    out.push_str("}\n");

    out
}

/// Generate dispatch code for a unary method.
fn generate_unary_dispatch(method: &MethodDetail) -> String {
    let mut out = String::new();
    let method_name = method.method_name.to_snake_case();

    // Decode arguments
    if method.args.is_empty() {
        // No arguments to decode
    } else if method.args.len() == 1 {
        let arg = &method.args[0];
        let arg_name = arg.name.to_snake_case();
        let arg_ty = rust_type_server_arg(&arg.type_info);
        out.push_str(&format!(
            "                    let {arg_name}: {arg_ty} = facet_postcard::from_slice(&payload)\n"
        ));
        out.push_str("                        .map_err(|e| format!(\"decode error: {e}\"))?;\n");
    } else {
        // Multiple arguments - decode as tuple
        let arg_types: Vec<String> = method
            .args
            .iter()
            .map(|a| rust_type_server_arg(&a.type_info))
            .collect();
        let tuple_ty = format!("({})", arg_types.join(", "));
        out.push_str(&format!(
            "                    let args: {tuple_ty} = facet_postcard::from_slice(&payload)\n"
        ));
        out.push_str("                        .map_err(|e| format!(\"decode error: {e}\"))?;\n");

        // Unpack tuple into named variables
        for (i, arg) in method.args.iter().enumerate() {
            let arg_name = arg.name.to_snake_case();
            out.push_str(&format!("                    let {arg_name} = args.{i};\n"));
        }
    }

    // Call the method
    let arg_names: Vec<String> = method.args.iter().map(|a| a.name.to_snake_case()).collect();
    let call_args = arg_names.join(", ");

    out.push_str(&format!(
        "                    let result = self.service.{method_name}({call_args}).await\n"
    ));
    out.push_str("                        .map_err(|e| format!(\"method error: {e}\"))?;\n");

    // Encode response
    out.push_str("                    facet_postcard::to_vec(&result)\n");
    out.push_str("                        .map_err(|e| format!(\"encode error: {e}\"))\n");

    out
}

/// Check if a type is a stream.
fn is_stream(ty: &TypeDetail) -> bool {
    matches!(ty, TypeDetail::Stream(_))
}

/// Convert TypeDetail to Rust type string for client arguments.
/// Streaming args become Push<T> from caller perspective.
fn rust_type_client_arg(ty: &TypeDetail) -> String {
    match ty {
        TypeDetail::Stream(inner) => format!("Push<{}>", rust_type_client_arg(inner)),
        _ => rust_type_base(ty),
    }
}

/// Convert TypeDetail to Rust type string for client returns.
/// Streaming returns become Pull<T> from caller perspective.
fn rust_type_client_return(ty: &TypeDetail) -> String {
    match ty {
        TypeDetail::Stream(inner) => format!("Pull<{}>", rust_type_client_return(inner)),
        _ => rust_type_base(ty),
    }
}

/// Convert TypeDetail to Rust type string for server arguments.
/// Streaming args become Pull<T> from callee perspective (receives what client pushes).
fn rust_type_server_arg(ty: &TypeDetail) -> String {
    match ty {
        TypeDetail::Stream(inner) => format!("Pull<{}>", rust_type_server_arg(inner)),
        _ => rust_type_base(ty),
    }
}

/// Convert TypeDetail to Rust type string for server returns.
/// Streaming returns become Push<T> from callee perspective (pushes what client pulls).
fn rust_type_server_return(ty: &TypeDetail) -> String {
    match ty {
        TypeDetail::Stream(inner) => format!("Push<{}>", rust_type_server_return(inner)),
        _ => rust_type_base(ty),
    }
}

/// Convert TypeDetail to base Rust type (non-streaming).
fn rust_type_base(ty: &TypeDetail) -> String {
    match ty {
        TypeDetail::Bool => "bool".into(),
        TypeDetail::U8 => "u8".into(),
        TypeDetail::U16 => "u16".into(),
        TypeDetail::U32 => "u32".into(),
        TypeDetail::U64 => "u64".into(),
        TypeDetail::U128 => "u128".into(),
        TypeDetail::I8 => "i8".into(),
        TypeDetail::I16 => "i16".into(),
        TypeDetail::I32 => "i32".into(),
        TypeDetail::I64 => "i64".into(),
        TypeDetail::I128 => "i128".into(),
        TypeDetail::F32 => "f32".into(),
        TypeDetail::F64 => "f64".into(),
        TypeDetail::Char => "char".into(),
        TypeDetail::String => "String".into(),
        TypeDetail::Unit => "()".into(),
        TypeDetail::Bytes => "Vec<u8>".into(),
        TypeDetail::List(inner) => format!("Vec<{}>", rust_type_base(inner)),
        TypeDetail::Option(inner) => format!("Option<{}>", rust_type_base(inner)),
        TypeDetail::Array { element, len } => format!("[{}; {}]", rust_type_base(element), len),
        TypeDetail::Map { key, value } => {
            format!(
                "std::collections::HashMap<{}, {}>",
                rust_type_base(key),
                rust_type_base(value)
            )
        }
        TypeDetail::Set(inner) => {
            format!("std::collections::HashSet<{}>", rust_type_base(inner))
        }
        TypeDetail::Tuple(items) => {
            let inner = items
                .iter()
                .map(rust_type_base)
                .collect::<Vec<_>>()
                .join(", ");
            format!("({inner})")
        }
        TypeDetail::Stream(inner) => {
            // Should be handled by caller-specific functions, but fallback
            format!("/* stream */ {}", rust_type_base(inner))
        }
        TypeDetail::Struct { fields } => {
            // Anonymous struct - represent as tuple for now
            // In practice, these would have named types
            let inner = fields
                .iter()
                .map(|f| rust_type_base(&f.type_info))
                .collect::<Vec<_>>()
                .join(", ");
            format!("({inner})")
        }
        TypeDetail::Enum { variants: _ } => {
            // Anonymous enum - would need named type in practice
            "/* enum */".into()
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use roam_schema::{ArgDetail, MethodDetail, ServiceDetail, TypeDetail};

    fn sample_service() -> ServiceDetail {
        ServiceDetail {
            name: "Calculator".into(),
            doc: Some("A simple calculator service.".into()),
            methods: vec![MethodDetail {
                service_name: "Calculator".into(),
                method_name: "add".into(),
                args: vec![
                    ArgDetail {
                        name: "a".into(),
                        type_info: TypeDetail::I32,
                    },
                    ArgDetail {
                        name: "b".into(),
                        type_info: TypeDetail::I32,
                    },
                ],
                return_type: TypeDetail::I32,
                doc: Some("Add two numbers.".into()),
            }],
        }
    }

    #[test]
    fn test_generate_service() {
        let service = sample_service();
        let code = generate_service(&service);

        assert!(code.contains("pub trait CalculatorClient"));
        assert!(code.contains("pub trait CalculatorServer"));
        assert!(code.contains("pub struct CalculatorDispatcher"));
        assert!(code.contains("fn add("));
        assert!(code.contains("pub mod method_id"));
        assert!(code.contains("pub const ADD: u64"));
    }

    #[test]
    fn test_streaming_types() {
        // Client pushes data to server
        let push_ty = TypeDetail::Stream(Box::new(TypeDetail::String));
        assert_eq!(rust_type_client_arg(&push_ty), "Push<String>");
        assert_eq!(rust_type_server_arg(&push_ty), "Pull<String>");

        // Server returns stream to client
        let pull_ty = TypeDetail::Stream(Box::new(TypeDetail::U32));
        assert_eq!(rust_type_client_return(&pull_ty), "Pull<u32>");
        assert_eq!(rust_type_server_return(&pull_ty), "Push<u32>");
    }
}
