//! Rust code generation for roam services.
//!
//! Generates caller traits and handler dispatchers from ServiceDetail.
//! Intended for use in build.rs scripts.

use codegen::{Block, Impl, Scope};
use heck::{ToSnakeCase, ToUpperCamelCase};
use roam_schema::{MethodDetail, ServiceDetail, TypeDetail, VariantDetail, VariantPayload};

use crate::render::hex_u64;

/// Options for Rust code generation.
#[derive(Debug, Clone, Default)]
pub struct RustCodegenOptions {
    /// Generate tracing spans and events for RPC calls.
    ///
    /// When enabled, each method dispatch will be wrapped in a `tracing::debug_span!`
    /// with the service and method name. Events are emitted for request/response sizes.
    ///
    /// Requires the `tracing` crate in the consuming crate.
    pub tracing: bool,
}

/// Generator for Rust code from service definitions.
struct RustGenerator<'a> {
    service: &'a ServiceDetail,
    options: &'a RustCodegenOptions,
    scope: Scope,
}

impl<'a> RustGenerator<'a> {
    fn new(service: &'a ServiceDetail, options: &'a RustCodegenOptions) -> Self {
        Self {
            service,
            options,
            scope: Scope::new(),
        }
    }

    fn generate(mut self) -> String {
        // Header comment - only once per file (caller should only include once)
        self.scope.raw("// @generated by roam-codegen");
        self.scope
            .raw("// DO NOT EDIT - regenerate with build.rs\n");

        // Wrap in module named after the service to avoid conflicts
        // Use outer attributes to suppress clippy/unused warnings on generated code
        let mod_name = self.service.name.to_snake_case();
        self.scope.raw(format!(
            "#[allow(clippy::all, unused)]\npub mod {mod_name} {{"
        ));

        // Re-export common types for convenience
        self.scope.raw(
            "    pub use ::roam::session::{Push, Pull, StreamId, RoamError, CallResult, Never};",
        );

        // Internal imports for codegen (with allow to suppress warnings when not all are used)
        self.scope
            .raw("    #[allow(unused_imports)]\n    use ::roam::__private::facet_postcard;");

        // Generate method IDs
        self.generate_method_ids();

        // Generate caller trait (for making calls)
        self.generate_caller_trait();

        // Generate handler trait and dispatcher (for handling calls)
        self.generate_handler_trait();
        self.generate_dispatcher();

        // Close module
        self.scope.raw("}");

        self.scope.to_string()
    }

    fn generate_method_ids(&mut self) {
        // method_id module is now scoped within the service module, so no prefix needed
        self.scope
            .raw("    /// Method IDs for this service.\n    pub mod method_id {");

        for method in &self.service.methods {
            let id = crate::method_id(method);
            let const_name = method.method_name.to_snake_case().to_uppercase();
            self.scope.raw(format!(
                "        pub const {const_name}: u64 = {};",
                hex_u64(id)
            ));
        }

        self.scope.raw("    }");
    }

    fn generate_caller_trait(&mut self) {
        let trait_name = format!("{}Caller", self.service.name.to_upper_camel_case());
        let trait_def = self.scope.new_trait(&trait_name);
        trait_def.vis("pub");

        if let Some(doc) = &self.service.doc {
            trait_def.doc(doc);
        }

        for method in &self.service.methods {
            let method_name = method.method_name.to_snake_case();

            // Build the function
            let func = trait_def.new_fn(&method_name);
            func.arg_ref_self();

            // Add arguments
            for arg in &method.args {
                let ty = rust_type_client_arg(&arg.type_info);
                func.arg(&arg.name.to_snake_case(), ty);
            }

            // Return type
            let ret_ty = rust_type_client_return(&method.return_type);
            func.ret(format!(
                "impl ::std::future::Future<Output = ::std::result::Result<{ret_ty}, ::std::boxed::Box<dyn ::std::error::Error + Send + Sync>>> + Send"
            ));

            if let Some(doc) = &method.doc {
                func.doc(doc);
            }
        }
    }

    fn generate_handler_trait(&mut self) {
        let trait_name = format!("{}Handler", self.service.name.to_upper_camel_case());
        let trait_def = self.scope.new_trait(&trait_name);
        trait_def.vis("pub");
        trait_def.bound("Self", "Send + Sync");

        // Doc comment with prefix for handler
        if let Some(doc) = &self.service.doc {
            trait_def.doc(&format!("Handler for: {doc}"));
        } else {
            trait_def.doc("Handler trait for incoming calls.");
        }

        for method in &self.service.methods {
            let method_name = method.method_name.to_snake_case();

            // Build the function
            let func = trait_def.new_fn(&method_name);
            func.arg_ref_self();

            // Add arguments (with handler perspective types)
            for arg in &method.args {
                let ty = rust_type_server_arg(&arg.type_info);
                func.arg(&arg.name.to_snake_case(), ty);
            }

            // Return type
            let ret_ty = rust_type_server_return(&method.return_type);
            func.ret(format!(
                "impl ::std::future::Future<Output = ::std::result::Result<{ret_ty}, ::std::boxed::Box<dyn ::std::error::Error + Send + Sync>>> + Send"
            ));

            if let Some(doc) = &method.doc {
                func.doc(doc);
            }
        }
    }

    fn generate_dispatcher(&mut self) {
        let service_name = self.service.name.to_upper_camel_case();
        let handler_trait = format!("{service_name}Handler");

        // Dispatcher struct
        let struct_def = self.scope.new_struct(&format!("{service_name}Dispatcher"));
        struct_def.vis("pub");
        struct_def.generic("S");
        struct_def.doc(&format!("Dispatcher for {service_name} service."));
        struct_def.field("service", "S");

        // impl block for new()
        {
            let impl_block = self.scope.new_impl(&format!("{service_name}Dispatcher<S>"));
            impl_block.generic("S");

            let new_fn = impl_block.new_fn("new");
            new_fn.vis("pub");
            new_fn.arg("service", "S");
            new_fn.ret("Self");
            new_fn.line("Self { service }");
        }

        // impl ServiceDispatcher for Dispatcher
        {
            let impl_block = self.scope.new_impl(&format!("{service_name}Dispatcher<S>"));
            impl_block.generic("S");
            impl_block.bound("S", &handler_trait);
            impl_block.impl_trait("::roam_stream::ServiceDispatcher");

            generate_is_streaming(impl_block, self.service);
            generate_dispatch_unary(impl_block, self.service, self.options);
            generate_dispatch_streaming(impl_block, self.service, self.options);
        }
    }
}

fn generate_is_streaming(impl_block: &mut Impl, service: &ServiceDetail) {
    let func = impl_block.new_fn("is_streaming");
    func.arg_ref_self();
    func.arg("method_id", "u64");
    func.ret("bool");

    let streaming_ids: Vec<String> = service
        .methods
        .iter()
        .filter(|m| m.args.iter().any(|a| is_stream(&a.type_info)) || is_stream(&m.return_type))
        .map(|m| hex_u64(crate::method_id(m)))
        .collect();

    if streaming_ids.is_empty() {
        func.line("let _ = method_id;");
        func.line("false");
    } else {
        func.line(format!(
            "matches!(method_id, {})",
            streaming_ids.join(" | ")
        ));
    }
}

fn generate_dispatch_unary(
    impl_block: &mut Impl,
    service: &ServiceDetail,
    options: &RustCodegenOptions,
) {
    let func = impl_block.new_fn("dispatch_unary");
    func.arg_ref_self();
    func.arg("method_id", "u64");
    func.arg("payload", "&[u8]");
    func.ret("impl ::std::future::Future<Output = ::std::result::Result<::std::vec::Vec<u8>, ::std::string::String>> + Send");

    func.line("// Copy payload to avoid lifetime issues in async block");
    func.line("let payload = payload.to_vec();");

    // Build async block
    let mut async_block = Block::new("async move");

    // Match block
    let mut match_block = Block::new("match method_id");

    for method in &service.methods {
        let id = crate::method_id(method);
        let has_streaming =
            method.args.iter().any(|a| is_stream(&a.type_info)) || is_stream(&method.return_type);

        if has_streaming {
            // Streaming methods handled by dispatch_streaming
            continue;
        }

        let mut arm = Block::new(&format!("{} =>", hex_u64(id)));
        generate_unary_dispatch_body(method, &mut arm, service, options);
        match_block.push_block(arm);
    }

    // r[impl unary.error.unknown-method] - Unknown method_id returns RoamError::UnknownMethod
    // Default arm - encode UnknownMethod error in response payload per spec r[unary.response.encoding]
    match_block.line("_ => {");
    match_block.line("    let result: CallResult<(), Never> = Err(RoamError::UnknownMethod);");
    match_block
        .line("    facet_postcard::to_vec(&result).map_err(|e| format!(\"encode error: {e}\"))");
    match_block.line("}");

    async_block.push_block(match_block);
    func.push_block(async_block);
}

fn generate_unary_dispatch_body(
    method: &MethodDetail,
    block: &mut Block,
    service: &ServiceDetail,
    options: &RustCodegenOptions,
) {
    let method_name = method.method_name.to_snake_case();
    let return_ty = rust_type_server_return(&method.return_type);

    // r[impl unary.error.invalid-payload] - Deserialization failure returns RoamError::InvalidPayload
    // Helper to encode InvalidPayload error per spec r[unary.response.encoding]
    let encode_invalid_payload = format!(
        "let err_result: CallResult<{return_ty}, Never> = Err(RoamError::InvalidPayload); \
         return facet_postcard::to_vec(&err_result).map_err(|e| format!(\"encode error: {{e}}\"));"
    );

    // Decode arguments - on error, encode InvalidPayload in response
    if method.args.is_empty() {
        // No arguments to decode
    } else if method.args.len() == 1 {
        let arg = &method.args[0];
        let arg_name = arg.name.to_snake_case();
        let arg_ty = rust_type_server_arg(&arg.type_info);
        block.line(format!(
            "let {arg_name}: {arg_ty} = match facet_postcard::from_slice(&payload) {{"
        ));
        block.line("    Ok(v) => v,");
        block.line(format!("    Err(_) => {{ {encode_invalid_payload} }}"));
        block.line("};");
    } else {
        // Multiple arguments - decode as tuple
        let arg_types: Vec<String> = method
            .args
            .iter()
            .map(|a| rust_type_server_arg(&a.type_info))
            .collect();
        let tuple_ty = format!("({})", arg_types.join(", "));
        block.line(format!(
            "let args: {tuple_ty} = match facet_postcard::from_slice(&payload) {{"
        ));
        block.line("    Ok(v) => v,");
        block.line(format!("    Err(_) => {{ {encode_invalid_payload} }}"));
        block.line("};");

        // Unpack tuple into named variables
        for (i, arg) in method.args.iter().enumerate() {
            let arg_name = arg.name.to_snake_case();
            block.line(format!("let {arg_name} = args.{i};"));
        }
    }

    // Call the method
    let arg_names: Vec<String> = method.args.iter().map(|a| a.name.to_snake_case()).collect();
    let call_args = arg_names.join(", ");

    // Tracing support
    if options.tracing {
        let service_name = service.name.to_upper_camel_case();
        block.line(format!(
            "let span = tracing::debug_span!(\"rpc\", service = \"{service_name}\", method = \"{method_name}\");"
        ));
        block.line("let _guard = span.enter();");
        block.line("tracing::debug!(payload_len = payload.len(), \"request received\");");
    }

    // Call handler and encode response per spec r[unary.response.encoding]
    // Response is always CallResult<T, Never> = Result<T, RoamError<Never>>
    if method.return_type == TypeDetail::Unit {
        block.line(format!("self.service.{method_name}({call_args}).await"));
        block.line("    .map_err(|e| format!(\"method error: {e}\"))?;");
        block.line(format!(
            "let call_result: CallResult<{return_ty}, Never> = Ok(());"
        ));
    } else {
        block.line(format!(
            "let result = self.service.{method_name}({call_args}).await"
        ));
        block.line("    .map_err(|e| format!(\"method error: {e}\"))?;");
        block.line(format!(
            "let call_result: CallResult<{return_ty}, Never> = Ok(result);"
        ));
    }

    if options.tracing {
        block.line("let response = facet_postcard::to_vec(&call_result)");
        block.line("    .map_err(|e| format!(\"encode error: {e}\"))?;");
        block.line("tracing::debug!(response_len = response.len(), \"response ready\");");
        block.line("Ok(response)");
    } else {
        block.line("facet_postcard::to_vec(&call_result)");
        block.line("    .map_err(|e| format!(\"encode error: {e}\"))");
    }
}

fn generate_dispatch_streaming(
    impl_block: &mut Impl,
    service: &ServiceDetail,
    options: &RustCodegenOptions,
) {
    let ret_type = "::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::vec::Vec<u8>, ::std::string::String>> + Send + '_>>";

    let func = impl_block.new_fn("dispatch_streaming");
    func.arg_ref_self();
    func.arg("method_id", "u64");
    func.arg("payload", "Vec<u8>");
    func.arg("registry", "&mut ::roam_stream::StreamRegistry");
    func.ret(ret_type);

    // Collect streaming methods
    let streaming_methods: Vec<_> = service
        .methods
        .iter()
        .filter(|m| m.args.iter().any(|a| is_stream(&a.type_info)) || is_stream(&m.return_type))
        .collect();

    if streaming_methods.is_empty() {
        let mut async_block = Block::new("::std::boxed::Box::pin(async move");
        async_block.after(")");
        async_block.line("let _ = method_id;");
        async_block.line("let result: CallResult<(), Never> = Err(RoamError::UnknownMethod);");
        async_block
            .line("facet_postcard::to_vec(&result).map_err(|e| format!(\"encode error: {e}\"))");
        func.push_block(async_block);
    } else {
        func.line("// Each streaming method sets up handles and returns a boxed future");

        let mut match_block = Block::new("match method_id");

        for method in &streaming_methods {
            let id = crate::method_id(method);
            let method_name = method.method_name.to_snake_case();
            let mut arm = Block::new(&format!("{} =>", hex_u64(id)));
            arm.line(format!("// Setup for {method_name}"));
            generate_streaming_setup_and_dispatch(method, &mut arm, service, options);
            match_block.push_block(arm);
        }

        // r[impl unary.error.unknown-method] - Unknown method_id returns RoamError::UnknownMethod
        // Default arm - encode UnknownMethod error per spec r[unary.response.encoding]
        let mut default_arm = Block::new("_ => ::std::boxed::Box::pin(async move");
        default_arm.after("),");
        default_arm.line("let result: CallResult<(), Never> = Err(RoamError::UnknownMethod);");
        default_arm
            .line("facet_postcard::to_vec(&result).map_err(|e| format!(\"encode error: {e}\"))");
        match_block.push_block(default_arm);

        func.push_block(match_block);
    }
}

fn generate_streaming_setup_and_dispatch(
    method: &MethodDetail,
    block: &mut Block,
    service: &ServiceDetail,
    options: &RustCodegenOptions,
) {
    let method_name = method.method_name.to_snake_case();

    // Build the wire type (streaming args are u64 on the wire)
    let wire_types: Vec<String> = method
        .args
        .iter()
        .map(|a| {
            if is_stream(&a.type_info) {
                "StreamId".into()
            } else {
                rust_type_server_arg(&a.type_info)
            }
        })
        .collect();

    // Decode and set up handles
    if method.args.is_empty() {
        // No arguments - just call the method
    } else if method.args.len() == 1 {
        let arg = &method.args[0];
        let arg_name = arg.name.to_snake_case();

        if is_stream(&arg.type_info) {
            let mut decode = Block::new(&format!(
                "let {arg_name}_id: StreamId = match facet_postcard::from_slice(&payload)"
            ));
            decode.line("Ok(id) => id,");
            decode.line("Err(e) => return ::std::boxed::Box::pin(async move { Err(format!(\"decode error: {e}\")) }),");
            decode.after(";");
            block.push_block(decode);

            generate_stream_handle_creation(block, &arg_name, &arg.type_info);
        } else {
            let mut decode = Block::new(&format!(
                "let {arg_name}: {} = match facet_postcard::from_slice(&payload)",
                wire_types[0]
            ));
            decode.line("Ok(v) => v,");
            decode.line("Err(e) => return ::std::boxed::Box::pin(async move { Err(format!(\"decode error: {e}\")) }),");
            decode.after(";");
            block.push_block(decode);
        }
    } else {
        // Multiple arguments - decode as tuple
        let tuple_ty = format!("({})", wire_types.join(", "));
        let mut decode = Block::new(&format!(
            "let args: {tuple_ty} = match facet_postcard::from_slice(&payload)"
        ));
        decode.line("Ok(a) => a,");
        decode.line("Err(e) => return ::std::boxed::Box::pin(async move { Err(format!(\"decode error: {e}\")) }),");
        decode.after(";");
        block.push_block(decode);

        // Create handles for each streaming arg, pass through non-streaming args
        for (i, arg) in method.args.iter().enumerate() {
            let arg_name = arg.name.to_snake_case();
            if is_stream(&arg.type_info) {
                block.line(format!("let {arg_name}_id: StreamId = args.{i};"));
                generate_stream_handle_creation(block, &arg_name, &arg.type_info);
            } else {
                block.line(format!("let {arg_name} = args.{i};"));
            }
        }
    }

    // Now generate the async block
    let arg_names: Vec<String> = method.args.iter().map(|a| a.name.to_snake_case()).collect();
    let call_args = arg_names.join(", ");

    let mut async_block = Block::new("::std::boxed::Box::pin(async move");
    async_block.after(")");

    // Tracing support for streaming methods
    if options.tracing {
        let service_name = service.name.to_upper_camel_case();
        async_block.line(format!(
            "let span = tracing::debug_span!(\"rpc\", service = \"{service_name}\", method = \"{method_name}\");"
        ));
        async_block.line("let _guard = span.enter();");
        async_block
            .line("tracing::debug!(payload_len = payload.len(), \"streaming request received\");");
    }

    // For unit return types, don't bind to a variable (clippy: let_unit_value)
    if method.return_type == TypeDetail::Unit {
        async_block.line(format!("self.service.{method_name}({call_args}).await"));
        async_block.line("    .map_err(|e| format!(\"method error: {e}\"))?;");

        if options.tracing {
            async_block.line("let response = facet_postcard::to_vec(&())");
        } else {
            async_block.line("facet_postcard::to_vec(&())");
        }
    } else {
        async_block.line(format!(
            "let result = self.service.{method_name}({call_args}).await"
        ));
        async_block.line("    .map_err(|e| format!(\"method error: {e}\"))?;");

        if options.tracing {
            async_block.line("let response = facet_postcard::to_vec(&result)");
        } else {
            async_block.line("facet_postcard::to_vec(&result)");
        }
    }

    if options.tracing {
        async_block.line("    .map_err(|e| format!(\"encode error: {e}\"))?;");
        async_block
            .line("tracing::debug!(response_len = response.len(), \"streaming response ready\");");
        async_block.line("Ok(response)");
    } else {
        async_block.line("    .map_err(|e| format!(\"encode error: {e}\"))");
    }

    block.push_block(async_block);
}

fn generate_stream_handle_creation(block: &mut Block, arg_name: &str, ty: &TypeDetail) {
    match ty {
        TypeDetail::Push(inner) => {
            // Caller sends → Handler receives via Pull
            let inner_ty = rust_type_base(inner);
            block.line(format!(
                "let {arg_name}_rx = registry.register_incoming({arg_name}_id);"
            ));
            block.line(format!(
                "let {arg_name}: Pull<{inner_ty}> = Pull::new({arg_name}_id, {arg_name}_rx);"
            ));
        }
        TypeDetail::Pull(inner) => {
            // Caller receives → Handler sends via Push
            let inner_ty = rust_type_base(inner);
            block.line(format!(
                "let {arg_name}_sender = registry.register_outgoing({arg_name}_id);"
            ));
            block.line(format!(
                "let {arg_name}: Push<{inner_ty}> = Push::new({arg_name}_sender);"
            ));
        }
        _ => {}
    }
}

/// Generate a complete Rust module for a service with default options.
///
/// r[impl codegen.rust.service] - Generate client, server, and method IDs.
pub fn generate_service(service: &ServiceDetail) -> String {
    generate_service_with_options(service, &RustCodegenOptions::default())
}

/// Generate a complete Rust module for a service with custom options.
///
/// r[impl codegen.rust.service] - Generate client, server, and method IDs.
pub fn generate_service_with_options(
    service: &ServiceDetail,
    options: &RustCodegenOptions,
) -> String {
    RustGenerator::new(service, options).generate()
}

/// Check if a type is a stream (Push or Pull).
fn is_stream(ty: &TypeDetail) -> bool {
    matches!(ty, TypeDetail::Push(_) | TypeDetail::Pull(_))
}

/// Convert TypeDetail to Rust type string for client arguments.
/// Push<T> stays Push<T> (client sends), Pull<T> stays Pull<T> (client receives).
fn rust_type_client_arg(ty: &TypeDetail) -> String {
    match ty {
        TypeDetail::Push(inner) => format!("Push<{}>", rust_type_base(inner)),
        TypeDetail::Pull(inner) => format!("Pull<{}>", rust_type_base(inner)),
        _ => rust_type_base(ty),
    }
}

/// Convert TypeDetail to Rust type string for client returns.
/// Streams should not appear in return types per spec r[core.stream.return-forbidden].
fn rust_type_client_return(ty: &TypeDetail) -> String {
    rust_type_base(ty)
}

/// Convert TypeDetail to Rust type string for server arguments.
/// Push<T> becomes Pull<T> (server receives what client pushes).
/// Pull<T> becomes Push<T> (server sends what client pulls).
fn rust_type_server_arg(ty: &TypeDetail) -> String {
    match ty {
        TypeDetail::Push(inner) => format!("Pull<{}>", rust_type_base(inner)),
        TypeDetail::Pull(inner) => format!("Push<{}>", rust_type_base(inner)),
        _ => rust_type_base(ty),
    }
}

/// Convert TypeDetail to Rust type string for server returns.
/// Streams should not appear in return types per spec r[core.stream.return-forbidden].
fn rust_type_server_return(ty: &TypeDetail) -> String {
    rust_type_base(ty)
}

/// Convert TypeDetail to base Rust type (non-streaming).
fn rust_type_base(ty: &TypeDetail) -> String {
    match ty {
        TypeDetail::Bool => "bool".into(),
        TypeDetail::U8 => "u8".into(),
        TypeDetail::U16 => "u16".into(),
        TypeDetail::U32 => "u32".into(),
        TypeDetail::U64 => "u64".into(),
        TypeDetail::U128 => "u128".into(),
        TypeDetail::I8 => "i8".into(),
        TypeDetail::I16 => "i16".into(),
        TypeDetail::I32 => "i32".into(),
        TypeDetail::I64 => "i64".into(),
        TypeDetail::I128 => "i128".into(),
        TypeDetail::F32 => "f32".into(),
        TypeDetail::F64 => "f64".into(),
        TypeDetail::Char => "char".into(),
        TypeDetail::String => "::std::string::String".into(),
        TypeDetail::Unit => "()".into(),
        TypeDetail::Bytes => "::std::vec::Vec<u8>".into(),
        TypeDetail::List(inner) => format!("::std::vec::Vec<{}>", rust_type_base(inner)),
        TypeDetail::Option(inner) => format!("::std::option::Option<{}>", rust_type_base(inner)),
        TypeDetail::Array { element, len } => format!("[{}; {}]", rust_type_base(element), len),
        TypeDetail::Map { key, value } => {
            format!(
                "::std::collections::HashMap<{}, {}>",
                rust_type_base(key),
                rust_type_base(value)
            )
        }
        TypeDetail::Set(inner) => {
            format!("::std::collections::HashSet<{}>", rust_type_base(inner))
        }
        TypeDetail::Tuple(items) => {
            let inner = items
                .iter()
                .map(rust_type_base)
                .collect::<Vec<_>>()
                .join(", ");
            format!("({inner})")
        }
        TypeDetail::Push(inner) => {
            // Should be handled by caller-specific functions, but fallback
            format!("Push<{}>", rust_type_base(inner))
        }
        TypeDetail::Pull(inner) => {
            // Should be handled by caller-specific functions, but fallback
            format!("Pull<{}>", rust_type_base(inner))
        }
        TypeDetail::Struct { name, fields } => {
            if let Some(name) = name {
                // Named struct - prefix with super:: to access from within service module
                format!("super::{name}")
            } else {
                // Anonymous struct - represent as tuple
                let inner = fields
                    .iter()
                    .map(|f| rust_type_base(&f.type_info))
                    .collect::<Vec<_>>()
                    .join(", ");
                format!("({inner})")
            }
        }
        TypeDetail::Enum { name, variants } => {
            if let Some(name) = name {
                // Named enum - prefix with super:: to access from within service module
                format!("super::{name}")
            } else {
                // Check for Result pattern: two variants Ok(T) and Err(E)
                if variants.len() == 2 {
                    let ok_variant = variants.iter().find(|v| v.name == "Ok");
                    let err_variant = variants.iter().find(|v| v.name == "Err");
                    if let (
                        Some(VariantDetail {
                            payload: VariantPayload::Newtype(ok_ty),
                            ..
                        }),
                        Some(VariantDetail {
                            payload: VariantPayload::Newtype(err_ty),
                            ..
                        }),
                    ) = (ok_variant, err_variant)
                    {
                        return format!(
                            "::std::result::Result<{}, {}>",
                            rust_type_base(ok_ty),
                            rust_type_base(err_ty)
                        );
                    }
                }
                // Other anonymous enum - represent structure (shouldn't happen in practice)
                let variant_names: Vec<_> = variants.iter().map(|v| v.name.as_str()).collect();
                format!("/* enum({}) */", variant_names.join("|"))
            }
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use roam_schema::{
        ArgDetail, FieldDetail, MethodDetail, ServiceDetail, TypeDetail, VariantDetail,
        VariantPayload,
    };

    // ===========================================
    // rust_type_base tests for all type variants
    // ===========================================

    mod primitives {
        use super::*;

        #[test]
        fn bool_type() {
            assert_eq!(rust_type_base(&TypeDetail::Bool), "bool");
        }

        #[test]
        fn unsigned_integers() {
            assert_eq!(rust_type_base(&TypeDetail::U8), "u8");
            assert_eq!(rust_type_base(&TypeDetail::U16), "u16");
            assert_eq!(rust_type_base(&TypeDetail::U32), "u32");
            assert_eq!(rust_type_base(&TypeDetail::U64), "u64");
            assert_eq!(rust_type_base(&TypeDetail::U128), "u128");
        }

        #[test]
        fn signed_integers() {
            assert_eq!(rust_type_base(&TypeDetail::I8), "i8");
            assert_eq!(rust_type_base(&TypeDetail::I16), "i16");
            assert_eq!(rust_type_base(&TypeDetail::I32), "i32");
            assert_eq!(rust_type_base(&TypeDetail::I64), "i64");
            assert_eq!(rust_type_base(&TypeDetail::I128), "i128");
        }

        #[test]
        fn floats() {
            assert_eq!(rust_type_base(&TypeDetail::F32), "f32");
            assert_eq!(rust_type_base(&TypeDetail::F64), "f64");
        }

        #[test]
        fn char_type() {
            assert_eq!(rust_type_base(&TypeDetail::Char), "char");
        }

        #[test]
        fn string_type() {
            assert_eq!(rust_type_base(&TypeDetail::String), "::std::string::String");
        }

        #[test]
        fn unit_type() {
            assert_eq!(rust_type_base(&TypeDetail::Unit), "()");
        }

        #[test]
        fn bytes_type() {
            assert_eq!(rust_type_base(&TypeDetail::Bytes), "::std::vec::Vec<u8>");
        }
    }

    mod containers {
        use super::*;

        #[test]
        fn list_of_primitives() {
            let ty = TypeDetail::List(Box::new(TypeDetail::I32));
            assert_eq!(rust_type_base(&ty), "::std::vec::Vec<i32>");
        }

        #[test]
        fn list_of_strings() {
            let ty = TypeDetail::List(Box::new(TypeDetail::String));
            assert_eq!(
                rust_type_base(&ty),
                "::std::vec::Vec<::std::string::String>"
            );
        }

        #[test]
        fn option_of_primitive() {
            let ty = TypeDetail::Option(Box::new(TypeDetail::U64));
            assert_eq!(rust_type_base(&ty), "::std::option::Option<u64>");
        }

        #[test]
        fn option_of_string() {
            let ty = TypeDetail::Option(Box::new(TypeDetail::String));
            assert_eq!(
                rust_type_base(&ty),
                "::std::option::Option<::std::string::String>"
            );
        }

        #[test]
        fn array_type() {
            let ty = TypeDetail::Array {
                element: Box::new(TypeDetail::U8),
                len: 32,
            };
            assert_eq!(rust_type_base(&ty), "[u8; 32]");
        }

        #[test]
        fn map_type() {
            let ty = TypeDetail::Map {
                key: Box::new(TypeDetail::String),
                value: Box::new(TypeDetail::I32),
            };
            assert_eq!(
                rust_type_base(&ty),
                "::std::collections::HashMap<::std::string::String, i32>"
            );
        }

        #[test]
        fn set_type() {
            let ty = TypeDetail::Set(Box::new(TypeDetail::String));
            assert_eq!(
                rust_type_base(&ty),
                "::std::collections::HashSet<::std::string::String>"
            );
        }

        #[test]
        fn tuple_type() {
            let ty = TypeDetail::Tuple(vec![TypeDetail::U32, TypeDetail::String, TypeDetail::Bool]);
            assert_eq!(rust_type_base(&ty), "(u32, ::std::string::String, bool)");
        }

        #[test]
        fn empty_tuple() {
            let ty = TypeDetail::Tuple(vec![]);
            assert_eq!(rust_type_base(&ty), "()");
        }

        #[test]
        fn single_element_tuple() {
            let ty = TypeDetail::Tuple(vec![TypeDetail::I32]);
            assert_eq!(rust_type_base(&ty), "(i32)");
        }
    }

    mod streams {
        use super::*;

        #[test]
        fn push_of_primitive() {
            let ty = TypeDetail::Push(Box::new(TypeDetail::U32));
            assert_eq!(rust_type_base(&ty), "Push<u32>");
        }

        #[test]
        fn push_of_string() {
            let ty = TypeDetail::Push(Box::new(TypeDetail::String));
            assert_eq!(rust_type_base(&ty), "Push<::std::string::String>");
        }

        #[test]
        fn pull_of_primitive() {
            let ty = TypeDetail::Pull(Box::new(TypeDetail::I64));
            assert_eq!(rust_type_base(&ty), "Pull<i64>");
        }

        #[test]
        fn pull_of_bytes() {
            let ty = TypeDetail::Pull(Box::new(TypeDetail::Bytes));
            assert_eq!(rust_type_base(&ty), "Pull<::std::vec::Vec<u8>>");
        }
    }

    mod composite_types {
        use super::*;

        #[test]
        fn named_struct() {
            let ty = TypeDetail::Struct {
                name: Some("MyStruct".to_string()),
                fields: vec![
                    FieldDetail {
                        name: "x".to_string(),
                        type_info: TypeDetail::I32,
                    },
                    FieldDetail {
                        name: "y".to_string(),
                        type_info: TypeDetail::I32,
                    },
                ],
            };
            // Uses super:: because generated code is inside a module
            assert_eq!(rust_type_base(&ty), "super::MyStruct");
        }

        #[test]
        fn named_struct_with_module_path() {
            let ty = TypeDetail::Struct {
                name: Some("my_module::MyStruct".to_string()),
                fields: vec![],
            };
            // Uses super:: because generated code is inside a module
            assert_eq!(rust_type_base(&ty), "super::my_module::MyStruct");
        }

        #[test]
        fn anonymous_struct_as_tuple() {
            let ty = TypeDetail::Struct {
                name: None,
                fields: vec![
                    FieldDetail {
                        name: "a".to_string(),
                        type_info: TypeDetail::U8,
                    },
                    FieldDetail {
                        name: "b".to_string(),
                        type_info: TypeDetail::String,
                    },
                ],
            };
            assert_eq!(rust_type_base(&ty), "(u8, ::std::string::String)");
        }

        #[test]
        fn named_enum() {
            let ty = TypeDetail::Enum {
                name: Some("MyEnum".to_string()),
                variants: vec![
                    VariantDetail {
                        name: "A".to_string(),
                        payload: VariantPayload::Unit,
                    },
                    VariantDetail {
                        name: "B".to_string(),
                        payload: VariantPayload::Newtype(TypeDetail::I32),
                    },
                ],
            };
            // Uses super:: because generated code is inside a module
            assert_eq!(rust_type_base(&ty), "super::MyEnum");
        }

        #[test]
        fn result_pattern_recognized() {
            // Result<T, E> is represented as anonymous enum with Ok(T) and Err(E)
            let ty = TypeDetail::Enum {
                name: None,
                variants: vec![
                    VariantDetail {
                        name: "Ok".to_string(),
                        payload: VariantPayload::Newtype(TypeDetail::String),
                    },
                    VariantDetail {
                        name: "Err".to_string(),
                        payload: VariantPayload::Newtype(TypeDetail::I32),
                    },
                ],
            };
            assert_eq!(
                rust_type_base(&ty),
                "::std::result::Result<::std::string::String, i32>"
            );
        }

        #[test]
        fn result_with_complex_types() {
            let ty = TypeDetail::Enum {
                name: None,
                variants: vec![
                    VariantDetail {
                        name: "Ok".to_string(),
                        payload: VariantPayload::Newtype(TypeDetail::List(Box::new(
                            TypeDetail::U8,
                        ))),
                    },
                    VariantDetail {
                        name: "Err".to_string(),
                        payload: VariantPayload::Newtype(TypeDetail::String),
                    },
                ],
            };
            assert_eq!(
                rust_type_base(&ty),
                "::std::result::Result<::std::vec::Vec<u8>, ::std::string::String>"
            );
        }

        #[test]
        fn result_with_named_error_type() {
            let ty = TypeDetail::Enum {
                name: None,
                variants: vec![
                    VariantDetail {
                        name: "Ok".to_string(),
                        payload: VariantPayload::Newtype(TypeDetail::Unit),
                    },
                    VariantDetail {
                        name: "Err".to_string(),
                        payload: VariantPayload::Newtype(TypeDetail::Struct {
                            name: Some("MyError".to_string()),
                            fields: vec![],
                        }),
                    },
                ],
            };
            // MyError uses super:: because generated code is inside a module
            assert_eq!(
                rust_type_base(&ty),
                "::std::result::Result<(), super::MyError>"
            );
        }

        #[test]
        fn anonymous_enum_not_result_pattern() {
            // Not a Result - different variant names
            let ty = TypeDetail::Enum {
                name: None,
                variants: vec![
                    VariantDetail {
                        name: "Success".to_string(),
                        payload: VariantPayload::Unit,
                    },
                    VariantDetail {
                        name: "Failure".to_string(),
                        payload: VariantPayload::Unit,
                    },
                ],
            };
            assert_eq!(rust_type_base(&ty), "/* enum(Success|Failure) */");
        }

        #[test]
        fn anonymous_enum_result_with_wrong_payload() {
            // Has Ok/Err but not Newtype payloads
            let ty = TypeDetail::Enum {
                name: None,
                variants: vec![
                    VariantDetail {
                        name: "Ok".to_string(),
                        payload: VariantPayload::Unit,
                    },
                    VariantDetail {
                        name: "Err".to_string(),
                        payload: VariantPayload::Unit,
                    },
                ],
            };
            assert_eq!(rust_type_base(&ty), "/* enum(Ok|Err) */");
        }
    }

    mod nested_types {
        use super::*;

        #[test]
        fn vec_of_option() {
            let ty = TypeDetail::List(Box::new(TypeDetail::Option(Box::new(TypeDetail::I32))));
            assert_eq!(
                rust_type_base(&ty),
                "::std::vec::Vec<::std::option::Option<i32>>"
            );
        }

        #[test]
        fn option_of_vec() {
            let ty = TypeDetail::Option(Box::new(TypeDetail::List(Box::new(TypeDetail::String))));
            assert_eq!(
                rust_type_base(&ty),
                "::std::option::Option<::std::vec::Vec<::std::string::String>>"
            );
        }

        #[test]
        fn map_of_vec_to_option() {
            let ty = TypeDetail::Map {
                key: Box::new(TypeDetail::String),
                value: Box::new(TypeDetail::Option(Box::new(TypeDetail::List(Box::new(
                    TypeDetail::U8,
                ))))),
            };
            assert_eq!(
                rust_type_base(&ty),
                "::std::collections::HashMap<::std::string::String, ::std::option::Option<::std::vec::Vec<u8>>>"
            );
        }

        #[test]
        fn vec_of_named_struct() {
            let ty = TypeDetail::List(Box::new(TypeDetail::Struct {
                name: Some("Item".to_string()),
                fields: vec![],
            }));
            assert_eq!(rust_type_base(&ty), "::std::vec::Vec<super::Item>");
        }

        #[test]
        fn option_of_named_enum() {
            let ty = TypeDetail::Option(Box::new(TypeDetail::Enum {
                name: Some("Status".to_string()),
                variants: vec![],
            }));
            assert_eq!(rust_type_base(&ty), "::std::option::Option<super::Status>");
        }

        #[test]
        fn push_of_result() {
            let ty = TypeDetail::Push(Box::new(TypeDetail::Enum {
                name: None,
                variants: vec![
                    VariantDetail {
                        name: "Ok".to_string(),
                        payload: VariantPayload::Newtype(TypeDetail::Bytes),
                    },
                    VariantDetail {
                        name: "Err".to_string(),
                        payload: VariantPayload::Newtype(TypeDetail::String),
                    },
                ],
            }));
            assert_eq!(
                rust_type_base(&ty),
                "Push<::std::result::Result<::std::vec::Vec<u8>, ::std::string::String>>"
            );
        }

        #[test]
        fn tuple_of_mixed_types() {
            let ty = TypeDetail::Tuple(vec![
                TypeDetail::U32,
                TypeDetail::Option(Box::new(TypeDetail::String)),
                TypeDetail::Struct {
                    name: Some("Point".to_string()),
                    fields: vec![],
                },
            ]);
            assert_eq!(
                rust_type_base(&ty),
                "(u32, ::std::option::Option<::std::string::String>, super::Point)"
            );
        }
    }

    // ===========================================
    // Client/Server type perspective tests
    // ===========================================

    mod client_server_perspectives {
        use super::*;

        #[test]
        fn push_client_arg_stays_push() {
            let ty = TypeDetail::Push(Box::new(TypeDetail::String));
            assert_eq!(rust_type_client_arg(&ty), "Push<::std::string::String>");
        }

        #[test]
        fn push_server_arg_becomes_pull() {
            let ty = TypeDetail::Push(Box::new(TypeDetail::String));
            assert_eq!(rust_type_server_arg(&ty), "Pull<::std::string::String>");
        }

        #[test]
        fn pull_client_arg_stays_pull() {
            let ty = TypeDetail::Pull(Box::new(TypeDetail::U32));
            assert_eq!(rust_type_client_arg(&ty), "Pull<u32>");
        }

        #[test]
        fn pull_server_arg_becomes_push() {
            let ty = TypeDetail::Pull(Box::new(TypeDetail::U32));
            assert_eq!(rust_type_server_arg(&ty), "Push<u32>");
        }

        #[test]
        fn non_stream_unchanged_client() {
            let ty = TypeDetail::String;
            assert_eq!(rust_type_client_arg(&ty), "::std::string::String");
        }

        #[test]
        fn non_stream_unchanged_server() {
            let ty = TypeDetail::String;
            assert_eq!(rust_type_server_arg(&ty), "::std::string::String");
        }
    }

    // ===========================================
    // Service generation tests
    // ===========================================

    fn sample_service() -> ServiceDetail {
        ServiceDetail {
            name: "Calculator".into(),
            doc: Some("A simple calculator service.".into()),
            methods: vec![MethodDetail {
                service_name: "Calculator".into(),
                method_name: "add".into(),
                args: vec![
                    ArgDetail {
                        name: "a".into(),
                        type_info: TypeDetail::I32,
                    },
                    ArgDetail {
                        name: "b".into(),
                        type_info: TypeDetail::I32,
                    },
                ],
                return_type: TypeDetail::I32,
                doc: Some("Add two numbers.".into()),
            }],
        }
    }

    #[test]
    fn test_generate_service() {
        let service = sample_service();
        let code = generate_service(&service);

        assert!(code.contains("pub trait CalculatorCaller"));
        assert!(code.contains("pub trait CalculatorHandler"));
        assert!(code.contains("pub struct CalculatorDispatcher"));
        assert!(code.contains("fn add("));
        assert!(code.contains("pub mod method_id"));
        assert!(code.contains("pub const ADD: u64"));
    }

    #[test]
    fn test_streaming_types() {
        // Push<T> in service definition: caller sends, handler receives
        let push_ty = TypeDetail::Push(Box::new(TypeDetail::String));
        assert_eq!(
            rust_type_client_arg(&push_ty),
            "Push<::std::string::String>"
        );
        assert_eq!(
            rust_type_server_arg(&push_ty),
            "Pull<::std::string::String>"
        );

        // Pull<T> in service definition: handler sends, caller receives
        let pull_ty = TypeDetail::Pull(Box::new(TypeDetail::U32));
        assert_eq!(rust_type_client_arg(&pull_ty), "Pull<u32>");
        assert_eq!(rust_type_server_arg(&pull_ty), "Push<u32>");
    }

    #[test]
    fn test_multiline_doc_comments() {
        let service = ServiceDetail {
            name: "MultiDoc".into(),
            doc: Some("First line.\nSecond line.\nThird line.".into()),
            methods: vec![MethodDetail {
                service_name: "MultiDoc".into(),
                method_name: "test_method".into(),
                args: vec![],
                return_type: TypeDetail::Unit,
                doc: Some("Method first line.\nMethod second line.".into()),
            }],
        };

        let code = generate_service(&service);

        // Verify each line has its own /// prefix
        assert!(
            code.contains("/// First line.\n/// Second line.\n/// Third line.\n"),
            "Service doc should have /// on each line"
        );
        assert!(
            code.contains("/// Handler for: First line.\n/// Second line.\n/// Third line.\n"),
            "Handler doc should have /// on each line with prefix on first"
        );
        // Method docs are indented (inside trait) - codegen handles indentation
        assert!(
            code.contains("    /// Method first line.\n    /// Method second line.\n"),
            "Method doc should have /// on each line (indented)"
        );
    }
}
