//! Rust code generation for roam services.
//!
//! Generates caller traits and handler dispatchers from ServiceDetail.
//! Intended for use in build.rs scripts.
//!
//! TODO: Switch from `push_str` to something that handles indentation properly

use heck::{ToSnakeCase, ToUpperCamelCase};
use roam_schema::{MethodDetail, ServiceDetail, TypeDetail};

use crate::render::hex_u64;

/// Generate a complete Rust module for a service.
///
/// r[impl codegen.rust.service] - Generate client, server, and method IDs.
pub fn generate_service(service: &ServiceDetail) -> String {
    let mut out = String::new();
    out.push_str("// @generated by roam-codegen\n");
    out.push_str("// DO NOT EDIT - regenerate with build.rs\n\n");

    // Imports (with allow to suppress warnings when not all are used)
    out.push_str("#[allow(unused_imports)]\n");
    out.push_str("use ::roam::session::{Push, Pull, StreamId};\n");
    out.push_str("#[allow(unused_imports)]\n");
    out.push_str("use ::roam::__private::facet_postcard;\n\n");

    // Generate method IDs
    out.push_str(&generate_method_ids(service));

    // Generate caller trait (for making calls)
    out.push_str(&generate_caller_trait(service));

    // Generate handler trait and dispatcher (for handling calls)
    out.push_str(&generate_handler_trait(service));
    out.push_str(&generate_dispatcher(service));

    out
}

/// Generate method ID constants.
fn generate_method_ids(service: &ServiceDetail) -> String {
    let mut out = String::new();
    out.push_str("/// Method IDs for this service.\n");
    out.push_str("pub mod method_id {\n");

    for method in &service.methods {
        let id = crate::method_id(method);
        let const_name = method.method_name.to_snake_case().to_uppercase();
        out.push_str(&format!(
            "    pub const {const_name}: u64 = {};\n",
            hex_u64(id)
        ));
    }

    out.push_str("}\n\n");
    out
}

/// Generate caller trait (for making calls to the service).
///
/// r[impl streaming.caller-pov] - Caller uses Push for args, Pull for returns.
fn generate_caller_trait(service: &ServiceDetail) -> String {
    let mut out = String::new();
    let trait_name = format!("{}Caller", service.name.to_upper_camel_case());

    if let Some(doc) = &service.doc {
        out.push_str(&format!("/// {}\n", doc));
    }
    out.push_str(&format!("pub trait {trait_name} {{\n"));

    for method in &service.methods {
        let method_name = method.method_name.to_snake_case();

        // Build argument list with streaming types for caller perspective
        let args = method
            .args
            .iter()
            .map(|a| {
                let ty = rust_type_client_arg(&a.type_info);
                format!("{}: {}", a.name.to_snake_case(), ty)
            })
            .collect::<Vec<_>>()
            .join(", ");

        // Return type from caller perspective
        let ret_ty = rust_type_client_return(&method.return_type);

        if let Some(doc) = &method.doc {
            out.push_str(&format!("    /// {}\n", doc));
        }
        out.push_str(&format!(
            "    fn {method_name}(&self, {args}) -> impl ::std::future::Future<Output = ::std::result::Result<{ret_ty}, ::std::boxed::Box<dyn ::std::error::Error + Send + Sync>>> + Send;\n"
        ));
    }

    out.push_str("}\n\n");
    out
}

/// Generate handler trait (for handling incoming calls).
///
/// r[impl streaming.caller-pov] - Handler uses Pull for args, Push for returns.
fn generate_handler_trait(service: &ServiceDetail) -> String {
    let mut out = String::new();
    let trait_name = format!("{}Handler", service.name.to_upper_camel_case());

    if let Some(doc) = &service.doc {
        out.push_str(&format!("/// Handler for: {}\n", doc));
    } else {
        out.push_str("/// Handler trait for incoming calls.\n");
    }
    out.push_str(&format!("pub trait {trait_name}: Send + Sync {{\n"));

    for method in &service.methods {
        let method_name = method.method_name.to_snake_case();

        // Build argument list with streaming types for callee perspective
        let args = method
            .args
            .iter()
            .map(|a| {
                let ty = rust_type_server_arg(&a.type_info);
                format!("{}: {}", a.name.to_snake_case(), ty)
            })
            .collect::<Vec<_>>()
            .join(", ");

        // Return type from callee perspective
        let ret_ty = rust_type_server_return(&method.return_type);

        if let Some(doc) = &method.doc {
            out.push_str(&format!("    /// {}\n", doc));
        }
        out.push_str(&format!(
            "    fn {method_name}(&self, {args}) -> impl ::std::future::Future<Output = ::std::result::Result<{ret_ty}, ::std::boxed::Box<dyn ::std::error::Error + Send + Sync>>> + Send;\n"
        ));
    }

    out.push_str("}\n\n");
    out
}

/// Generate dispatcher implementation.
///
/// r[impl core.call] - Route requests to appropriate method handlers.
fn generate_dispatcher(service: &ServiceDetail) -> String {
    let mut out = String::new();
    let service_name = service.name.to_upper_camel_case();
    let handler_trait = format!("{service_name}Handler");

    out.push_str(&format!("/// Dispatcher for {service_name} service.\n"));
    out.push_str(&format!("pub struct {service_name}Dispatcher<S> {{\n"));
    out.push_str("    service: S,\n");
    out.push_str("}\n\n");

    out.push_str(&format!("impl<S> {service_name}Dispatcher<S> {{\n"));
    out.push_str("    pub fn new(service: S) -> Self {\n");
    out.push_str("        Self { service }\n");
    out.push_str("    }\n");
    out.push_str("}\n\n");

    // Implement ServiceDispatcher trait
    out.push_str(&format!(
        "impl<S: {handler_trait}> ::roam_tcp::ServiceDispatcher for {service_name}Dispatcher<S> {{\n"
    ));

    // Generate is_streaming() method
    out.push_str(&generate_is_streaming(service));

    // Generate dispatch_unary() method
    out.push_str(&generate_dispatch_unary(service));

    // Generate dispatch_streaming() method
    out.push_str(&generate_dispatch_streaming(service));

    out.push_str("}\n");

    out
}

/// Generate is_streaming() method.
fn generate_is_streaming(service: &ServiceDetail) -> String {
    let mut out = String::new();
    out.push_str("    fn is_streaming(&self, method_id: u64) -> bool {\n");
    out.push_str("        matches!(method_id, ");

    let streaming_ids: Vec<String> = service
        .methods
        .iter()
        .filter(|m| m.args.iter().any(|a| is_stream(&a.type_info)) || is_stream(&m.return_type))
        .map(|m| hex_u64(crate::method_id(m)))
        .collect();

    if streaming_ids.is_empty() {
        out.push_str("_ if false => true"); // Never matches, but type-checks
    } else {
        out.push_str(&streaming_ids.join(" | "));
    }

    out.push_str(")\n");
    out.push_str("    }\n\n");
    out
}

/// Generate dispatch_unary() method.
fn generate_dispatch_unary(service: &ServiceDetail) -> String {
    let mut out = String::new();
    out.push_str("    fn dispatch_unary(\n");
    out.push_str("        &self,\n");
    out.push_str("        method_id: u64,\n");
    out.push_str("        payload: &[u8],\n");
    out.push_str("    ) -> impl ::std::future::Future<Output = ::std::result::Result<::std::vec::Vec<u8>, ::std::string::String>> + Send {\n");
    out.push_str("        // Copy payload to avoid lifetime issues in async block\n");
    out.push_str("        let payload = payload.to_vec();\n");
    out.push_str("        async move {\n");
    out.push_str("            match method_id {\n");

    for method in &service.methods {
        let id = crate::method_id(method);
        let has_streaming =
            method.args.iter().any(|a| is_stream(&a.type_info)) || is_stream(&method.return_type);

        if has_streaming {
            // Streaming methods handled by dispatch_streaming
            continue;
        }

        out.push_str(&format!("                {} => {{\n", hex_u64(id)));
        out.push_str(&generate_unary_dispatch_body(method));
        out.push_str("                }\n");
    }

    out.push_str(
        "                _ => Err(format!(\"unknown or streaming method: {method_id}\")),\n",
    );
    out.push_str("            }\n");
    out.push_str("        }\n");
    out.push_str("    }\n\n");
    out
}

/// Generate dispatch_streaming() method.
fn generate_dispatch_streaming(service: &ServiceDetail) -> String {
    let mut out = String::new();

    // Use explicit return type with trait object to allow different async blocks.
    // The '_ lifetime allows the future to borrow from &self.
    let ret_type = "::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::vec::Vec<u8>, ::std::string::String>> + Send + '_>>";

    out.push_str("    fn dispatch_streaming(\n");
    out.push_str("        &self,\n");
    out.push_str("        method_id: u64,\n");
    out.push_str("        payload: &[u8],\n");
    out.push_str("        registry: &mut ::roam_tcp::StreamRegistry,\n");
    out.push_str(&format!("    ) -> {ret_type} {{\n"));
    out.push_str("        // Copy payload to avoid lifetime issues in async block\n");
    out.push_str("        let payload = payload.to_vec();\n\n");

    // Collect streaming methods - we need to create stream handles synchronously
    // before the async block since registry is borrowed mutably
    let streaming_methods: Vec<_> = service
        .methods
        .iter()
        .filter(|m| m.args.iter().any(|a| is_stream(&a.type_info)) || is_stream(&m.return_type))
        .collect();

    if streaming_methods.is_empty() {
        out.push_str("        ::std::boxed::Box::pin(async move {\n");
        out.push_str("            Err(format!(\"no streaming methods: {method_id}\"))\n");
        out.push_str("        })\n");
    } else {
        // Each streaming method has different handle types, so we can't share a common
        // setup_result type. Instead, handle each method entirely in its own match arm,
        // set up handles synchronously, then return a boxed future.
        out.push_str(
            "        // Each streaming method sets up handles and returns a boxed future\n",
        );
        out.push_str("        match method_id {\n");

        for method in &streaming_methods {
            let id = crate::method_id(method);
            let method_name = method.method_name.to_snake_case();
            out.push_str(&format!("            {} => {{\n", hex_u64(id)));
            out.push_str(&format!("                // Setup for {method_name}\n"));
            out.push_str(&generate_streaming_setup_and_dispatch(method));
            out.push_str("            }\n");
        }

        out.push_str("            _ => ::std::boxed::Box::pin(async move {\n");
        out.push_str("                Err(format!(\"unknown streaming method: {method_id}\"))\n");
        out.push_str("            }),\n");
        out.push_str("        }\n");
    }

    out.push_str("    }\n");
    out
}

/// Generate combined streaming setup and dispatch for a single method.
///
/// Sets up handles synchronously, then returns a boxed async block that calls the handler.
fn generate_streaming_setup_and_dispatch(method: &MethodDetail) -> String {
    let mut out = String::new();
    let method_name = method.method_name.to_snake_case();

    // Build the wire type (streaming args are u64 on the wire)
    let wire_types: Vec<String> = method
        .args
        .iter()
        .map(|a| {
            if is_stream(&a.type_info) {
                "StreamId".into()
            } else {
                rust_type_server_arg(&a.type_info)
            }
        })
        .collect();

    // Decode and set up handles
    if method.args.is_empty() {
        // No arguments - just call the method
    } else if method.args.len() == 1 {
        let arg = &method.args[0];
        let arg_name = arg.name.to_snake_case();

        if is_stream(&arg.type_info) {
            out.push_str(&format!(
                "                let {arg_name}_id: StreamId = match facet_postcard::from_slice(&payload) {{\n"
            ));
            out.push_str("                    Ok(id) => id,\n");
            out.push_str(
                "                    Err(e) => return ::std::boxed::Box::pin(async move { Err(format!(\"decode error: {e}\")) }),\n"
            );
            out.push_str("                };\n");

            // Register stream based on direction
            out.push_str(&generate_stream_handle_creation_inline(
                &arg_name,
                &arg.type_info,
            ));
        } else {
            out.push_str(&format!(
                "                let {arg_name}: {} = match facet_postcard::from_slice(&payload) {{\n",
                wire_types[0]
            ));
            out.push_str("                    Ok(v) => v,\n");
            out.push_str("                    Err(e) => return ::std::boxed::Box::pin(async move { Err(format!(\"decode error: {e}\")) }),\n");
            out.push_str("                };\n");
        }
    } else {
        // Multiple arguments - decode as tuple
        let tuple_ty = format!("({})", wire_types.join(", "));
        out.push_str(&format!(
            "                let args: {tuple_ty} = match facet_postcard::from_slice(&payload) {{\n"
        ));
        out.push_str("                    Ok(a) => a,\n");
        out.push_str("                    Err(e) => return ::std::boxed::Box::pin(async move { Err(format!(\"decode error: {e}\")) }),\n");
        out.push_str("                };\n");

        // Create handles for each streaming arg, pass through non-streaming args
        for (i, arg) in method.args.iter().enumerate() {
            let arg_name = arg.name.to_snake_case();
            if is_stream(&arg.type_info) {
                out.push_str(&format!(
                    "                let {arg_name}_id: StreamId = args.{i};\n"
                ));
                out.push_str(&generate_stream_handle_creation_inline(
                    &arg_name,
                    &arg.type_info,
                ));
            } else {
                out.push_str(&format!("                let {arg_name} = args.{i};\n"));
            }
        }
    }

    // Now generate the async block
    let arg_names: Vec<String> = method.args.iter().map(|a| a.name.to_snake_case()).collect();
    let call_args = arg_names.join(", ");

    out.push_str("                ::std::boxed::Box::pin(async move {\n");

    // For unit return types, don't bind to a variable (clippy: let_unit_value)
    if method.return_type == TypeDetail::Unit {
        out.push_str(&format!(
            "                    self.service.{method_name}({call_args}).await\n"
        ));
        out.push_str("                        .map_err(|e| format!(\"method error: {e}\"))?;\n");
        out.push_str("                    facet_postcard::to_vec(&())\n");
    } else {
        out.push_str(&format!(
            "                    let result = self.service.{method_name}({call_args}).await\n"
        ));
        out.push_str("                        .map_err(|e| format!(\"method error: {e}\"))?;\n");
        out.push_str("                    facet_postcard::to_vec(&result)\n");
    }
    out.push_str("                        .map_err(|e| format!(\"encode error: {e}\"))\n");
    out.push_str("                })\n");

    out
}

/// Generate stream handle creation code (inline version without extra indentation).
fn generate_stream_handle_creation_inline(arg_name: &str, ty: &TypeDetail) -> String {
    let mut out = String::new();

    match ty {
        TypeDetail::Push(inner) => {
            // Caller sends → Handler receives via Pull
            let inner_ty = rust_type_base(inner);
            out.push_str(&format!(
                "                let {arg_name}_rx = registry.register_incoming({arg_name}_id);\n"
            ));
            out.push_str(&format!(
                "                let {arg_name}: Pull<{inner_ty}> = Pull::new({arg_name}_id, {arg_name}_rx);\n"
            ));
        }
        TypeDetail::Pull(inner) => {
            // Caller receives → Handler sends via Push
            let inner_ty = rust_type_base(inner);
            out.push_str(&format!(
                "                let {arg_name}_sender = registry.register_outgoing({arg_name}_id);\n"
            ));
            out.push_str(&format!(
                "                let {arg_name}: Push<{inner_ty}> = Push::new({arg_name}_sender);\n"
            ));
        }
        _ => {}
    }

    out
}

/// Generate dispatch body for a unary method.
fn generate_unary_dispatch_body(method: &MethodDetail) -> String {
    let mut out = String::new();
    let method_name = method.method_name.to_snake_case();

    // Decode arguments
    if method.args.is_empty() {
        // No arguments to decode
    } else if method.args.len() == 1 {
        let arg = &method.args[0];
        let arg_name = arg.name.to_snake_case();
        let arg_ty = rust_type_server_arg(&arg.type_info);
        out.push_str(&format!(
            "                    let {arg_name}: {arg_ty} = facet_postcard::from_slice(&payload)\n"
        ));
        out.push_str("                        .map_err(|e| format!(\"decode error: {e}\"))?;\n");
    } else {
        // Multiple arguments - decode as tuple
        let arg_types: Vec<String> = method
            .args
            .iter()
            .map(|a| rust_type_server_arg(&a.type_info))
            .collect();
        let tuple_ty = format!("({})", arg_types.join(", "));
        out.push_str(&format!(
            "                    let args: {tuple_ty} = facet_postcard::from_slice(&payload)\n"
        ));
        out.push_str("                        .map_err(|e| format!(\"decode error: {e}\"))?;\n");

        // Unpack tuple into named variables
        for (i, arg) in method.args.iter().enumerate() {
            let arg_name = arg.name.to_snake_case();
            out.push_str(&format!("                    let {arg_name} = args.{i};\n"));
        }
    }

    // Call the method
    let arg_names: Vec<String> = method.args.iter().map(|a| a.name.to_snake_case()).collect();
    let call_args = arg_names.join(", ");

    // For unit return types, don't bind to a variable (clippy: let_unit_value)
    if method.return_type == TypeDetail::Unit {
        out.push_str(&format!(
            "                    self.service.{method_name}({call_args}).await\n"
        ));
        out.push_str("                        .map_err(|e| format!(\"method error: {e}\"))?;\n");
        out.push_str("                    facet_postcard::to_vec(&())\n");
    } else {
        out.push_str(&format!(
            "                    let result = self.service.{method_name}({call_args}).await\n"
        ));
        out.push_str("                        .map_err(|e| format!(\"method error: {e}\"))?;\n");
        out.push_str("                    facet_postcard::to_vec(&result)\n");
    }
    out.push_str("                        .map_err(|e| format!(\"encode error: {e}\"))\n");

    out
}

/// Check if a type is a stream (Push or Pull).
fn is_stream(ty: &TypeDetail) -> bool {
    matches!(ty, TypeDetail::Push(_) | TypeDetail::Pull(_))
}

/// Convert TypeDetail to Rust type string for client arguments.
/// Push<T> stays Push<T> (client sends), Pull<T> stays Pull<T> (client receives).
fn rust_type_client_arg(ty: &TypeDetail) -> String {
    match ty {
        TypeDetail::Push(inner) => format!("Push<{}>", rust_type_base(inner)),
        TypeDetail::Pull(inner) => format!("Pull<{}>", rust_type_base(inner)),
        _ => rust_type_base(ty),
    }
}

/// Convert TypeDetail to Rust type string for client returns.
/// Streams should not appear in return types per spec r[core.stream.return-forbidden].
fn rust_type_client_return(ty: &TypeDetail) -> String {
    rust_type_base(ty)
}

/// Convert TypeDetail to Rust type string for server arguments.
/// Push<T> becomes Pull<T> (server receives what client pushes).
/// Pull<T> becomes Push<T> (server sends what client pulls).
fn rust_type_server_arg(ty: &TypeDetail) -> String {
    match ty {
        TypeDetail::Push(inner) => format!("Pull<{}>", rust_type_base(inner)),
        TypeDetail::Pull(inner) => format!("Push<{}>", rust_type_base(inner)),
        _ => rust_type_base(ty),
    }
}

/// Convert TypeDetail to Rust type string for server returns.
/// Streams should not appear in return types per spec r[core.stream.return-forbidden].
fn rust_type_server_return(ty: &TypeDetail) -> String {
    rust_type_base(ty)
}

/// Convert TypeDetail to base Rust type (non-streaming).
fn rust_type_base(ty: &TypeDetail) -> String {
    match ty {
        TypeDetail::Bool => "bool".into(),
        TypeDetail::U8 => "u8".into(),
        TypeDetail::U16 => "u16".into(),
        TypeDetail::U32 => "u32".into(),
        TypeDetail::U64 => "u64".into(),
        TypeDetail::U128 => "u128".into(),
        TypeDetail::I8 => "i8".into(),
        TypeDetail::I16 => "i16".into(),
        TypeDetail::I32 => "i32".into(),
        TypeDetail::I64 => "i64".into(),
        TypeDetail::I128 => "i128".into(),
        TypeDetail::F32 => "f32".into(),
        TypeDetail::F64 => "f64".into(),
        TypeDetail::Char => "char".into(),
        TypeDetail::String => "::std::string::String".into(),
        TypeDetail::Unit => "()".into(),
        TypeDetail::Bytes => "::std::vec::Vec<u8>".into(),
        TypeDetail::List(inner) => format!("::std::vec::Vec<{}>", rust_type_base(inner)),
        TypeDetail::Option(inner) => format!("::std::option::Option<{}>", rust_type_base(inner)),
        TypeDetail::Array { element, len } => format!("[{}; {}]", rust_type_base(element), len),
        TypeDetail::Map { key, value } => {
            format!(
                "::std::collections::HashMap<{}, {}>",
                rust_type_base(key),
                rust_type_base(value)
            )
        }
        TypeDetail::Set(inner) => {
            format!("::std::collections::HashSet<{}>", rust_type_base(inner))
        }
        TypeDetail::Tuple(items) => {
            let inner = items
                .iter()
                .map(rust_type_base)
                .collect::<Vec<_>>()
                .join(", ");
            format!("({inner})")
        }
        TypeDetail::Push(inner) => {
            // Should be handled by caller-specific functions, but fallback
            format!("Push<{}>", rust_type_base(inner))
        }
        TypeDetail::Pull(inner) => {
            // Should be handled by caller-specific functions, but fallback
            format!("Pull<{}>", rust_type_base(inner))
        }
        TypeDetail::Struct { fields } => {
            // Anonymous struct - represent as tuple for now
            // In practice, these would have named types
            let inner = fields
                .iter()
                .map(|f| rust_type_base(&f.type_info))
                .collect::<Vec<_>>()
                .join(", ");
            format!("({inner})")
        }
        TypeDetail::Enum { variants: _ } => {
            // Anonymous enum - would need named type in practice
            "/* enum */".into()
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use roam_schema::{ArgDetail, MethodDetail, ServiceDetail, TypeDetail};

    fn sample_service() -> ServiceDetail {
        ServiceDetail {
            name: "Calculator".into(),
            doc: Some("A simple calculator service.".into()),
            methods: vec![MethodDetail {
                service_name: "Calculator".into(),
                method_name: "add".into(),
                args: vec![
                    ArgDetail {
                        name: "a".into(),
                        type_info: TypeDetail::I32,
                    },
                    ArgDetail {
                        name: "b".into(),
                        type_info: TypeDetail::I32,
                    },
                ],
                return_type: TypeDetail::I32,
                doc: Some("Add two numbers.".into()),
            }],
        }
    }

    #[test]
    fn test_generate_service() {
        let service = sample_service();
        let code = generate_service(&service);

        assert!(code.contains("pub trait CalculatorCaller"));
        assert!(code.contains("pub trait CalculatorHandler"));
        assert!(code.contains("pub struct CalculatorDispatcher"));
        assert!(code.contains("fn add("));
        assert!(code.contains("pub mod method_id"));
        assert!(code.contains("pub const ADD: u64"));
    }

    #[test]
    fn test_streaming_types() {
        // Push<T> in service definition: caller sends, handler receives
        let push_ty = TypeDetail::Push(Box::new(TypeDetail::String));
        assert_eq!(
            rust_type_client_arg(&push_ty),
            "Push<::std::string::String>"
        );
        assert_eq!(
            rust_type_server_arg(&push_ty),
            "Pull<::std::string::String>"
        );

        // Pull<T> in service definition: handler sends, caller receives
        let pull_ty = TypeDetail::Pull(Box::new(TypeDetail::U32));
        assert_eq!(rust_type_client_arg(&pull_ty), "Pull<u32>");
        assert_eq!(rust_type_server_arg(&pull_ty), "Push<u32>");
    }
}
