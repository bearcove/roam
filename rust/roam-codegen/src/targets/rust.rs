//! Rust code generation for roam services.
//!
//! Generates caller traits and handler dispatchers from ServiceDetail.
//! Intended for use in build.rs scripts.

use codegen::{Block, Impl, Scope};
use facet_core::{ScalarType, Shape};
use heck::{ToSnakeCase, ToUpperCamelCase};
use roam_schema::{
    EnumInfo, MethodDetail, ServiceDetail, ShapeKind, StructInfo, VariantKind, classify_shape,
    classify_variant, is_bytes, is_rx, is_tx,
};

/// Extract the Ok and Err types from a Result<T, E> shape.
/// Returns (ok_type, Some(err_type)) for Result, or (shape, None) for non-Result types.
fn extract_result_types(shape: &'static Shape) -> (&'static Shape, Option<&'static Shape>) {
    if let ShapeKind::Enum(EnumInfo {
        name: None,
        variants,
    }) = classify_shape(shape)
    {
        if variants.len() == 2 {
            let ok_variant = variants.iter().find(|v| v.name == "Ok");
            let err_variant = variants.iter().find(|v| v.name == "Err");

            if let (Some(ok_v), Some(err_v)) = (ok_variant, err_variant) {
                if let (
                    VariantKind::Newtype { inner: ok_ty },
                    VariantKind::Newtype { inner: err_ty },
                ) = (classify_variant(ok_v), classify_variant(err_v))
                {
                    return (ok_ty, Some(err_ty));
                }
            }
        }
    }
    (shape, None)
}

/// Format the return type for caller trait methods.
/// Returns CallResult<T, E> where E is the user error type (or Never for infallible methods).
fn format_caller_return_type(return_shape: &'static Shape) -> String {
    let (ok_ty, err_ty) = extract_result_types(return_shape);
    let ok_type_str = rust_type_client_return(ok_ty);
    let err_type_str = err_ty
        .map(|e| rust_type_base(e))
        .unwrap_or_else(|| "Never".to_string());
    format!("CallResult<{ok_type_str}, {err_type_str}>")
}

/// Format the return type for handler trait methods.
/// Returns Result<T, RoamError<E>> where E is the user error type (or Never for infallible methods).
fn format_handler_return_type(return_shape: &'static Shape) -> String {
    let (ok_ty, err_ty) = extract_result_types(return_shape);
    let ok_type_str = rust_type_server_return(ok_ty);
    let err_type_str = err_ty
        .map(|e| rust_type_base(e))
        .unwrap_or_else(|| "Never".to_string());
    format!("Result<{ok_type_str}, RoamError<{err_type_str}>>")
}

use crate::render::hex_u64;

/// Options for Rust code generation.
#[derive(Debug, Clone, Default)]
pub struct RustCodegenOptions {
    /// Generate tracing spans and events for RPC calls.
    ///
    /// When enabled, each method dispatch will be wrapped in a `tracing::debug_span!`
    /// with the service and method name. Events are emitted for request/response sizes.
    ///
    /// Requires the `tracing` crate in the consuming crate.
    pub tracing: bool,
}

/// Generator for Rust code from service definitions.
struct RustGenerator<'a> {
    service: &'a ServiceDetail,
    options: &'a RustCodegenOptions,
    scope: Scope,
}

impl<'a> RustGenerator<'a> {
    fn new(service: &'a ServiceDetail, options: &'a RustCodegenOptions) -> Self {
        Self {
            service,
            options,
            scope: Scope::new(),
        }
    }

    fn generate(mut self) -> String {
        // Header comment - only once per file (caller should only include once)
        self.scope.raw("// @generated by roam-codegen");
        self.scope
            .raw("// DO NOT EDIT - regenerate with build.rs\n");

        // Wrap in module named after the service to avoid conflicts
        // Use outer attributes to suppress clippy/unused warnings on generated code
        let mod_name = self.service.name.to_snake_case();
        self.scope.raw(format!(
            "#[allow(clippy::all, unused)]\npub mod {mod_name} {{"
        ));

        // Re-export common types for convenience
        self.scope
            .raw("    pub use ::roam::session::{Tx, Rx, StreamId, RoamError, CallResult, Never};");

        // Internal imports for codegen (with allow to suppress warnings when not all are used)
        self.scope
            .raw("    #[allow(unused_imports)]\n    use ::roam::__private::facet_postcard;");

        // Generate method IDs
        self.generate_method_ids();

        // Generate caller trait (for making calls)
        self.generate_caller_trait();

        // Generate handler trait and dispatcher (for handling calls)
        self.generate_handler_trait();
        self.generate_dispatcher();

        // Close module
        self.scope.raw("}");

        self.scope.to_string()
    }

    fn generate_method_ids(&mut self) {
        // method_id module is now scoped within the service module, so no prefix needed
        self.scope
            .raw("    /// Method IDs for this service.\n    pub mod method_id {");

        for method in &self.service.methods {
            let id = crate::method_id(method);
            let const_name = method.method_name.to_snake_case().to_uppercase();
            self.scope.raw(format!(
                "        pub const {const_name}: u64 = {};",
                hex_u64(id)
            ));
        }

        self.scope.raw("    }");
    }

    fn generate_caller_trait(&mut self) {
        let trait_name = format!("{}Caller", self.service.name.to_upper_camel_case());
        let trait_def = self.scope.new_trait(&trait_name);
        trait_def.vis("pub");

        if let Some(doc) = &self.service.doc {
            trait_def.doc(doc);
        }

        for method in &self.service.methods {
            let method_name = method.method_name.to_snake_case();
            let is_streaming =
                method.args.iter().any(|a| is_stream(a.ty)) || is_stream(method.return_type);

            // Build argument list - client perspective uses types as-is
            let args: Vec<String> = method
                .args
                .iter()
                .map(|arg| {
                    let arg_name = arg.name.to_snake_case();
                    let arg_type = rust_type_client_arg(arg.ty);
                    format!("{arg_name}: {arg_type}")
                })
                .collect();

            let _args_str = if args.is_empty() {
                "&self".to_string()
            } else {
                format!("&self, {}", args.join(", "))
            };

            // Return type - client perspective uses types as-is
            // CallResult<T, E> wraps the response in RoamError handling
            let full_return = format_caller_return_type(method.return_type);

            let fn_def = trait_def.new_fn(&method_name);
            fn_def.arg_ref_self();
            for arg in &method.args {
                let arg_name = arg.name.to_snake_case();
                let arg_type = rust_type_client_arg(arg.ty);
                fn_def.arg(&arg_name, &arg_type);
            }
            fn_def.ret(format!("impl std::future::Future<Output = {full_return}>"));

            if let Some(doc) = &method.doc {
                fn_def.doc(doc.as_ref());
            }
        }
    }

    fn generate_handler_trait(&mut self) {
        let trait_name = format!("{}Handler", self.service.name.to_upper_camel_case());
        let trait_def = self.scope.new_trait(&trait_name);
        trait_def.vis("pub");
        trait_def.bound("Self", "Send + Sync");

        // Add service doc with "Handler for:" prefix
        if let Some(doc) = &self.service.doc {
            trait_def.doc(&format!("Handler for: {doc}"));
        }

        for method in &self.service.methods {
            let method_name = method.method_name.to_snake_case();
            let _is_streaming =
                method.args.iter().any(|a| is_stream(a.ty)) || is_stream(method.return_type);

            // Build argument list - server perspective INVERTS Tx/Rx
            let args: Vec<String> = method
                .args
                .iter()
                .map(|arg| {
                    let arg_name = arg.name.to_snake_case();
                    let arg_type = rust_type_server_arg(arg.ty);
                    format!("{arg_name}: {arg_type}")
                })
                .collect();

            let _args_str = if args.is_empty() {
                "&self".to_string()
            } else {
                format!("&self, {}", args.join(", "))
            };

            // Return type - server perspective INVERTS Tx/Rx
            // Handler returns Result<T, RoamError<E>> where E is the user error type
            let full_return = format_handler_return_type(method.return_type);

            let fn_def = trait_def.new_fn(&method_name);
            fn_def.set_async(true);
            fn_def.arg_ref_self();
            for arg in &method.args {
                let arg_name = arg.name.to_snake_case();
                let arg_type = rust_type_server_arg(arg.ty);
                fn_def.arg(&arg_name, &arg_type);
            }
            fn_def.ret(&full_return);

            if let Some(doc) = &method.doc {
                fn_def.doc(doc.as_ref());
            }
        }
    }

    fn generate_dispatcher(&mut self) {
        let service_name = self.service.name.to_upper_camel_case();
        let dispatcher_name = format!("{service_name}Dispatcher");
        let handler_trait = format!("{service_name}Handler");

        // Generate the dispatcher struct
        self.scope.raw(format!(
            "\n    /// Dispatcher for {service_name} service.\n    pub struct {dispatcher_name}<H> {{\n        handler: H,\n    }}"
        ));

        // Generate impl block
        let impl_block = self.scope.new_impl(&dispatcher_name);
        impl_block.generic("H");
        impl_block
            .target_generic("H")
            .bound("H", format!("{handler_trait} + 'static"));

        // Constructor
        let new_fn = impl_block.new_fn("new");
        new_fn.vis("pub");
        new_fn.arg("handler", "H");
        new_fn.ret("Self");
        new_fn.line("Self { handler }");

        // Dispatch method
        let dispatch_fn = impl_block.new_fn("dispatch");
        dispatch_fn.vis("pub");
        dispatch_fn.set_async(true);
        dispatch_fn.arg_ref_self();
        dispatch_fn.arg("method_id", "u64");
        dispatch_fn.arg("payload", "&[u8]");
        dispatch_fn.ret("::std::vec::Vec<u8>");

        let mut dispatch_body = Block::new("match method_id");
        for method in &self.service.methods {
            let _id = crate::method_id(method);
            let method_name = method.method_name.to_snake_case();
            let const_name = method_name.to_uppercase();

            dispatch_body.line(format!(
                "method_id::{const_name} => self.dispatch_{method_name}(payload).await,"
            ));
        }
        dispatch_body.line("_ => Self::unknown_method_response(method_id),");
        dispatch_fn.push_block(dispatch_body);

        // Unknown method response helper
        let unknown_fn = impl_block.new_fn("unknown_method_response");
        unknown_fn.arg("_method_id", "u64");
        unknown_fn.ret("::std::vec::Vec<u8>");
        unknown_fn.line("// Return error response for unknown method");
        unknown_fn.line("vec![1] // Error marker");

        // Generate dispatch_<method> for each method
        for method in &self.service.methods {
            generate_dispatch_method_fn(impl_block, method, self.options);
        }

        // Generate ServiceDispatcher trait implementation
        self.generate_service_dispatcher_impl(&dispatcher_name, &handler_trait);
    }

    fn generate_service_dispatcher_impl(&mut self, dispatcher_name: &str, handler_trait: &str) {
        // Generate is_streaming method body
        let mut is_streaming_arms = Vec::new();
        for method in &self.service.methods {
            let method_name = method.method_name.to_snake_case();
            let const_name = method_name.to_uppercase();
            let is_streaming =
                method.args.iter().any(|a| is_stream(a.ty)) || is_stream(method.return_type);
            is_streaming_arms.push(format!(
                "            method_id::{const_name} => {is_streaming},"
            ));
        }
        let is_streaming_match = is_streaming_arms.join("\n");

        // Generate dispatch_unary arms
        let mut dispatch_unary_arms = Vec::new();
        for method in &self.service.methods {
            let method_name = method.method_name.to_snake_case();
            let const_name = method_name.to_uppercase();
            let is_streaming =
                method.args.iter().any(|a| is_stream(a.ty)) || is_stream(method.return_type);
            if !is_streaming {
                dispatch_unary_arms.push(format!(
                    "                method_id::{const_name} => self.dispatch_{method_name}(payload).await,"
                ));
            }
        }
        dispatch_unary_arms
            .push("                _ => Err(\"unknown method\".to_string()),".to_string());
        let dispatch_unary_match = dispatch_unary_arms.join("\n");

        // Generate the impl block as raw code (codegen crate doesn't support impl Trait for Type<G> well)
        self.scope.raw(format!(
            r#"
    impl<H> ::roam::session::ServiceDispatcher for {dispatcher_name}<H>
    where
        H: {handler_trait} + 'static,
    {{
        fn is_streaming(&self, method_id: u64) -> bool {{
            match method_id {{
{is_streaming_match}
                _ => false,
            }}
        }}

        fn dispatch_unary(
            &self,
            method_id: u64,
            payload: &[u8],
        ) -> impl std::future::Future<Output = Result<Vec<u8>, String>> + Send {{
            let payload = payload.to_vec();
            async move {{
                match method_id {{
{dispatch_unary_match}
                }}
            }}
        }}

        fn dispatch_streaming(
            &self,
            method_id: u64,
            _payload: Vec<u8>,
            _registry: &mut ::roam::session::StreamRegistry,
        ) -> std::pin::Pin<
            Box<dyn std::future::Future<Output = Result<Vec<u8>, String>> + Send + 'static>,
        > {{
            // TODO: Implement streaming dispatch
            Box::pin(async move {{
                Err(format!("streaming not yet implemented for method {{}}", method_id))
            }})
        }}
    }}"#
        ));
    }
}

/// Generate a dispatch method for a single service method.
fn generate_dispatch_method_fn(
    impl_block: &mut Impl,
    method: &MethodDetail,
    options: &RustCodegenOptions,
) {
    let method_name = method.method_name.to_snake_case();
    let dispatch_name = format!("dispatch_{method_name}");

    let is_streaming = method.args.iter().any(|a| is_stream(a.ty)) || is_stream(method.return_type);

    let dispatch_fn = impl_block.new_fn(&dispatch_name);
    dispatch_fn.set_async(true);
    dispatch_fn.arg_ref_self();
    dispatch_fn.arg("payload", "&[u8]");
    dispatch_fn.ret("::std::vec::Vec<u8>");

    if is_streaming {
        generate_dispatch_streaming(dispatch_fn, method, options);
    } else {
        generate_dispatch_unary(dispatch_fn, method, options);
    }
}

/// Generate body for non-streaming method dispatch.
fn generate_dispatch_unary(
    dispatch_fn: &mut codegen::Function,
    method: &MethodDetail,
    options: &RustCodegenOptions,
) {
    let method_name = method.method_name.to_snake_case();

    // Decode arguments
    if method.args.is_empty() {
        dispatch_fn.line("// No arguments to decode");
    } else {
        dispatch_fn.line("// Decode arguments");
        dispatch_fn.line("let mut cursor = payload;");

        for arg in &method.args {
            let arg_name = arg.name.to_snake_case();
            generate_decode_stmt(dispatch_fn, &arg_name, arg.ty);
        }
    }

    // Call handler
    let args: Vec<String> = method.args.iter().map(|a| a.name.to_snake_case()).collect();
    let args_str = args.join(", ");

    if options.tracing {
        dispatch_fn.line(format!(
            "let _span = tracing::debug_span!(\"dispatch\", method = \"{method_name}\").entered();"
        ));
    }

    dispatch_fn.line(format!(
        "match self.handler.{method_name}({args_str}).await {{"
    ));
    dispatch_fn.line("    Ok(result) => {");
    dispatch_fn.line("        let mut out = vec![0u8]; // Success marker");
    generate_encode_expr(dispatch_fn, "result", method.return_type, "        ");
    dispatch_fn.line("        out");
    dispatch_fn.line("    }");
    dispatch_fn.line("    Err(_e) => {");
    dispatch_fn.line("        // Encode RoamError - for now just return error marker");
    dispatch_fn.line("        vec![1, 1] // Result::Err, RoamError::UnknownMethod placeholder");
    dispatch_fn.line("    }");
    dispatch_fn.line("}");
}

/// Generate body for streaming method dispatch.
fn generate_dispatch_streaming(
    dispatch_fn: &mut codegen::Function,
    method: &MethodDetail,
    _options: &RustCodegenOptions,
) {
    let _method_name = method.method_name.to_snake_case();

    dispatch_fn.line("// Streaming dispatch - requires stream setup");
    dispatch_fn.line("// TODO: Implement streaming dispatch");
    dispatch_fn.line("vec![1] // Error - streaming not yet implemented");
}

/// Generate decode statement for a type.
fn generate_decode_stmt(func: &mut codegen::Function, var_name: &str, _shape: &'static Shape) {
    // Use postcard for decoding
    func.line(format!(
        "let ({var_name}, rest) = facet_postcard::from_slice(cursor).expect(\"decode {var_name}\");"
    ));
    func.line("cursor = rest;");
}

/// Generate encode expression for a type.
fn generate_encode_expr(
    func: &mut codegen::Function,
    expr: &str,
    _shape: &'static Shape,
    indent: &str,
) {
    // Use postcard for encoding
    func.line(format!(
        "{indent}out.extend(facet_postcard::to_vec(&{expr}).expect(\"encode\"));"
    ));
}

/// Generate service code with default options.
pub fn generate_service(service: &ServiceDetail) -> String {
    generate_service_with_options(service, &RustCodegenOptions::default())
}

/// Generate service code with custom options.
pub fn generate_service_with_options(
    service: &ServiceDetail,
    options: &RustCodegenOptions,
) -> String {
    RustGenerator::new(service, options).generate()
}

/// Check if a shape is a stream (Tx or Rx).
fn is_stream(shape: &'static Shape) -> bool {
    is_tx(shape) || is_rx(shape)
}

/// Convert Shape to Rust type string for client arguments.
/// Schema types are from CALLER's perspective (per spec r[streaming.caller-pov]).
/// Caller uses types as-is: Tx = caller sends, Rx = caller receives.
fn rust_type_client_arg(shape: &'static Shape) -> String {
    match classify_shape(shape) {
        ShapeKind::Tx { inner } => format!("Tx<{}>", rust_type_base(inner)),
        ShapeKind::Rx { inner } => format!("Rx<{}>", rust_type_base(inner)),
        _ => rust_type_base(shape),
    }
}

/// Convert Shape to Rust type string for client returns.
/// Schema types are from CALLER's perspective - no transformation needed.
fn rust_type_client_return(shape: &'static Shape) -> String {
    match classify_shape(shape) {
        ShapeKind::Tx { inner } => format!("Tx<{}>", rust_type_base(inner)),
        ShapeKind::Rx { inner } => format!("Rx<{}>", rust_type_base(inner)),
        _ => rust_type_base(shape),
    }
}

/// Convert Shape to Rust type string for server/handler arguments.
/// Schema types are from caller's perspective, so we INVERT for handler.
/// Caller's Tx (sends) becomes handler's Rx (receives).
/// Caller's Rx (receives) becomes handler's Tx (sends).
fn rust_type_server_arg(shape: &'static Shape) -> String {
    match classify_shape(shape) {
        ShapeKind::Tx { inner } => format!("Rx<{}>", rust_type_base(inner)),
        ShapeKind::Rx { inner } => format!("Tx<{}>", rust_type_base(inner)),
        _ => rust_type_base(shape),
    }
}

/// Convert Shape to Rust type string for server/handler returns.
/// Schema types are from caller's perspective, so we INVERT for handler.
fn rust_type_server_return(shape: &'static Shape) -> String {
    match classify_shape(shape) {
        ShapeKind::Tx { inner } => format!("Rx<{}>", rust_type_base(inner)),
        ShapeKind::Rx { inner } => format!("Tx<{}>", rust_type_base(inner)),
        _ => rust_type_base(shape),
    }
}

/// Convert Shape to base Rust type (non-streaming).
fn rust_type_base(shape: &'static Shape) -> String {
    // Check for bytes first (Vec<u8>)
    if is_bytes(shape) {
        return "::std::vec::Vec<u8>".into();
    }

    match classify_shape(shape) {
        ShapeKind::Scalar(scalar) => rust_scalar_type(scalar),
        ShapeKind::List { element } => format!("::std::vec::Vec<{}>", rust_type_base(element)),
        ShapeKind::Slice { element } => format!("&[{}]", rust_type_base(element)),
        ShapeKind::Option { inner } => {
            format!("::std::option::Option<{}>", rust_type_base(inner))
        }
        ShapeKind::Array { element, len } => format!("[{}; {}]", rust_type_base(element), len),
        ShapeKind::Map { key, value } => {
            format!(
                "::std::collections::HashMap<{}, {}>",
                rust_type_base(key),
                rust_type_base(value)
            )
        }
        ShapeKind::Set { element } => {
            format!("::std::collections::HashSet<{}>", rust_type_base(element))
        }
        ShapeKind::Tuple { elements } => {
            let inner = elements
                .iter()
                .map(|p| rust_type_base(p.shape))
                .collect::<Vec<_>>()
                .join(", ");
            format!("({inner})")
        }
        ShapeKind::Tx { inner } => {
            // Should be handled by caller-specific functions, but fallback
            format!("Tx<{}>", rust_type_base(inner))
        }
        ShapeKind::Rx { inner } => {
            // Should be handled by caller-specific functions, but fallback
            format!("Rx<{}>", rust_type_base(inner))
        }
        ShapeKind::Struct(StructInfo {
            name: Some(name),
            fields: _,
            ..
        }) => {
            // Named struct - prefix with super:: to access from within service module
            format!("super::{name}")
        }
        ShapeKind::Struct(StructInfo {
            name: None, fields, ..
        }) => {
            // Anonymous struct - represent as tuple
            let inner = fields
                .iter()
                .map(|f| rust_type_base(f.shape()))
                .collect::<Vec<_>>()
                .join(", ");
            format!("({inner})")
        }
        ShapeKind::Enum(EnumInfo {
            name: Some(name), ..
        }) => {
            // Named enum - prefix with super:: to access from within service module
            format!("super::{name}")
        }
        ShapeKind::Enum(EnumInfo {
            name: None,
            variants,
        }) => {
            // Check for Result pattern: two variants Ok(T) and Err(E)
            if variants.len() == 2 {
                let ok_variant = variants.iter().find(|v| v.name == "Ok");
                let err_variant = variants.iter().find(|v| v.name == "Err");

                if let (Some(ok_v), Some(err_v)) = (ok_variant, err_variant) {
                    if let (
                        VariantKind::Newtype { inner: ok_ty },
                        VariantKind::Newtype { inner: err_ty },
                    ) = (classify_variant(ok_v), classify_variant(err_v))
                    {
                        return format!(
                            "::std::result::Result<{}, {}>",
                            rust_type_base(ok_ty),
                            rust_type_base(err_ty)
                        );
                    }
                }
            }
            // Other anonymous enum - represent structure (shouldn't happen in practice)
            let variant_names: Vec<_> = variants.iter().map(|v| v.name).collect();
            format!("/* enum({}) */", variant_names.join("|"))
        }
        ShapeKind::Pointer { pointee } => rust_type_base(pointee),
        ShapeKind::Opaque => "/* opaque */".into(),
    }
}

/// Convert ScalarType to Rust type string.
fn rust_scalar_type(scalar: ScalarType) -> String {
    match scalar {
        ScalarType::Bool => "bool".into(),
        ScalarType::U8 => "u8".into(),
        ScalarType::U16 => "u16".into(),
        ScalarType::U32 => "u32".into(),
        ScalarType::U64 => "u64".into(),
        ScalarType::U128 => "u128".into(),
        ScalarType::USize => "usize".into(),
        ScalarType::I8 => "i8".into(),
        ScalarType::I16 => "i16".into(),
        ScalarType::I32 => "i32".into(),
        ScalarType::I64 => "i64".into(),
        ScalarType::I128 => "i128".into(),
        ScalarType::ISize => "isize".into(),
        ScalarType::F32 => "f32".into(),
        ScalarType::F64 => "f64".into(),
        ScalarType::Char => "char".into(),
        ScalarType::Str | ScalarType::CowStr => "&str".into(),
        ScalarType::String => "::std::string::String".into(),
        ScalarType::Unit => "()".into(),
        _ => "/* unknown scalar */".into(),
    }
}

#[cfg(test)]
mod tests {
    use std::borrow::Cow;

    use super::*;
    use facet::Facet;
    use roam_schema::{ArgDetail, MethodDetail, ServiceDetail};

    // ===========================================
    // rust_type_base tests for all type variants
    // ===========================================

    mod primitives {
        use super::*;

        #[test]
        fn bool_type() {
            assert_eq!(rust_type_base(<bool as Facet>::SHAPE), "bool");
        }

        #[test]
        fn unsigned_integers() {
            assert_eq!(rust_type_base(<u8 as Facet>::SHAPE), "u8");
            assert_eq!(rust_type_base(<u16 as Facet>::SHAPE), "u16");
            assert_eq!(rust_type_base(<u32 as Facet>::SHAPE), "u32");
            assert_eq!(rust_type_base(<u64 as Facet>::SHAPE), "u64");
            assert_eq!(rust_type_base(<u128 as Facet>::SHAPE), "u128");
        }

        #[test]
        fn signed_integers() {
            assert_eq!(rust_type_base(<i8 as Facet>::SHAPE), "i8");
            assert_eq!(rust_type_base(<i16 as Facet>::SHAPE), "i16");
            assert_eq!(rust_type_base(<i32 as Facet>::SHAPE), "i32");
            assert_eq!(rust_type_base(<i64 as Facet>::SHAPE), "i64");
            assert_eq!(rust_type_base(<i128 as Facet>::SHAPE), "i128");
        }

        #[test]
        fn floats() {
            assert_eq!(rust_type_base(<f32 as Facet>::SHAPE), "f32");
            assert_eq!(rust_type_base(<f64 as Facet>::SHAPE), "f64");
        }

        #[test]
        fn char_type() {
            assert_eq!(rust_type_base(<char as Facet>::SHAPE), "char");
        }

        #[test]
        fn string_type() {
            assert_eq!(
                rust_type_base(<String as Facet>::SHAPE),
                "::std::string::String"
            );
        }

        #[test]
        fn unit_type() {
            assert_eq!(rust_type_base(<() as Facet>::SHAPE), "()");
        }

        #[test]
        fn bytes_type() {
            assert_eq!(
                rust_type_base(<Vec<u8> as Facet>::SHAPE),
                "::std::vec::Vec<u8>"
            );
        }
    }

    mod containers {
        use super::*;

        #[test]
        fn list_of_primitives() {
            assert_eq!(
                rust_type_base(<Vec<i32> as Facet>::SHAPE),
                "::std::vec::Vec<i32>"
            );
        }

        #[test]
        fn list_of_strings() {
            assert_eq!(
                rust_type_base(<Vec<String> as Facet>::SHAPE),
                "::std::vec::Vec<::std::string::String>"
            );
        }

        #[test]
        fn option_of_primitive() {
            assert_eq!(
                rust_type_base(<Option<u64> as Facet>::SHAPE),
                "::std::option::Option<u64>"
            );
        }

        #[test]
        fn option_of_string() {
            assert_eq!(
                rust_type_base(<Option<String> as Facet>::SHAPE),
                "::std::option::Option<::std::string::String>"
            );
        }

        #[test]
        fn array_type() {
            assert_eq!(rust_type_base(<[u8; 32] as Facet>::SHAPE), "[u8; 32]");
        }

        #[test]
        fn map_type() {
            use std::collections::HashMap;
            assert_eq!(
                rust_type_base(<HashMap<String, i32> as Facet>::SHAPE),
                "::std::collections::HashMap<::std::string::String, i32>"
            );
        }

        #[test]
        fn set_type() {
            use std::collections::HashSet;
            assert_eq!(
                rust_type_base(<HashSet<String> as Facet>::SHAPE),
                "::std::collections::HashSet<::std::string::String>"
            );
        }

        #[test]
        fn tuple_type() {
            assert_eq!(
                rust_type_base(<(u32, String, bool) as Facet>::SHAPE),
                "(u32, ::std::string::String, bool)"
            );
        }

        #[test]
        fn empty_tuple() {
            assert_eq!(rust_type_base(<() as Facet>::SHAPE), "()");
        }

        #[test]
        fn single_element_tuple() {
            // Note: In Rust, (i32,) is a 1-tuple, but <(i32,) as Facet>::SHAPE
            // gives us a tuple type. The output format depends on facet's representation.
            assert_eq!(rust_type_base(<(i32,) as Facet>::SHAPE), "(i32)");
        }
    }

    mod composite_types {
        use super::*;

        #[derive(Facet)]
        struct MyStruct {
            x: i32,
            y: i32,
        }

        #[test]
        fn named_struct() {
            // Uses super:: because generated code is inside a module
            assert_eq!(
                rust_type_base(<MyStruct as Facet>::SHAPE),
                "super::MyStruct"
            );
        }

        #[derive(Facet)]
        enum MyEnum {
            A,
            B(i32),
        }

        #[test]
        fn named_enum() {
            // Uses super:: because generated code is inside a module
            assert_eq!(rust_type_base(<MyEnum as Facet>::SHAPE), "super::MyEnum");
        }

        #[test]
        fn result_pattern_recognized() {
            // Result<T, E> should be recognized
            assert_eq!(
                rust_type_base(<Result<String, i32> as Facet>::SHAPE),
                "::std::result::Result<::std::string::String, i32>"
            );
        }

        #[test]
        fn result_with_complex_types() {
            assert_eq!(
                rust_type_base(<Result<Vec<u8>, String> as Facet>::SHAPE),
                "::std::result::Result<::std::vec::Vec<u8>, ::std::string::String>"
            );
        }

        #[derive(Facet)]
        struct MyError {
            message: String,
        }

        #[test]
        fn result_with_named_error_type() {
            // MyError uses super:: because generated code is inside a module
            assert_eq!(
                rust_type_base(<Result<(), MyError> as Facet>::SHAPE),
                "::std::result::Result<(), super::MyError>"
            );
        }
    }

    mod nested_types {
        use super::*;

        #[test]
        fn vec_of_option() {
            assert_eq!(
                rust_type_base(<Vec<Option<i32>> as Facet>::SHAPE),
                "::std::vec::Vec<::std::option::Option<i32>>"
            );
        }

        #[test]
        fn option_of_vec() {
            assert_eq!(
                rust_type_base(<Option<Vec<String>> as Facet>::SHAPE),
                "::std::option::Option<::std::vec::Vec<::std::string::String>>"
            );
        }

        #[test]
        fn map_of_vec_to_option() {
            use std::collections::HashMap;
            assert_eq!(
                rust_type_base(<HashMap<String, Option<Vec<u8>>> as Facet>::SHAPE),
                "::std::collections::HashMap<::std::string::String, ::std::option::Option<::std::vec::Vec<u8>>>"
            );
        }

        #[derive(Facet)]
        struct Item {
            id: u32,
        }

        #[test]
        fn vec_of_named_struct() {
            assert_eq!(
                rust_type_base(<Vec<Item> as Facet>::SHAPE),
                "::std::vec::Vec<super::Item>"
            );
        }

        #[derive(Facet)]
        enum Status {
            Active,
            Inactive,
        }

        #[test]
        fn option_of_named_enum() {
            assert_eq!(
                rust_type_base(<Option<Status> as Facet>::SHAPE),
                "::std::option::Option<super::Status>"
            );
        }

        #[test]
        fn tuple_of_mixed_types() {
            #[derive(Facet)]
            struct Point {
                x: i32,
                y: i32,
            }
            assert_eq!(
                rust_type_base(<(u32, Option<String>, Point) as Facet>::SHAPE),
                "(u32, ::std::option::Option<::std::string::String>, super::Point)"
            );
        }
    }

    // ===========================================
    // Service generation tests
    // ===========================================

    fn sample_service() -> ServiceDetail {
        ServiceDetail {
            name: Cow::Borrowed("Calculator"),
            doc: Some(Cow::Borrowed("A simple calculator service.")),
            methods: vec![MethodDetail {
                service_name: Cow::Borrowed("Calculator"),
                method_name: Cow::Borrowed("add"),
                args: vec![
                    ArgDetail {
                        name: Cow::Borrowed("a"),
                        ty: <i32 as Facet>::SHAPE,
                    },
                    ArgDetail {
                        name: Cow::Borrowed("b"),
                        ty: <i32 as Facet>::SHAPE,
                    },
                ],
                return_type: <i32 as Facet>::SHAPE,
                doc: Some(Cow::Borrowed("Add two numbers.")),
            }],
        }
    }

    #[test]
    fn test_generate_service() {
        let service = sample_service();
        let code = generate_service(&service);

        assert!(code.contains("pub trait CalculatorCaller"));
        assert!(code.contains("pub trait CalculatorHandler"));
        assert!(code.contains("CalculatorDispatcher"));
        assert!(code.contains("fn add("));
        assert!(code.contains("pub mod method_id"));
        assert!(code.contains("pub const ADD: u64"));
    }

    #[test]
    fn test_multiline_doc_comments() {
        let service = ServiceDetail {
            name: Cow::Borrowed("MultiDoc"),
            doc: Some(Cow::Borrowed("First line.\nSecond line.\nThird line.")),
            methods: vec![MethodDetail {
                service_name: Cow::Borrowed("MultiDoc"),
                method_name: Cow::Borrowed("test_method"),
                args: vec![],
                return_type: <() as Facet>::SHAPE,
                doc: Some(Cow::Borrowed("Method first line.\nMethod second line.")),
            }],
        };

        let code = generate_service(&service);

        // Verify doc comments are present (exact format depends on codegen library)
        assert!(code.contains("First line"), "Service doc should be present");
        assert!(
            code.contains("Handler for:"),
            "Handler doc should have prefix"
        );
    }
}
