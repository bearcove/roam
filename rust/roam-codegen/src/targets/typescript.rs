use heck::{ToLowerCamelCase, ToUpperCamelCase};
use roam_schema::{MethodDetail, ServiceDetail, TypeDetail};

use crate::render::{fq_name, hex_u64};

pub fn generate_method_ids(methods: &[MethodDetail]) -> String {
    let mut items = methods
        .iter()
        .map(|m| (fq_name(m), crate::method_id(m)))
        .collect::<Vec<_>>();
    items.sort_by(|a, b| a.0.cmp(&b.0));

    let mut out = String::new();
    out.push_str("// @generated by roam-codegen\n");
    out.push_str("// This file defines canonical roam method IDs.\n\n");
    out.push_str("export const METHOD_ID: Record<string, bigint> = {\n");
    for (name, id) in items {
        out.push_str(&format!("  \"{name}\": {}n,\n", hex_u64(id)));
    }
    out.push_str("} as const;\n");
    out
}

/// Generate a complete TypeScript module for a service.
///
/// r[impl codegen.typescript.service] - Generate client, server, and method IDs.
pub fn generate_service(service: &ServiceDetail) -> String {
    let mut out = String::new();
    out.push_str("// @generated by roam-codegen\n");
    out.push_str("// DO NOT EDIT - regenerate with `cargo xtask codegen --typescript`\n\n");

    // Import runtime primitives from @bearcove/roam-core
    out.push_str("import type { MethodHandler } from \"@bearcove/roam-core\";\n");
    out.push_str("import { encodeResultOk, encodeResultErr, encodeInvalidPayload } from \"@bearcove/roam-core\";\n");
    out.push_str("import { encodeString, decodeString } from \"@bearcove/roam-core\";\n");

    // Check if any method uses streaming
    let has_streaming = service
        .methods
        .iter()
        .any(|m| m.args.iter().any(|a| is_stream(&a.type_info)) || is_stream(&m.return_type));

    if has_streaming {
        out.push_str("import type { Push, Pull, StreamId } from \"@bearcove/roam-core\";\n");
    }
    out.push('\n');

    // Generate method IDs
    out.push_str("export const METHOD_ID = {\n");
    for method in &service.methods {
        let id = crate::method_id(method);
        let method_name = method.method_name.to_lower_camel_case();
        out.push_str(&format!("  {method_name}: {}n,\n", hex_u64(id)));
    }
    out.push_str("} as const;\n\n");

    // Generate type aliases
    out.push_str(&generate_types(service));

    // Generate client interface
    out.push_str(&generate_client_interface(service));

    // Generate server interface and handlers
    out.push_str(&generate_server_interface(service));

    out
}

fn generate_types(service: &ServiceDetail) -> String {
    let mut out = String::new();
    out.push_str("// Type definitions\n");

    for method in &service.methods {
        let method_name = method.method_name.to_upper_camel_case();

        // Request type (tuple of args)
        if method.args.is_empty() {
            out.push_str(&format!("export type {method_name}Request = [];\n"));
        } else if method.args.len() == 1 {
            let ty = ts_type(&method.args[0].type_info);
            out.push_str(&format!("export type {method_name}Request = [{ty}];\n"));
        } else {
            out.push_str(&format!("export type {method_name}Request = [\n"));
            for arg in &method.args {
                let ty = ts_type(&arg.type_info);
                out.push_str(&format!("  {ty}, // {}\n", arg.name));
            }
            out.push_str("];\n");
        }

        // Response type
        let ret_ty = ts_type(&method.return_type);
        out.push_str(&format!(
            "export type {method_name}Response = {ret_ty};\n\n"
        ));
    }

    out
}

/// Generate client interface.
///
/// r[impl streaming.caller-pov] - Client uses Push for args, Pull for returns.
fn generate_client_interface(service: &ServiceDetail) -> String {
    let mut out = String::new();
    let service_name = service.name.to_upper_camel_case();

    out.push_str(&format!("// Client interface for {service_name}\n"));
    out.push_str(&format!("export interface {service_name}Client {{\n"));

    for method in &service.methods {
        let method_name = method.method_name.to_lower_camel_case();
        // Client args: streams become Push<T>
        let args = method
            .args
            .iter()
            .map(|a| {
                format!(
                    "{}: {}",
                    a.name.to_lower_camel_case(),
                    ts_type_client_arg(&a.type_info)
                )
            })
            .collect::<Vec<_>>()
            .join(", ");
        // Client returns: streams become Pull<T>
        let ret_ty = ts_type_client_return(&method.return_type);

        if let Some(doc) = &method.doc {
            out.push_str(&format!("  /** {} */\n", doc));
        }
        out.push_str(&format!("  {method_name}({args}): Promise<{ret_ty}>;\n"));
    }

    out.push_str("}\n\n");
    out
}

/// Generate server interface.
///
/// r[impl streaming.caller-pov] - Server uses Pull for args, Push for returns.
fn generate_server_interface(service: &ServiceDetail) -> String {
    let mut out = String::new();
    let service_name = service.name.to_upper_camel_case();

    out.push_str(&format!("// Server handler interface for {service_name}\n"));
    out.push_str(&format!("export interface {service_name}Handler {{\n"));

    for method in &service.methods {
        let method_name = method.method_name.to_lower_camel_case();
        // Server args: streams become Pull<T>
        let args = method
            .args
            .iter()
            .map(|a| {
                format!(
                    "{}: {}",
                    a.name.to_lower_camel_case(),
                    ts_type_server_arg(&a.type_info)
                )
            })
            .collect::<Vec<_>>()
            .join(", ");
        // Server returns: streams become Push<T>
        let ret_ty = ts_type_server_return(&method.return_type);

        out.push_str(&format!(
            "  {method_name}({args}): Promise<{ret_ty}> | {ret_ty};\n"
        ));
    }

    out.push_str("}\n\n");

    // Generate method handlers map
    out.push_str(&format!("// Method handlers for {service_name}\n"));
    out.push_str(&format!("export const {}_methodHandlers = new Map<bigint, MethodHandler<{service_name}Handler>>([\n", service_name.to_lower_camel_case()));

    for method in &service.methods {
        let method_name = method.method_name.to_lower_camel_case();
        let id = crate::method_id(method);

        out.push_str(&format!(
            "  [{}n, async (handler, payload) => {{\n",
            hex_u64(id)
        ));
        out.push_str("    try {\n");

        // Check if we can fully implement this method
        let can_decode_args =
            method.args.len() == 1 && matches!(method.args[0].type_info, TypeDetail::String);
        let can_encode_return = matches!(method.return_type, TypeDetail::String);

        if can_decode_args && can_encode_return {
            // Single string argument - simple case for Echo service
            out.push_str("      const decoded = decodeString(payload, 0);\n");
            out.push_str("      if (decoded.next !== payload.length) throw new Error(\"args: trailing bytes\");\n");
            let arg_name = method.args[0].name.to_lower_camel_case();
            out.push_str(&format!("      const {arg_name} = decoded.value;\n"));

            // Call handler
            let arg_names = method
                .args
                .iter()
                .map(|a| a.name.to_lower_camel_case())
                .collect::<Vec<_>>()
                .join(", ");
            out.push_str(&format!(
                "      const result = await handler.{method_name}({arg_names});\n"
            ));

            // Encode response
            out.push_str("      return encodeResultOk(encodeString(result));\n");
        } else {
            // Not yet implemented - return error
            out.push_str("      // TODO: implement encoding/decoding for complex types\n");
            out.push_str("      return encodeResultErr(encodeInvalidPayload());\n");
        }

        out.push_str("    } catch (e) {\n");
        out.push_str("      return encodeResultErr(encodeInvalidPayload());\n");
        out.push_str("    }\n");
        out.push_str("  }],\n");
    }

    out.push_str("]);\n");

    out
}

/// Check if a type is a stream.
fn is_stream(ty: &TypeDetail) -> bool {
    matches!(ty, TypeDetail::Stream(_))
}

/// Convert TypeDetail to TypeScript type (non-streaming base types).
fn ts_type_base(ty: &TypeDetail) -> String {
    match ty {
        TypeDetail::Bool => "boolean".into(),
        TypeDetail::U8
        | TypeDetail::U16
        | TypeDetail::U32
        | TypeDetail::I8
        | TypeDetail::I16
        | TypeDetail::I32
        | TypeDetail::F32
        | TypeDetail::F64 => "number".into(),
        TypeDetail::U64 | TypeDetail::U128 | TypeDetail::I64 | TypeDetail::I128 => "bigint".into(),
        TypeDetail::Char | TypeDetail::String => "string".into(),
        TypeDetail::Unit => "void".into(),
        TypeDetail::Bytes => "Uint8Array".into(),
        TypeDetail::List(inner) => format!("{}[]", ts_type_base(inner)),
        TypeDetail::Option(inner) => format!("{} | null", ts_type_base(inner)),
        TypeDetail::Array { element, len } => format!("[{}; {}]", ts_type_base(element), len),
        TypeDetail::Map { key, value } => {
            format!("Map<{}, {}>", ts_type_base(key), ts_type_base(value))
        }
        TypeDetail::Set(inner) => format!("Set<{}>", ts_type_base(inner)),
        TypeDetail::Tuple(items) => {
            let inner = items
                .iter()
                .map(ts_type_base)
                .collect::<Vec<_>>()
                .join(", ");
            format!("[{inner}]")
        }
        TypeDetail::Stream(inner) => {
            // Fallback - shouldn't reach here if called correctly
            format!("/* stream */ {}", ts_type_base(inner))
        }
        TypeDetail::Struct { fields } => {
            let inner = fields
                .iter()
                .map(|f| format!("{}: {}", f.name, ts_type_base(&f.type_info)))
                .collect::<Vec<_>>()
                .join("; ");
            format!("{{ {inner} }}")
        }
        TypeDetail::Enum { variants } => {
            // Simple union type for now
            variants
                .iter()
                .map(|v| format!("{{ tag: '{}' }}", v.name))
                .collect::<Vec<_>>()
                .join(" | ")
        }
    }
}

/// Convert TypeDetail to TypeScript type string for client arguments.
/// Streaming args become Push<T> from caller perspective.
///
/// r[impl streaming.caller-pov] - Client uses Push for args, Pull for returns.
fn ts_type_client_arg(ty: &TypeDetail) -> String {
    match ty {
        TypeDetail::Stream(inner) => format!("Push<{}>", ts_type_client_arg(inner)),
        _ => ts_type_base(ty),
    }
}

/// Convert TypeDetail to TypeScript type string for client returns.
/// Streaming returns become Pull<T> from caller perspective.
///
/// r[impl streaming.caller-pov] - Client uses Push for args, Pull for returns.
fn ts_type_client_return(ty: &TypeDetail) -> String {
    match ty {
        TypeDetail::Stream(inner) => format!("Pull<{}>", ts_type_client_return(inner)),
        _ => ts_type_base(ty),
    }
}

/// Convert TypeDetail to TypeScript type string for server arguments.
/// Streaming args become Pull<T> from callee perspective (receives what client pushes).
///
/// r[impl streaming.caller-pov] - Server uses Pull for args, Push for returns.
fn ts_type_server_arg(ty: &TypeDetail) -> String {
    match ty {
        TypeDetail::Stream(inner) => format!("Pull<{}>", ts_type_server_arg(inner)),
        _ => ts_type_base(ty),
    }
}

/// Convert TypeDetail to TypeScript type string for server returns.
/// Streaming returns become Push<T> from callee perspective (pushes what client pulls).
///
/// r[impl streaming.caller-pov] - Server uses Pull for args, Push for returns.
fn ts_type_server_return(ty: &TypeDetail) -> String {
    match ty {
        TypeDetail::Stream(inner) => format!("Push<{}>", ts_type_server_return(inner)),
        _ => ts_type_base(ty),
    }
}

/// Legacy ts_type for backward compatibility in type definitions.
fn ts_type(ty: &TypeDetail) -> String {
    ts_type_base(ty)
}
