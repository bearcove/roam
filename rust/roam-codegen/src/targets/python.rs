use heck::{ToSnakeCase, ToUpperCamelCase};
use roam_schema::{MethodDetail, ServiceDetail, TypeDetail};

use crate::render::{fq_name, hex_u64};

pub fn generate_method_ids(methods: &[MethodDetail]) -> String {
    let mut items = methods
        .iter()
        .map(|m| (fq_name(m), crate::method_id(m)))
        .collect::<Vec<_>>();
    items.sort_by(|a, b| a.0.cmp(&b.0));

    let mut out = String::new();
    out.push_str("# @generated by roam-codegen\n");
    out.push_str("# This file defines canonical roam method IDs.\n\n");
    out.push_str("METHOD_ID: dict[str, int] = {\n");
    for (name, id) in items {
        out.push_str(&format!("    \"{name}\": {},\n", hex_u64(id)));
    }
    out.push_str("}\n");
    out
}

/// Generate a complete Python module for a service.
pub fn generate_service(service: &ServiceDetail) -> String {
    let mut out = String::new();
    out.push_str("# @generated by roam-codegen\n");
    out.push_str("# DO NOT EDIT - regenerate with `cargo run -p roam-codegen`\n\n");
    out.push_str("from abc import ABC, abstractmethod\n");
    out.push_str("from typing import Protocol\n\n");

    // Generate method IDs
    out.push_str("METHOD_ID = {\n");
    for method in &service.methods {
        let id = crate::method_id(method);
        let method_name = method.method_name.to_snake_case();
        out.push_str(&format!("    \"{method_name}\": {},\n", hex_u64(id)));
    }
    out.push_str("}\n\n");

    // Generate client protocol
    out.push_str(&generate_client_protocol(service));

    // Generate server handler
    out.push_str(&generate_server_handler(service));

    out
}

fn generate_client_protocol(service: &ServiceDetail) -> String {
    let mut out = String::new();
    let service_name = service.name.to_upper_camel_case();

    if let Some(doc) = &service.doc {
        out.push_str(&format!("\"\"\"{}\"\"\"\n\n", doc));
    }

    out.push_str(&format!("class {service_name}Caller(Protocol):\n"));
    out.push_str("    \"\"\"Caller protocol for making service calls.\"\"\"\n\n");

    for method in &service.methods {
        let method_name = method.method_name.to_snake_case();
        let args = method
            .args
            .iter()
            .map(|a| format!("{}: {}", a.name.to_snake_case(), py_type(&a.type_info)))
            .collect::<Vec<_>>()
            .join(", ");
        let ret_ty = py_type(&method.return_type);

        if let Some(doc) = &method.doc {
            out.push_str(&format!(
                "    def {method_name}(self, {args}) -> {ret_ty}:\n"
            ));
            out.push_str(&format!("        \"\"\"{}\"\"\"\n", doc));
            out.push_str("        ...\n\n");
        } else {
            out.push_str(&format!(
                "    def {method_name}(self, {args}) -> {ret_ty}: ...\n\n"
            ));
        }
    }

    out
}

fn generate_server_handler(service: &ServiceDetail) -> String {
    let mut out = String::new();
    let service_name = service.name.to_upper_camel_case();

    out.push_str(&format!("class {service_name}Handler(ABC):\n"));
    out.push_str("    \"\"\"Abstract base class for implementing the service.\"\"\"\n\n");

    for method in &service.methods {
        let method_name = method.method_name.to_snake_case();
        let args = method
            .args
            .iter()
            .map(|a| format!("{}: {}", a.name.to_snake_case(), py_type(&a.type_info)))
            .collect::<Vec<_>>()
            .join(", ");
        let ret_ty = py_type(&method.return_type);

        out.push_str("    @abstractmethod\n");
        out.push_str(&format!(
            "    def {method_name}(self, {args}) -> {ret_ty}:\n"
        ));
        if let Some(doc) = &method.doc {
            out.push_str(&format!("        \"\"\"{}\"\"\"\n", doc));
        }
        out.push_str("        ...\n\n");
    }

    // Generate dispatcher
    out.push_str(&format!(
        "\ndef create_{}_dispatcher(handler: {service_name}Handler):\n",
        service.name.to_snake_case()
    ));
    out.push_str("    \"\"\"Create a dispatcher function for the service.\"\"\"\n");
    out.push_str("    def dispatch(method_id: int, payload: bytes) -> bytes:\n");
    out.push_str("        o = 0\n");
    out.push_str("        match method_id:\n");

    for method in &service.methods {
        let method_name = method.method_name.to_snake_case();
        let id = crate::method_id(method);
        out.push_str(&format!("            case {}:\n", hex_u64(id)));
        out.push_str("                try:\n");

        // Decode arguments
        for arg in &method.args {
            let arg_name = arg.name.to_snake_case();
            out.push_str(&format!(
                "                    {arg_name}, o = decode_string(payload, o)\n"
            ));
        }

        // Call handler
        let args_list = method
            .args
            .iter()
            .map(|a| a.name.to_snake_case())
            .collect::<Vec<_>>()
            .join(", ");

        out.push_str(&format!(
            "                    result = handler.{method_name}({args_list})\n"
        ));

        // Encode result
        out.push_str("                    return encode_result_ok(result, encode_string)\n");
        out.push_str("                except Exception as e:\n");
        out.push_str("                    return encode_invalid_payload_error()\n");
    }

    out.push_str("            case _:\n");
    out.push_str("                return encode_unknown_method_error()\n");
    out.push_str("    return dispatch\n\n");

    // Generate runtime helper functions
    out.push_str(&generate_runtime_helpers());

    out
}

fn py_type(ty: &TypeDetail) -> String {
    match ty {
        TypeDetail::Bool => "bool".into(),
        TypeDetail::U8 | TypeDetail::U16 | TypeDetail::U32 | TypeDetail::U64 | TypeDetail::U128 => {
            "int".into()
        }
        TypeDetail::I8 | TypeDetail::I16 | TypeDetail::I32 | TypeDetail::I64 | TypeDetail::I128 => {
            "int".into()
        }
        TypeDetail::F32 | TypeDetail::F64 => "float".into(),
        TypeDetail::Char | TypeDetail::String => "str".into(),
        TypeDetail::Unit => "None".into(),
        TypeDetail::Bytes => "bytes".into(),
        TypeDetail::List(inner) => format!("list[{}]", py_type(inner)),
        TypeDetail::Option(inner) => format!("{} | None", py_type(inner)),
        TypeDetail::Array { element, .. } => format!("list[{}]", py_type(element)),
        TypeDetail::Map { key, value } => format!("dict[{}, {}]", py_type(key), py_type(value)),
        TypeDetail::Set(inner) => format!("set[{}]", py_type(inner)),
        TypeDetail::Tuple(items) => {
            let inner = items.iter().map(py_type).collect::<Vec<_>>().join(", ");
            format!("tuple[{inner}]")
        }
        // Push: caller sends data to callee
        TypeDetail::Push(inner) => format!("AsyncGenerator[{}, None, None]", py_type(inner)),
        // Pull: callee sends data to caller
        TypeDetail::Pull(inner) => format!("AsyncIterator[{}]", py_type(inner)),
        TypeDetail::Struct { fields } => {
            // Use TypedDict for inline structs
            let inner = fields
                .iter()
                .map(|f| format!("\"{}\": {}", f.name, py_type(&f.type_info)))
                .collect::<Vec<_>>()
                .join(", ");
            format!("dict[{{{inner}}}]")
        }
        TypeDetail::Enum { .. } => {
            // Enums would need proper class generation
            "object".into()
        }
    }
}

fn generate_runtime_helpers() -> String {
    let mut out = String::new();
    out.push_str("# Runtime helper functions\n\n");

    out.push_str("def encode_varint(value: int) -> bytes:\n");
    out.push_str("    if value < 0:\n");
    out.push_str("        raise ValueError(\"negative varint\")\n");
    out.push_str("    out = bytearray()\n");
    out.push_str("    while True:\n");
    out.push_str("        byte = value & 0x7F\n");
    out.push_str("        value >>= 7\n");
    out.push_str("        if value != 0:\n");
    out.push_str("            byte |= 0x80\n");
    out.push_str("        out.append(byte)\n");
    out.push_str("        if value == 0:\n");
    out.push_str("            break\n");
    out.push_str("    return bytes(out)\n\n");

    out.push_str("def decode_varint(buf: bytes, offset: int) -> tuple[int, int]:\n");
    out.push_str("    result = 0\n");
    out.push_str("    shift = 0\n");
    out.push_str("    i = offset\n");
    out.push_str("    while True:\n");
    out.push_str("        if i >= len(buf):\n");
    out.push_str("            raise ValueError(\"varint: eof\")\n");
    out.push_str("        byte = buf[i]\n");
    out.push_str("        i += 1\n");
    out.push_str("        if shift >= 64:\n");
    out.push_str("            raise ValueError(\"varint: overflow\")\n");
    out.push_str("        result |= (byte & 0x7F) << shift\n");
    out.push_str("        if (byte & 0x80) == 0:\n");
    out.push_str("            return result, i\n");
    out.push_str("        shift += 7\n\n");

    out.push_str("def encode_string(s: str) -> bytes:\n");
    out.push_str("    b = s.encode(\"utf-8\")\n");
    out.push_str("    return encode_varint(len(b)) + b\n\n");

    out.push_str("def decode_string(buf: bytes, offset: int) -> tuple[str, int]:\n");
    out.push_str("    length, o = decode_varint(buf, offset)\n");
    out.push_str("    if o + length > len(buf):\n");
    out.push_str("        raise ValueError(\"string: length out of range\")\n");
    out.push_str("    s = buf[o:o + length].decode(\"utf-8\")\n");
    out.push_str("    return s, o + length\n\n");

    out.push_str("def encode_result_ok(value: str, encoder) -> bytes:\n");
    out.push_str("    out = encode_varint(0)  # Result::Ok\n");
    out.push_str("    out += encoder(value)\n");
    out.push_str("    return out\n\n");

    out.push_str("def encode_result_err(err: Exception) -> bytes:\n");
    out.push_str("    out = encode_varint(1)  # Result::Err\n");
    out.push_str("    out += encode_varint(0)  # RoamError::User\n");
    out.push_str("    out += encode_string(str(err))\n");
    out.push_str("    return out\n\n");

    out.push_str("def encode_unknown_method_error() -> bytes:\n");
    out.push_str("    out = encode_varint(1)  # Result::Err\n");
    out.push_str("    out += encode_varint(1)  # RoamError::UnknownMethod\n");
    out.push_str("    return out\n\n");

    out.push_str("def encode_invalid_payload_error() -> bytes:\n");
    out.push_str("    out = encode_varint(1)  # Result::Err\n");
    out.push_str("    out += encode_varint(2)  # RoamError::InvalidPayload\n");
    out.push_str("    return out\n");

    out
}
