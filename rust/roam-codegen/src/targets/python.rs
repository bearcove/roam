use facet_core::{ScalarType, Shape};
use heck::{ToSnakeCase, ToUpperCamelCase};
use roam_schema::{
    EnumInfo, MethodDetail, ServiceDetail, ShapeKind, StructInfo, classify_shape, is_bytes,
};

use crate::render::{fq_name, hex_u64};

pub fn generate_method_ids(methods: &[MethodDetail]) -> String {
    let mut items = methods
        .iter()
        .map(|m| (fq_name(m), crate::method_id(m)))
        .collect::<Vec<_>>();
    items.sort_by(|a, b| a.0.cmp(&b.0));

    let mut out = String::new();
    out.push_str("# @generated by roam-codegen\n");
    out.push_str("# This file defines canonical roam method IDs.\n\n");
    out.push_str("METHOD_ID: dict[str, int] = {\n");
    for (name, id) in items {
        out.push_str(&format!("    \"{name}\": {},\n", hex_u64(id)));
    }
    out.push_str("}\n");
    out
}

/// Generate a complete Python module for a service.
pub fn generate_service(service: &ServiceDetail) -> String {
    let mut out = String::new();
    out.push_str("# @generated by roam-codegen\n");
    out.push_str("# DO NOT EDIT - regenerate with `cargo run -p roam-codegen`\n\n");
    out.push_str("from abc import ABC, abstractmethod\n");
    out.push_str("from typing import Protocol\n\n");

    // Generate method IDs
    out.push_str("METHOD_ID = {\n");
    for method in &service.methods {
        let id = crate::method_id(method);
        let method_name = method.method_name.to_snake_case();
        out.push_str(&format!("    \"{method_name}\": {},\n", hex_u64(id)));
    }
    out.push_str("}\n\n");

    // Generate client protocol
    out.push_str(&generate_client_protocol(service));

    // Generate server handler
    out.push_str(&generate_server_handler(service));

    out
}

fn generate_client_protocol(service: &ServiceDetail) -> String {
    let mut out = String::new();
    let service_name = service.name.to_upper_camel_case();

    if let Some(doc) = &service.doc {
        out.push_str(&format!("\"\"\"{}\"\"\"\n\n", doc));
    }

    out.push_str(&format!("class {service_name}Caller(Protocol):\n"));
    out.push_str("    \"\"\"Caller protocol for making service calls.\"\"\"\n\n");

    for method in &service.methods {
        let method_name = method.method_name.to_snake_case();
        let args = method
            .args
            .iter()
            .map(|a| format!("{}: {}", a.name.to_snake_case(), py_type(a.ty)))
            .collect::<Vec<_>>()
            .join(", ");
        let ret_ty = py_type(method.return_type);

        if let Some(doc) = &method.doc {
            out.push_str(&format!(
                "    def {method_name}(self, {args}) -> {ret_ty}:\n"
            ));
            out.push_str(&format!("        \"\"\"{}\"\"\"\n", doc));
            out.push_str("        ...\n\n");
        } else {
            out.push_str(&format!(
                "    def {method_name}(self, {args}) -> {ret_ty}: ...\n\n"
            ));
        }
    }

    out
}

fn generate_server_handler(service: &ServiceDetail) -> String {
    let mut out = String::new();
    let service_name = service.name.to_upper_camel_case();

    out.push_str(&format!("class {service_name}Handler(ABC):\n"));
    out.push_str("    \"\"\"Abstract base class for implementing the service.\"\"\"\n\n");

    for method in &service.methods {
        let method_name = method.method_name.to_snake_case();
        let args = method
            .args
            .iter()
            .map(|a| format!("{}: {}", a.name.to_snake_case(), py_type(a.ty)))
            .collect::<Vec<_>>()
            .join(", ");
        let ret_ty = py_type(method.return_type);

        out.push_str("    @abstractmethod\n");
        out.push_str(&format!(
            "    def {method_name}(self, {args}) -> {ret_ty}:\n"
        ));
        if let Some(doc) = &method.doc {
            out.push_str(&format!("        \"\"\"{}\"\"\"\n", doc));
        }
        out.push_str("        ...\n\n");
    }

    // Generate dispatcher
    out.push_str(&format!(
        "\ndef create_{}_dispatcher(handler: {service_name}Handler):\n",
        service.name.to_snake_case()
    ));
    out.push_str("    \"\"\"Create a dispatcher function for the service.\"\"\"\n");
    out.push_str("    def dispatch(method_id: int, payload: bytes) -> bytes:\n");
    out.push_str("        o = 0\n");
    out.push_str("        match method_id:\n");

    for method in &service.methods {
        let method_name = method.method_name.to_snake_case();
        let id = crate::method_id(method);
        out.push_str(&format!("            case {}:\n", hex_u64(id)));
        out.push_str("                try:\n");

        // Decode arguments
        for arg in &method.args {
            let arg_name = arg.name.to_snake_case();
            out.push_str(&format!(
                "                    {arg_name}, o = decode_string(payload, o)\n"
            ));
        }

        // Call handler
        let args_list = method
            .args
            .iter()
            .map(|a| a.name.to_snake_case())
            .collect::<Vec<_>>()
            .join(", ");

        out.push_str(&format!(
            "                    result = handler.{method_name}({args_list})\n"
        ));

        // Encode result
        out.push_str("                    return encode_result_ok(result, encode_string)\n");
        out.push_str("                except Exception as e:\n");
        out.push_str("                    return encode_invalid_payload_error()\n");
    }

    out.push_str("            case _:\n");
    out.push_str("                return encode_unknown_method_error()\n");
    out.push_str("    return dispatch\n\n");

    // Generate runtime helper functions
    out.push_str(&generate_runtime_helpers());

    out
}

fn py_type(shape: &'static Shape) -> String {
    // Check for bytes first
    if is_bytes(shape) {
        return "bytes".into();
    }

    match classify_shape(shape) {
        ShapeKind::Scalar(scalar) => py_scalar_type(scalar),
        ShapeKind::List { element } => format!("list[{}]", py_type(element)),
        ShapeKind::Option { inner } => format!("{} | None", py_type(inner)),
        ShapeKind::Array { element, .. } => format!("list[{}]", py_type(element)),
        ShapeKind::Slice { element } => format!("list[{}]", py_type(element)),
        ShapeKind::Map { key, value } => format!("dict[{}, {}]", py_type(key), py_type(value)),
        ShapeKind::Set { element } => format!("set[{}]", py_type(element)),
        ShapeKind::Tuple { elements } => {
            let inner = elements
                .iter()
                .map(|p| py_type(p.shape))
                .collect::<Vec<_>>()
                .join(", ");
            if inner.is_empty() {
                "tuple[()]".into()
            } else {
                format!("tuple[{inner}]")
            }
        }
        // Tx: caller sends data to callee
        ShapeKind::Tx { inner } => format!("AsyncGenerator[{}, None, None]", py_type(inner)),
        // Rx: callee sends data to caller
        ShapeKind::Rx { inner } => format!("AsyncIterator[{}]", py_type(inner)),
        ShapeKind::Struct(StructInfo {
            name: Some(name), ..
        }) => name.to_string(),
        ShapeKind::Enum(EnumInfo {
            name: Some(name), ..
        }) => name.to_string(),
        ShapeKind::Struct(StructInfo { fields, .. }) => {
            // Use TypedDict for inline structs
            let inner = fields
                .iter()
                .map(|f| format!("\"{}\": {}", f.name, py_type(f.shape())))
                .collect::<Vec<_>>()
                .join(", ");
            format!("dict[{{{inner}}}]")
        }
        ShapeKind::Enum(_) => "object".into(),
        ShapeKind::Pointer { pointee } => py_type(pointee),
        ShapeKind::Result { ok, err } => {
            format!("Result[{}, {}]", py_type(ok), py_type(err))
        }
        ShapeKind::Opaque => "object".into(),
    }
}

fn py_scalar_type(scalar: ScalarType) -> String {
    match scalar {
        ScalarType::Bool => "bool".into(),
        ScalarType::U8
        | ScalarType::U16
        | ScalarType::U32
        | ScalarType::U64
        | ScalarType::U128
        | ScalarType::USize => "int".into(),
        ScalarType::I8
        | ScalarType::I16
        | ScalarType::I32
        | ScalarType::I64
        | ScalarType::I128
        | ScalarType::ISize => "int".into(),
        ScalarType::F32 | ScalarType::F64 => "float".into(),
        ScalarType::Char | ScalarType::Str | ScalarType::String | ScalarType::CowStr => {
            "str".into()
        }
        ScalarType::Unit => "None".into(),
        _ => "object".into(),
    }
}

fn generate_runtime_helpers() -> String {
    let mut out = String::new();
    out.push_str("# Runtime helper functions\n\n");

    out.push_str("def encode_varint(value: int) -> bytes:\n");
    out.push_str("    if value < 0:\n");
    out.push_str("        raise ValueError(\"negative varint\")\n");
    out.push_str("    out = bytearray()\n");
    out.push_str("    while True:\n");
    out.push_str("        byte = value & 0x7F\n");
    out.push_str("        value >>= 7\n");
    out.push_str("        if value != 0:\n");
    out.push_str("            byte |= 0x80\n");
    out.push_str("        out.append(byte)\n");
    out.push_str("        if value == 0:\n");
    out.push_str("            break\n");
    out.push_str("    return bytes(out)\n\n");

    out.push_str("def decode_varint(buf: bytes, offset: int) -> tuple[int, int]:\n");
    out.push_str("    result = 0\n");
    out.push_str("    shift = 0\n");
    out.push_str("    i = offset\n");
    out.push_str("    while True:\n");
    out.push_str("        if i >= len(buf):\n");
    out.push_str("            raise ValueError(\"varint: eof\")\n");
    out.push_str("        byte = buf[i]\n");
    out.push_str("        i += 1\n");
    out.push_str("        if shift >= 64:\n");
    out.push_str("            raise ValueError(\"varint: overflow\")\n");
    out.push_str("        result |= (byte & 0x7F) << shift\n");
    out.push_str("        if (byte & 0x80) == 0:\n");
    out.push_str("            return result, i\n");
    out.push_str("        shift += 7\n\n");

    out.push_str("def encode_string(s: str) -> bytes:\n");
    out.push_str("    b = s.encode(\"utf-8\")\n");
    out.push_str("    return encode_varint(len(b)) + b\n\n");

    out.push_str("def decode_string(buf: bytes, offset: int) -> tuple[str, int]:\n");
    out.push_str("    length, o = decode_varint(buf, offset)\n");
    out.push_str("    if o + length > len(buf):\n");
    out.push_str("        raise ValueError(\"string: length out of range\")\n");
    out.push_str("    s = buf[o:o + length].decode(\"utf-8\")\n");
    out.push_str("    return s, o + length\n\n");

    out.push_str("def encode_result_ok(value: str, encoder) -> bytes:\n");
    out.push_str("    out = encode_varint(0)  # Result::Ok\n");
    out.push_str("    out += encoder(value)\n");
    out.push_str("    return out\n\n");

    out.push_str("def encode_result_err(err: Exception) -> bytes:\n");
    out.push_str("    out = encode_varint(1)  # Result::Err\n");
    out.push_str("    out += encode_varint(0)  # RoamError::User\n");
    out.push_str("    out += encode_string(str(err))\n");
    out.push_str("    return out\n\n");

    out.push_str("def encode_unknown_method_error() -> bytes:\n");
    out.push_str("    out = encode_varint(1)  # Result::Err\n");
    out.push_str("    out += encode_varint(1)  # RoamError::UnknownMethod\n");
    out.push_str("    return out\n\n");

    out.push_str("def encode_invalid_payload_error() -> bytes:\n");
    out.push_str("    out = encode_varint(1)  # Result::Err\n");
    out.push_str("    out += encode_varint(2)  # RoamError::InvalidPayload\n");
    out.push_str("    return out\n");

    out
}
