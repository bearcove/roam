use heck::{ToLowerCamelCase, ToUpperCamelCase};
use roam_schema::{MethodDetail, ServiceDetail, TypeDetail};

use crate::render::{fq_name, hex_u64};

pub fn generate_method_ids(methods: &[MethodDetail]) -> String {
    let mut items = methods
        .iter()
        .map(|m| (fq_name(m), crate::method_id(m)))
        .collect::<Vec<_>>();
    items.sort_by(|a, b| a.0.cmp(&b.0));

    let mut out = String::new();
    out.push_str("// Code generated by roam-codegen. DO NOT EDIT.\n\n");
    out.push_str("import java.util.Map;\n\n");
    out.push_str("public final class RoamMethodId {\n");
    out.push_str("    private RoamMethodId() {}\n\n");
    out.push_str("    public static final Map<String, Long> BY_NAME = Map.ofEntries(\n");
    for (i, (name, id)) in items.iter().enumerate() {
        let comma = if i + 1 == items.len() { "" } else { "," };
        out.push_str(&format!(
            "        Map.entry(\"{name}\", {hex}L){comma}\n",
            hex = hex_u64(*id)
        ));
    }
    out.push_str("    );\n");
    out.push_str("}\n");
    out
}

/// Generate a complete Java file for a service.
pub fn generate_service(service: &ServiceDetail) -> String {
    let mut out = String::new();
    out.push_str("// Code generated by roam-codegen. DO NOT EDIT.\n\n");
    out.push_str("import java.io.ByteArrayOutputStream;\n");
    out.push_str("import java.io.EOFException;\n");
    out.push_str("import java.nio.charset.StandardCharsets;\n");
    out.push_str("import java.util.concurrent.CompletableFuture;\n\n");

    let service_name = service.name.to_upper_camel_case();

    // Generate method ID constants (package-private)
    out.push_str(&format!("final class {service_name}MethodId {{\n"));
    out.push_str(&format!("    private {service_name}MethodId() {{}}\n\n"));
    for method in &service.methods {
        let const_name = method.method_name.to_upper_camel_case();
        let id = crate::method_id(method);
        out.push_str(&format!(
            "    static final long {} = {}L;\n",
            const_name.to_uppercase(),
            hex_u64(id)
        ));
    }
    out.push_str("}\n\n");

    // Generate client interface
    out.push_str(&generate_client_interface(service));

    // Generate server handler interface
    out.push_str(&generate_server_handler(service));

    // Generate runtime helper functions
    out.push_str(&generate_runtime_helpers());

    out
}

fn generate_client_interface(service: &ServiceDetail) -> String {
    let mut out = String::new();
    let service_name = service.name.to_upper_camel_case();

    if let Some(doc) = &service.doc {
        out.push_str(&format!("/** {doc} */\n"));
    }
    out.push_str(&format!("interface {service_name}Caller {{\n"));

    for method in &service.methods {
        let method_name = method.method_name.to_lower_camel_case();
        let args = method
            .args
            .iter()
            .map(|a| {
                format!(
                    "{} {}",
                    java_type(&a.type_info),
                    a.name.to_lower_camel_case()
                )
            })
            .collect::<Vec<_>>()
            .join(", ");
        let ret_ty = java_type(&method.return_type);

        if let Some(doc) = &method.doc {
            out.push_str(&format!("    /** {doc} */\n"));
        }
        out.push_str(&format!(
            "    CompletableFuture<{ret_ty}> {method_name}({args});\n"
        ));
    }

    out.push_str("}\n\n");
    out
}

fn generate_server_handler(service: &ServiceDetail) -> String {
    let mut out = String::new();
    let service_name = service.name.to_upper_camel_case();

    out.push_str(&format!("/** Handler interface for {service_name}. */\n"));
    out.push_str(&format!("interface {service_name}Handler {{\n"));

    for method in &service.methods {
        let method_name = method.method_name.to_lower_camel_case();
        let args = method
            .args
            .iter()
            .map(|a| {
                format!(
                    "{} {}",
                    java_type(&a.type_info),
                    a.name.to_lower_camel_case()
                )
            })
            .collect::<Vec<_>>()
            .join(", ");
        let ret_ty = java_type(&method.return_type);

        out.push_str(&format!(
            "    CompletableFuture<{ret_ty}> {method_name}({args});\n"
        ));
    }

    out.push_str("}\n\n");

    // Generate dispatcher class
    out.push_str(&format!("/** Dispatcher for {service_name} service. */\n"));
    out.push_str(&format!("final class {service_name}Dispatcher {{\n"));
    out.push_str(&format!(
        "    private final {service_name}Handler handler;\n\n"
    ));
    out.push_str(&format!(
        "    public {service_name}Dispatcher({service_name}Handler handler) {{\n"
    ));
    out.push_str("        this.handler = handler;\n");
    out.push_str("    }\n\n");

    out.push_str(
        "    public CompletableFuture<byte[]> dispatch(long methodId, byte[] payload) {\n",
    );
    out.push_str("        RuntimeHelpers.IntRef off = new RuntimeHelpers.IntRef(0);\n");
    out.push_str("        switch ((int) methodId) {\n");

    for method in &service.methods {
        let method_name = method.method_name.to_lower_camel_case();
        let id = crate::method_id(method);
        // Use int cast since Java switch doesn't work well with long
        out.push_str(&format!("            case (int) {}L:\n", hex_u64(id)));
        out.push_str("                try {\n");

        // Decode arguments
        for arg in &method.args {
            let arg_name = arg.name.to_lower_camel_case();
            out.push_str(&format!(
                "                    String {arg_name} = RuntimeHelpers.readString(payload, off);\n"
            ));
        }

        // Call handler
        let args_list = method
            .args
            .iter()
            .map(|a| a.name.to_lower_camel_case())
            .collect::<Vec<_>>()
            .join(", ");

        out.push_str(&format!(
            "                    return handler.{method_name}({args_list})\n"
        ));
        out.push_str("                        .thenApply(result -> RuntimeHelpers.encodeResultOk(result, RuntimeHelpers::encodeString))\n");
        out.push_str(
            "                        .exceptionally(err -> RuntimeHelpers.encodeResultErr(err));\n",
        );
        out.push_str("                } catch (Exception e) {\n");
        out.push_str("                    return CompletableFuture.completedFuture(RuntimeHelpers.encodeInvalidPayloadError());\n");
        out.push_str("                }\n");
    }

    out.push_str("            default:\n");
    out.push_str(
        "                return CompletableFuture.completedFuture(RuntimeHelpers.encodeUnknownMethodError());\n",
    );
    out.push_str("        }\n");
    out.push_str("    }\n");
    out.push_str("}\n");

    out
}

fn java_type(ty: &TypeDetail) -> String {
    match ty {
        TypeDetail::Bool => "Boolean".into(),
        TypeDetail::U8 | TypeDetail::I8 => "Byte".into(),
        TypeDetail::U16 | TypeDetail::I16 => "Short".into(),
        TypeDetail::U32 | TypeDetail::I32 => "Integer".into(),
        TypeDetail::U64 | TypeDetail::I64 => "Long".into(),
        TypeDetail::U128 | TypeDetail::I128 => "java.math.BigInteger".into(),
        TypeDetail::F32 => "Float".into(),
        TypeDetail::F64 => "Double".into(),
        TypeDetail::Char => "Character".into(),
        TypeDetail::String => "String".into(),
        TypeDetail::Unit => "Void".into(),
        TypeDetail::Bytes => "byte[]".into(),
        TypeDetail::List(inner) => format!("java.util.List<{}>", java_type(inner)),
        TypeDetail::Option(inner) => format!("java.util.Optional<{}>", java_type(inner)),
        TypeDetail::Array { element, .. } => format!("{}[]", java_type(element)),
        TypeDetail::Map { key, value } => {
            format!("java.util.Map<{}, {}>", java_type(key), java_type(value))
        }
        TypeDetail::Set(inner) => format!("java.util.Set<{}>", java_type(inner)),
        TypeDetail::Tuple(items) => {
            // Java doesn't have tuples; would need a record or class
            match items.len() {
                2 => format!(
                    "java.util.Map.Entry<{}, {}>",
                    java_type(&items[0]),
                    java_type(&items[1])
                ),
                _ => "Object[]".into(),
            }
        }
        // Push: caller sends data to callee
        TypeDetail::Push(inner) => {
            format!("java.util.concurrent.Flow.Subscriber<{}>", java_type(inner))
        }
        // Pull: callee sends data to caller
        TypeDetail::Pull(inner) => {
            format!("java.util.concurrent.Flow.Publisher<{}>", java_type(inner))
        }
        TypeDetail::Struct { .. } => "Object".into(), // Would need proper class generation
        TypeDetail::Enum { .. } => "Object".into(),   // Would need proper enum generation
    }
}

fn generate_runtime_helpers() -> String {
    let mut out = String::new();
    out.push_str("// Runtime helper functions\n\n");

    out.push_str("final class RuntimeHelpers {\n");
    out.push_str("    private RuntimeHelpers() {}\n\n");

    out.push_str("    static void writeUVarint(ByteArrayOutputStream out, long value) {\n");
    out.push_str("        long v = value;\n");
    out.push_str("        while (v >= 0x80) {\n");
    out.push_str("            out.write((int) (v & 0x7F) | 0x80);\n");
    out.push_str("            v >>>= 7;\n");
    out.push_str("        }\n");
    out.push_str("        out.write((int) v);\n");
    out.push_str("    }\n\n");

    out.push_str("    static long readUVarint(byte[] buf, IntRef off) throws EOFException {\n");
    out.push_str("        long result = 0;\n");
    out.push_str("        int shift = 0;\n");
    out.push_str("        while (true) {\n");
    out.push_str("            if (off.v >= buf.length) throw new EOFException(\"varint eof\");\n");
    out.push_str("            int b = buf[off.v++] & 0xFF;\n");
    out.push_str("            if (shift >= 64) throw new EOFException(\"varint overflow\");\n");
    out.push_str("            result |= (long) (b & 0x7F) << shift;\n");
    out.push_str("            if ((b & 0x80) == 0) return result;\n");
    out.push_str("            shift += 7;\n");
    out.push_str("        }\n");
    out.push_str("    }\n\n");

    out.push_str("    static String readString(byte[] buf, IntRef off) throws EOFException {\n");
    out.push_str("        long len = readUVarint(buf, off);\n");
    out.push_str("        if (len < 0 || len > (buf.length - off.v)) throw new EOFException(\"len out of range\");\n");
    out.push_str("        String s = new String(buf, off.v, (int) len, StandardCharsets.UTF_8);\n");
    out.push_str("        off.v += (int) len;\n");
    out.push_str("        return s;\n");
    out.push_str("    }\n\n");

    out.push_str("    static byte[] encodeString(String s) {\n");
    out.push_str("        ByteArrayOutputStream out = new ByteArrayOutputStream();\n");
    out.push_str("        byte[] bytes = s.getBytes(StandardCharsets.UTF_8);\n");
    out.push_str("        writeUVarint(out, bytes.length);\n");
    out.push_str("        out.writeBytes(bytes);\n");
    out.push_str("        return out.toByteArray();\n");
    out.push_str("    }\n\n");

    out.push_str("    static byte[] encodeResultOk(String value, java.util.function.Function<String, byte[]> encoder) {\n");
    out.push_str("        ByteArrayOutputStream out = new ByteArrayOutputStream();\n");
    out.push_str("        writeUVarint(out, 0); // Result::Ok\n");
    out.push_str("        out.writeBytes(encoder.apply(value));\n");
    out.push_str("        return out.toByteArray();\n");
    out.push_str("    }\n\n");

    out.push_str("    static byte[] encodeResultErr(Throwable err) {\n");
    out.push_str("        ByteArrayOutputStream out = new ByteArrayOutputStream();\n");
    out.push_str("        writeUVarint(out, 1); // Result::Err\n");
    out.push_str("        writeUVarint(out, 0); // RoamError::User\n");
    out.push_str("        byte[] msg = err.getMessage().getBytes(StandardCharsets.UTF_8);\n");
    out.push_str("        writeUVarint(out, msg.length);\n");
    out.push_str("        out.writeBytes(msg);\n");
    out.push_str("        return out.toByteArray();\n");
    out.push_str("    }\n\n");

    out.push_str("    static byte[] encodeUnknownMethodError() {\n");
    out.push_str("        ByteArrayOutputStream out = new ByteArrayOutputStream();\n");
    out.push_str("        writeUVarint(out, 1); // Result::Err\n");
    out.push_str("        writeUVarint(out, 1); // RoamError::UnknownMethod\n");
    out.push_str("        return out.toByteArray();\n");
    out.push_str("    }\n\n");

    out.push_str("    static byte[] encodeInvalidPayloadError() {\n");
    out.push_str("        ByteArrayOutputStream out = new ByteArrayOutputStream();\n");
    out.push_str("        writeUVarint(out, 1); // Result::Err\n");
    out.push_str("        writeUVarint(out, 2); // RoamError::InvalidPayload\n");
    out.push_str("        return out.toByteArray();\n");
    out.push_str("    }\n\n");

    out.push_str("    static final class IntRef {\n");
    out.push_str("        int v;\n");
    out.push_str("        IntRef(int v) { this.v = v; }\n");
    out.push_str("    }\n");
    out.push_str("}\n");

    out
}
