//! Swift code generation for roam services.
//!
//! This module generates Swift client and server code from service definitions.
//! The generated code includes:
//! - Type definitions for all named types (structs, enums)
//! - Caller protocol and client implementation for making RPC calls
//! - Handler protocol for implementing services
//! - Dispatcher for routing incoming calls
//! - Encoding/decoding logic for all types
//! - Runtime schema information for channel binding

pub mod client;
pub mod decode;
pub mod encode;
pub mod schema;
pub mod server;
pub mod types;

use roam_schema::{MethodDetail, ServiceDetail};

pub use client::generate_client;
pub use schema::generate_schemas;
pub use server::generate_server;
pub use types::{collect_named_types, generate_named_types};

/// Controls which Swift bindings are generated for a service.
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum SwiftBindings {
    /// Generate client-side bindings (`*Caller`, `*Client`) and shared support code.
    Client,
    /// Generate server-side bindings (`*Handler`, `*ChannelingDispatcher`) and shared support code.
    Server,
    /// Generate both client and server bindings (legacy default behavior).
    ClientAndServer,
}

/// Generate method IDs as a Swift enum.
pub fn generate_method_ids(methods: &[MethodDetail]) -> String {
    use crate::render::{fq_name, hex_u64};

    let mut items = methods
        .iter()
        .map(|m| (fq_name(m), crate::method_id(m)))
        .collect::<Vec<_>>();
    items.sort_by(|a, b| a.0.cmp(&b.0));

    let mut out = String::new();
    out.push_str("// @generated by roam-codegen\n");
    out.push_str("// This file defines canonical roam method IDs.\n\n");
    out.push_str("public enum RoamMethodId {\n");
    out.push_str("    public static let byName: [String: UInt64] = [\n");
    for (name, id) in items {
        out.push_str(&format!("        \"{name}\": {hex},\n", hex = hex_u64(id)));
    }
    out.push_str("    ]\n");
    out.push_str("}\n");
    out
}

/// Generate a complete Swift module for a service.
///
/// This is the main entry point for Swift code generation.
pub fn generate_service(service: &ServiceDetail) -> String {
    generate_service_with_bindings(service, SwiftBindings::ClientAndServer)
}

/// Generate a Swift module for a service with explicit client/server selection.
///
/// Shared sections (method IDs, named types, schemas) are always included.
pub fn generate_service_with_bindings(service: &ServiceDetail, bindings: SwiftBindings) -> String {
    use crate::render::hex_u64;
    use heck::{ToLowerCamelCase, ToUpperCamelCase};

    let mut out = String::new();
    out.push_str("// @generated by roam-codegen\n");
    out.push_str("// DO NOT EDIT - regenerate with `cargo xtask codegen --swift`\n\n");
    out.push_str("import Foundation\n");
    out.push_str("import RoamRuntime\n\n");

    let service_name = service.name.to_upper_camel_case();

    // Generate method IDs enum
    out.push_str(&format!("// MARK: - {service_name} Method IDs\n\n"));
    out.push_str(&format!("public enum {service_name}MethodId {{\n"));
    for method in &service.methods {
        let method_name = method.method_name.to_lower_camel_case();
        let id = crate::method_id(method);
        out.push_str(&format!(
            "    public static let {method_name}: UInt64 = {hex}\n",
            hex = hex_u64(id)
        ));
    }
    out.push_str("}\n\n");

    // Generate named types
    out.push_str(&format!("// MARK: - {service_name} Types\n\n"));
    let named_types = collect_named_types(service);
    out.push_str(&generate_named_types(&named_types));

    match bindings {
        SwiftBindings::Client => {
            out.push_str(&format!("// MARK: - {service_name} Client\n\n"));
            out.push_str(&generate_client(service));
        }
        SwiftBindings::Server => {
            out.push_str(&format!("// MARK: - {service_name} Server\n\n"));
            out.push_str(&generate_server(service));
        }
        SwiftBindings::ClientAndServer => {
            out.push_str(&format!("// MARK: - {service_name} Client\n\n"));
            out.push_str(&generate_client(service));

            out.push_str(&format!("// MARK: - {service_name} Server\n\n"));
            out.push_str(&generate_server(service));
        }
    }

    // Always generate runtime schema info used for channel binding.
    out.push_str(&format!("// MARK: - {service_name} Schemas\n\n"));
    out.push_str(&generate_schemas(service));

    out
}

#[cfg(test)]
mod tests {
    use super::*;
    use facet::Facet;
    use roam_schema::{ArgDetail, MethodDetail, ServiceDetail};
    use std::borrow::Cow;

    fn sample_service() -> ServiceDetail {
        ServiceDetail {
            name: Cow::Borrowed("Echo"),
            doc: Some(Cow::Borrowed("Simple echo service")),
            methods: vec![MethodDetail {
                service_name: Cow::Borrowed("Echo"),
                method_name: Cow::Borrowed("echo"),
                args: vec![ArgDetail {
                    name: Cow::Borrowed("message"),
                    ty: <String as Facet>::SHAPE,
                }],
                return_type: <String as Facet>::SHAPE,
                doc: Some(Cow::Borrowed("Echo back the message")),
            }],
        }
    }

    #[test]
    fn test_generate_service_contains_protocols() {
        let service = sample_service();
        let code = generate_service(&service);

        assert!(code.contains("protocol EchoCaller"));
        assert!(code.contains("protocol EchoHandler"));
        assert!(code.contains("EchoClient"));
        assert!(code.contains("EchoChannelingDispatcher"));
        assert!(code.contains("EchoMethodId"));
    }

    #[test]
    fn test_generate_service_client_only() {
        let service = sample_service();
        let code = generate_service_with_bindings(&service, SwiftBindings::Client);

        assert!(code.contains("protocol EchoCaller"));
        assert!(code.contains("EchoClient"));
        assert!(!code.contains("protocol EchoHandler"));
        assert!(!code.contains("EchoChannelingDispatcher"));
        assert!(code.contains("EchoMethodId"));
        assert!(code.contains("echo_schemas"));
    }

    #[test]
    fn test_generate_service_server_only() {
        let service = sample_service();
        let code = generate_service_with_bindings(&service, SwiftBindings::Server);

        assert!(!code.contains("protocol EchoCaller"));
        assert!(!code.contains("EchoClient"));
        assert!(code.contains("protocol EchoHandler"));
        assert!(code.contains("EchoChannelingDispatcher"));
        assert!(code.contains("EchoMethodId"));
        assert!(code.contains("echo_schemas"));
    }
}
