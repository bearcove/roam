//! Go code generation for roam services.
//!
//! Generates caller interfaces, handler interfaces, client implementations,
//! and dispatchers from ServiceDetail.

use std::collections::HashSet;

use facet_core::{ScalarType, Shape};
use heck::{ToSnakeCase, ToUpperCamelCase};
use roam_schema::{
    EnumInfo, MethodDetail, ServiceDetail, ShapeKind, StructInfo, VariantKind, classify_shape,
    classify_variant, is_bytes, is_rx, is_tx,
};

use crate::render::{fq_name, hex_u64};

pub fn generate_method_ids(methods: &[MethodDetail]) -> String {
    let mut items = methods
        .iter()
        .map(|m| (fq_name(m), crate::method_id(m)))
        .collect::<Vec<_>>();
    items.sort_by(|a, b| a.0.cmp(&b.0));

    let mut out = String::new();
    out.push_str("// Code generated by roam-codegen. DO NOT EDIT.\n\n");
    out.push_str("package roam\n\n");
    out.push_str("var MethodID = map[string]uint64{\n");
    for (name, id) in items {
        out.push_str(&format!("    \"{name}\": {hex},\n", hex = hex_u64(id)));
    }
    out.push_str("}\n");
    out
}

// ============================================================================
// Named Type Collection and Generation
// ============================================================================

/// Collect all named types (structs and enums with a name) from a service.
fn collect_named_types(service: &ServiceDetail) -> Vec<(String, &'static Shape)> {
    let mut seen: HashSet<String> = HashSet::new();
    let mut types = Vec::new();

    fn visit(
        shape: &'static Shape,
        seen: &mut HashSet<String>,
        types: &mut Vec<(String, &'static Shape)>,
    ) {
        match classify_shape(shape) {
            ShapeKind::Struct(StructInfo {
                name: Some(name),
                fields,
                ..
            }) => {
                if !seen.contains(name) {
                    seen.insert(name.to_string());
                    // Visit nested types first (dependencies before dependents)
                    for field in fields {
                        visit(field.shape(), seen, types);
                    }
                    types.push((name.to_string(), shape));
                }
            }
            ShapeKind::Enum(EnumInfo {
                name: Some(name),
                variants,
            }) => {
                if !seen.contains(name) {
                    seen.insert(name.to_string());
                    // Visit nested types in variants
                    for variant in variants {
                        match classify_variant(variant) {
                            VariantKind::Newtype { inner } => visit(inner, seen, types),
                            VariantKind::Struct { fields } | VariantKind::Tuple { fields } => {
                                for field in fields {
                                    visit(field.shape(), seen, types);
                                }
                            }
                            VariantKind::Unit => {}
                        }
                    }
                    types.push((name.to_string(), shape));
                }
            }
            ShapeKind::List { element } => visit(element, seen, types),
            ShapeKind::Option { inner } => visit(inner, seen, types),
            ShapeKind::Array { element, .. } => visit(element, seen, types),
            ShapeKind::Map { key, value } => {
                visit(key, seen, types);
                visit(value, seen, types);
            }
            ShapeKind::Set { element } => visit(element, seen, types),
            ShapeKind::Tuple { elements } => {
                for param in elements {
                    visit(param.shape, seen, types);
                }
            }
            ShapeKind::Tx { inner } | ShapeKind::Rx { inner } => visit(inner, seen, types),
            ShapeKind::Pointer { pointee } => visit(pointee, seen, types),
            _ => {}
        }
    }

    for method in &service.methods {
        for arg in &method.args {
            visit(arg.ty, &mut seen, &mut types);
        }
        visit(method.return_type, &mut seen, &mut types);
    }

    types
}

/// Generate Go type definitions for all named types.
fn generate_named_types(named_types: &[(String, &'static Shape)]) -> String {
    let mut out = String::new();

    if named_types.is_empty() {
        return out;
    }

    out.push_str("// Named type definitions\n\n");

    for (name, shape) in named_types {
        match classify_shape(shape) {
            ShapeKind::Struct(StructInfo { fields, .. }) => {
                out.push_str(&format!("type {name} struct {{\n"));
                for field in fields {
                    let field_name = field.name.to_upper_camel_case();
                    let field_type = go_type_base(field.shape());
                    out.push_str(&format!("\t{field_name} {field_type}\n"));
                }
                out.push_str("}\n\n");
            }
            ShapeKind::Enum(EnumInfo { variants, .. }) => {
                // Go doesn't have sum types, so we generate an interface + variant structs
                out.push_str(&format!("// {name} is a sum type (enum)\n"));
                out.push_str(&format!("type {name} interface {{\n"));
                out.push_str(&format!("\tis{name}()\n"));
                out.push_str("}\n\n");

                for variant in variants {
                    let variant_name = format!("{name}{}", variant.name.to_upper_camel_case());
                    match classify_variant(variant) {
                        VariantKind::Unit => {
                            out.push_str(&format!("type {variant_name} struct{{}}\n"));
                        }
                        VariantKind::Newtype { inner } => {
                            out.push_str(&format!("type {variant_name} struct {{\n"));
                            out.push_str(&format!("\tValue {}\n", go_type_base(inner)));
                            out.push_str("}\n");
                        }
                        VariantKind::Struct { fields } | VariantKind::Tuple { fields } => {
                            out.push_str(&format!("type {variant_name} struct {{\n"));
                            for field in fields {
                                let field_name = field.name.to_upper_camel_case();
                                let field_type = go_type_base(field.shape());
                                out.push_str(&format!("\t{field_name} {field_type}\n"));
                            }
                            out.push_str("}\n");
                        }
                    }
                    out.push_str(&format!("func ({variant_name}) is{name}() {{}}\n\n"));
                }
            }
            _ => {}
        }
    }

    out
}

// ============================================================================
// Service Generation (Public API)
// ============================================================================

/// Generate a complete Go module for a service.
///
/// r[impl codegen.go.service] - Generate client, server, and method IDs.
pub fn generate_service(service: &ServiceDetail) -> String {
    let mut out = String::new();

    // Header
    out.push_str("// Code generated by roam-codegen. DO NOT EDIT.\n\n");

    // Package declaration (use service name in snake_case)
    let pkg_name = service.name.to_snake_case();
    out.push_str(&format!("package {pkg_name}\n\n"));

    // Imports
    out.push_str("import (\n");
    out.push_str("\t\"context\"\n");
    out.push_str("\t\"encoding/binary\"\n");
    out.push_str("\t\"errors\"\n");
    out.push_str("\t\"math\"\n");
    out.push_str(")\n\n");

    // Suppress unused import warnings
    out.push_str("var _ = binary.LittleEndian\n");
    out.push_str("var _ = math.MaxFloat32\n");
    out.push_str("var _ = errors.New\n\n");

    // Collect and generate named types
    let named_types = collect_named_types(service);
    out.push_str(&generate_named_types(&named_types));

    // Generate method IDs
    out.push_str(&generate_service_method_ids(service));

    // Generate caller interface (client perspective)
    out.push_str(&generate_caller_interface(service));

    // Generate handler interface (server perspective)
    out.push_str(&generate_handler_interface(service));

    // Generate client implementation
    out.push_str(&generate_client_impl(service));

    // Generate dispatcher implementation
    out.push_str(&generate_dispatcher_impl(service));

    out
}

/// Generate method ID constants for the service.
fn generate_service_method_ids(service: &ServiceDetail) -> String {
    let mut out = String::new();

    out.push_str("// Method IDs\n");
    out.push_str("const (\n");

    for method in &service.methods {
        let const_name = format!("MethodID{}", method.method_name.to_upper_camel_case());
        let id = crate::method_id(method);
        out.push_str(&format!("\t{const_name} uint64 = {}\n", hex_u64(id)));
    }

    out.push_str(")\n\n");
    out
}

/// Generate the caller interface (client perspective).
fn generate_caller_interface(service: &ServiceDetail) -> String {
    let mut out = String::new();

    let interface_name = format!("{}Caller", service.name.to_upper_camel_case());

    // Doc comment
    if let Some(doc) = &service.doc {
        out.push_str(&format!("// {interface_name} {doc}\n"));
    }

    out.push_str(&format!("type {interface_name} interface {{\n"));

    for method in &service.methods {
        let method_name = method.method_name.to_upper_camel_case();

        // Doc comment
        if let Some(doc) = &method.doc {
            out.push_str(&format!("\t// {method_name} {doc}\n"));
        }

        // Method signature
        let args: Vec<String> = method
            .args
            .iter()
            .map(|a| format!("{} {}", a.name.to_snake_case(), go_type_client_arg(a.ty)))
            .collect();

        let has_streaming =
            method.args.iter().any(|a| is_stream(a.ty)) || is_stream(method.return_type);

        let ret_type = go_type_client_return(method.return_type);

        if has_streaming || ret_type == "()" {
            out.push_str(&format!(
                "\t{method_name}(ctx context.Context, {}) error\n",
                args.join(", ")
            ));
        } else {
            out.push_str(&format!(
                "\t{method_name}(ctx context.Context, {}) ({ret_type}, error)\n",
                args.join(", ")
            ));
        }
    }

    out.push_str("}\n\n");
    out
}

/// Generate the handler interface (server perspective).
fn generate_handler_interface(service: &ServiceDetail) -> String {
    let mut out = String::new();

    let interface_name = format!("{}Handler", service.name.to_upper_camel_case());

    // Doc comment
    if let Some(doc) = &service.doc {
        out.push_str(&format!("// {interface_name} Handler for: {doc}\n"));
    }

    out.push_str(&format!("type {interface_name} interface {{\n"));

    for method in &service.methods {
        let method_name = method.method_name.to_upper_camel_case();

        // Doc comment
        if let Some(doc) = &method.doc {
            out.push_str(&format!("\t// {method_name} {doc}\n"));
        }

        // Method signature - server perspective INVERTS Tx/Rx
        let args: Vec<String> = method
            .args
            .iter()
            .map(|a| format!("{} {}", a.name.to_snake_case(), go_type_server_arg(a.ty)))
            .collect();

        let has_streaming =
            method.args.iter().any(|a| is_stream(a.ty)) || is_stream(method.return_type);

        let ret_type = go_type_server_return(method.return_type);

        if has_streaming || ret_type == "()" {
            out.push_str(&format!(
                "\t{method_name}(ctx context.Context, {}) error\n",
                args.join(", ")
            ));
        } else {
            out.push_str(&format!(
                "\t{method_name}(ctx context.Context, {}) ({ret_type}, error)\n",
                args.join(", ")
            ));
        }
    }

    out.push_str("}\n\n");
    out
}

/// Generate client implementation that implements the Caller interface.
fn generate_client_impl(service: &ServiceDetail) -> String {
    let mut out = String::new();

    let service_name = service.name.to_upper_camel_case();
    let client_name = format!("{service_name}Client");
    let caller_interface = format!("{service_name}Caller");

    // Client struct
    out.push_str(&format!("// {client_name} implements {caller_interface}\n"));
    out.push_str(&format!("type {client_name} struct {{\n"));
    out.push_str("\tconn Connection\n");
    out.push_str("}\n\n");

    // Constructor
    out.push_str(&format!(
        "// New{client_name} creates a new {client_name}\n"
    ));
    out.push_str(&format!(
        "func New{client_name}(conn Connection) *{client_name} {{\n"
    ));
    out.push_str(&format!("\treturn &{client_name}{{conn: conn}}\n"));
    out.push_str("}\n\n");

    // Method implementations
    for method in &service.methods {
        let method_name = method.method_name.to_upper_camel_case();
        let method_id_const = format!("MethodID{method_name}");

        let has_streaming =
            method.args.iter().any(|a| is_stream(a.ty)) || is_stream(method.return_type);

        // Args with types
        let args_with_types: Vec<String> = method
            .args
            .iter()
            .map(|a| format!("{} {}", a.name.to_snake_case(), go_type_client_arg(a.ty)))
            .collect();

        // Arg names only
        let _arg_names: Vec<String> = method.args.iter().map(|a| a.name.to_snake_case()).collect();

        let ret_type = go_type_client_return(method.return_type);

        if has_streaming {
            // Streaming method - placeholder
            out.push_str(&format!(
                "func (c *{client_name}) {method_name}(ctx context.Context, {}) error {{\n",
                args_with_types.join(", ")
            ));
            out.push_str("\t// TODO: Implement streaming call\n");
            out.push_str("\treturn errors.New(\"streaming not implemented\")\n");
            out.push_str("}\n\n");
        } else if ret_type == "()" {
            // Void return
            out.push_str(&format!(
                "func (c *{client_name}) {method_name}(ctx context.Context, {}) error {{\n",
                args_with_types.join(", ")
            ));
            out.push_str(&generate_encode_args(&method.args));
            out.push_str(&format!(
                "\t_, err := c.conn.Call(ctx, {method_id_const}, payload)\n"
            ));
            out.push_str("\treturn err\n");
            out.push_str("}\n\n");
        } else {
            // Normal return
            out.push_str(&format!(
                "func (c *{client_name}) {method_name}(ctx context.Context, {}) ({ret_type}, error) {{\n",
                args_with_types.join(", ")
            ));
            out.push_str(&format!("\tvar result {ret_type}\n"));
            out.push_str(&generate_encode_args(&method.args));
            out.push_str(&format!(
                "\tresponse, err := c.conn.Call(ctx, {method_id_const}, payload)\n"
            ));
            out.push_str("\tif err != nil {\n");
            out.push_str("\t\treturn result, err\n");
            out.push_str("\t}\n");
            out.push_str(&generate_decode_return(method.return_type));
            out.push_str("\treturn result, nil\n");
            out.push_str("}\n\n");
        }
    }

    out
}

/// Generate dispatcher implementation.
fn generate_dispatcher_impl(service: &ServiceDetail) -> String {
    let mut out = String::new();

    let service_name = service.name.to_upper_camel_case();
    let dispatcher_name = format!("{service_name}Dispatcher");
    let handler_interface = format!("{service_name}Handler");

    // Dispatcher struct
    out.push_str(&format!(
        "// {dispatcher_name} dispatches calls to {handler_interface}\n"
    ));
    out.push_str(&format!("type {dispatcher_name} struct {{\n"));
    out.push_str(&format!("\thandler {handler_interface}\n"));
    out.push_str("}\n\n");

    // Constructor
    out.push_str(&format!(
        "// New{dispatcher_name} creates a new {dispatcher_name}\n"
    ));
    out.push_str(&format!(
        "func New{dispatcher_name}(handler {handler_interface}) *{dispatcher_name} {{\n"
    ));
    out.push_str(&format!(
        "\treturn &{dispatcher_name}{{handler: handler}}\n"
    ));
    out.push_str("}\n\n");

    // Dispatch method
    out.push_str("// Dispatch routes a method call to the appropriate handler method\n");
    out.push_str(&format!(
        "func (d *{dispatcher_name}) Dispatch(ctx context.Context, methodID uint64, payload []byte) ([]byte, error) {{\n"
    ));
    out.push_str("\tswitch methodID {\n");

    for method in &service.methods {
        let method_name = method.method_name.to_upper_camel_case();
        let method_id_const = format!("MethodID{method_name}");
        let _handler_method = method.method_name.to_snake_case();

        out.push_str(&format!("\tcase {method_id_const}:\n"));
        out.push_str(&format!(
            "\t\treturn d.dispatch{method_name}(ctx, payload)\n"
        ));
    }

    out.push_str("\tdefault:\n");
    out.push_str("\t\treturn nil, errors.New(\"unknown method\")\n");
    out.push_str("\t}\n");
    out.push_str("}\n\n");

    // Individual dispatch methods
    for method in &service.methods {
        let method_name = method.method_name.to_upper_camel_case();
        let handler_method = method.method_name.to_upper_camel_case();

        let has_streaming =
            method.args.iter().any(|a| is_stream(a.ty)) || is_stream(method.return_type);

        out.push_str(&format!(
            "func (d *{dispatcher_name}) dispatch{method_name}(ctx context.Context, payload []byte) ([]byte, error) {{\n"
        ));

        if has_streaming {
            out.push_str("\t// TODO: Implement streaming dispatch\n");
            out.push_str("\treturn nil, errors.New(\"streaming not implemented\")\n");
        } else {
            // Decode arguments
            out.push_str(&generate_decode_args(&method.args));

            // Call handler
            let arg_names: Vec<String> =
                method.args.iter().map(|a| a.name.to_snake_case()).collect();

            let ret_type = go_type_server_return(method.return_type);

            if ret_type == "()" {
                out.push_str(&format!(
                    "\terr := d.handler.{handler_method}(ctx, {})\n",
                    arg_names.join(", ")
                ));
                out.push_str("\tif err != nil {\n");
                out.push_str("\t\treturn nil, err\n");
                out.push_str("\t}\n");
                out.push_str("\treturn []byte{}, nil\n");
            } else {
                out.push_str(&format!(
                    "\tresult, err := d.handler.{handler_method}(ctx, {})\n",
                    arg_names.join(", ")
                ));
                out.push_str("\tif err != nil {\n");
                out.push_str("\t\treturn nil, err\n");
                out.push_str("\t}\n");
                out.push_str(&generate_encode_return(method.return_type));
            }
        }

        out.push_str("}\n\n");
    }

    out
}

/// Generate code to encode method arguments.
fn generate_encode_args(args: &[roam_schema::ArgDetail]) -> String {
    let mut out = String::new();

    if args.is_empty() {
        out.push_str("\tpayload := []byte{}\n");
        return out;
    }

    out.push_str("\tvar payload []byte\n");
    for arg in args {
        let arg_name = arg.name.to_snake_case();
        let encode_expr = generate_encode_expr(arg.ty, &arg_name);
        out.push_str(&format!("\tpayload = append(payload, {encode_expr}...)\n"));
    }

    out
}

/// Generate code to decode method arguments.
fn generate_decode_args(args: &[roam_schema::ArgDetail]) -> String {
    let mut out = String::new();

    if args.is_empty() {
        out.push_str("\t_ = payload // unused\n");
        return out;
    }

    out.push_str("\toff := 0\n");
    for arg in args {
        let arg_name = arg.name.to_snake_case();
        let arg_type = go_type_server_arg(arg.ty);
        out.push_str(&format!("\tvar {arg_name} {arg_type}\n"));
        out.push_str(&generate_decode_stmt(arg.ty, &arg_name, "off"));
    }

    out
}

/// Generate code to decode return value.
fn generate_decode_return(shape: &'static Shape) -> String {
    let mut out = String::new();
    out.push_str("\toff := 0\n");
    out.push_str(&generate_decode_stmt(shape, "result", "off"));
    out
}

/// Generate code to encode return value.
fn generate_encode_return(shape: &'static Shape) -> String {
    let mut out = String::new();
    let encode_expr = generate_encode_expr(shape, "result");
    out.push_str(&format!("\treturn {encode_expr}, nil\n"));
    out
}

// ============================================================================
// Type Conversion Functions
// ============================================================================

/// Check if a shape is a stream (Tx or Rx).
fn is_stream(shape: &'static Shape) -> bool {
    is_tx(shape) || is_rx(shape)
}

/// Convert ScalarType to Go type string.
fn go_scalar_type(scalar: ScalarType) -> String {
    match scalar {
        ScalarType::Bool => "bool".into(),
        ScalarType::U8 => "uint8".into(),
        ScalarType::U16 => "uint16".into(),
        ScalarType::U32 => "uint32".into(),
        ScalarType::U64 => "uint64".into(),
        ScalarType::U128 => "[16]byte".into(), // Go has no native uint128
        ScalarType::USize => "uint".into(),
        ScalarType::I8 => "int8".into(),
        ScalarType::I16 => "int16".into(),
        ScalarType::I32 => "int32".into(),
        ScalarType::I64 => "int64".into(),
        ScalarType::I128 => "[16]byte".into(), // Go has no native int128
        ScalarType::ISize => "int".into(),
        ScalarType::F32 => "float32".into(),
        ScalarType::F64 => "float64".into(),
        ScalarType::Char => "rune".into(),
        ScalarType::Str | ScalarType::CowStr | ScalarType::String => "string".into(),
        ScalarType::Unit => "struct{}".into(),
        _ => "interface{}".into(),
    }
}

/// Convert Shape to base Go type (non-streaming, non-perspective-aware).
fn go_type_base(shape: &'static Shape) -> String {
    // Check for bytes first
    if is_bytes(shape) {
        return "[]byte".into();
    }

    match classify_shape(shape) {
        ShapeKind::Scalar(scalar) => go_scalar_type(scalar),
        ShapeKind::List { element } => format!("[]{}", go_type_base(element)),
        ShapeKind::Slice { element } => format!("[]{}", go_type_base(element)),
        ShapeKind::Option { inner } => format!("*{}", go_type_base(inner)),
        ShapeKind::Array { element, len } => format!("[{}]{}", len, go_type_base(element)),
        ShapeKind::Map { key, value } => {
            format!("map[{}]{}", go_type_base(key), go_type_base(value))
        }
        ShapeKind::Set { element } => format!("map[{}]struct{{}}", go_type_base(element)),
        ShapeKind::Tuple { elements } => {
            // Go doesn't have tuples; use a struct
            let inner = elements
                .iter()
                .enumerate()
                .map(|(i, p)| format!("F{} {}", i, go_type_base(p.shape)))
                .collect::<Vec<_>>()
                .join("; ");
            format!("struct {{ {inner} }}")
        }
        ShapeKind::Tx { inner } => format!("chan<- {}", go_type_base(inner)),
        ShapeKind::Rx { inner } => format!("<-chan {}", go_type_base(inner)),
        ShapeKind::Struct(StructInfo {
            name: Some(name), ..
        }) => name.to_string(),
        ShapeKind::Struct(StructInfo {
            name: None, fields, ..
        }) => {
            let inner = fields
                .iter()
                .map(|f| {
                    format!(
                        "{} {}",
                        f.name.to_upper_camel_case(),
                        go_type_base(f.shape())
                    )
                })
                .collect::<Vec<_>>()
                .join("; ");
            format!("struct {{ {inner} }}")
        }
        ShapeKind::Enum(EnumInfo {
            name: Some(name), ..
        }) => name.to_string(),
        ShapeKind::Enum(EnumInfo { name: None, .. }) => "interface{}".into(),
        ShapeKind::Pointer { pointee } => go_type_base(pointee),
        ShapeKind::Result { ok, err } => {
            // Go doesn't have a native Result type, use a tuple-like struct or interface
            format!(
                "struct {{ Ok {}; Err {} }}",
                go_type_base(ok),
                go_type_base(err)
            )
        }
        ShapeKind::TupleStruct { fields } => {
            // Anonymous tuple struct - use struct with indexed fields
            let inner = fields
                .iter()
                .enumerate()
                .map(|(i, f)| format!("F{} {}", i, go_type_base(f.shape())))
                .collect::<Vec<_>>()
                .join("; ");
            format!("struct {{ {inner} }}")
        }
        ShapeKind::Opaque => "interface{}".into(),
    }
}

/// Convert Shape to Go type for client arguments.
/// Schema types are from CALLER's perspective (per spec r[streaming.caller-pov]).
/// Caller uses types as-is: Tx = caller sends, Rx = caller receives.
fn go_type_client_arg(shape: &'static Shape) -> String {
    match classify_shape(shape) {
        ShapeKind::Tx { inner } => format!("chan<- {}", go_type_base(inner)),
        ShapeKind::Rx { inner } => format!("<-chan {}", go_type_base(inner)),
        _ => go_type_base(shape),
    }
}

/// Convert Shape to Go type for client returns.
/// Schema types are from CALLER's perspective - no transformation needed.
fn go_type_client_return(shape: &'static Shape) -> String {
    match classify_shape(shape) {
        ShapeKind::Tx { inner } => format!("chan<- {}", go_type_base(inner)),
        ShapeKind::Rx { inner } => format!("<-chan {}", go_type_base(inner)),
        ShapeKind::Scalar(ScalarType::Unit) => "()".into(),
        ShapeKind::Tuple { elements: [] } => "()".into(),
        _ => go_type_base(shape),
    }
}

/// Convert Shape to Go type for server/handler arguments.
/// Schema types are from caller's perspective, so we INVERT for handler.
/// Caller's Tx (sends) becomes handler's Rx (receives).
/// Caller's Rx (receives) becomes handler's Tx (sends).
///
/// r[impl streaming.caller-pov] - Schema is from caller's perspective, server inverts.
fn go_type_server_arg(shape: &'static Shape) -> String {
    match classify_shape(shape) {
        ShapeKind::Tx { inner } => format!("<-chan {}", go_type_base(inner)),
        ShapeKind::Rx { inner } => format!("chan<- {}", go_type_base(inner)),
        _ => go_type_base(shape),
    }
}

/// Convert Shape to Go type for server/handler returns.
/// Schema types are from caller's perspective, so we INVERT for handler.
fn go_type_server_return(shape: &'static Shape) -> String {
    match classify_shape(shape) {
        ShapeKind::Tx { inner } => format!("<-chan {}", go_type_base(inner)),
        ShapeKind::Rx { inner } => format!("chan<- {}", go_type_base(inner)),
        ShapeKind::Scalar(ScalarType::Unit) => "()".into(),
        ShapeKind::Tuple { elements: [] } => "()".into(),
        _ => go_type_base(shape),
    }
}

// ============================================================================
// Encoding/Decoding Code Generation
// ============================================================================

/// Generate a Go expression that encodes a value of the given type.
fn generate_encode_expr(shape: &'static Shape, expr: &str) -> String {
    // Simplified encoding - use a generic encoder
    match classify_shape(shape) {
        ShapeKind::Scalar(ScalarType::Bool) => format!("encodeBool({expr})"),
        ShapeKind::Scalar(ScalarType::U8) => format!("encodeU8({expr})"),
        ShapeKind::Scalar(ScalarType::I8) => format!("encodeI8({expr})"),
        ShapeKind::Scalar(ScalarType::U16) => format!("encodeU16({expr})"),
        ShapeKind::Scalar(ScalarType::I16) => format!("encodeI16({expr})"),
        ShapeKind::Scalar(ScalarType::U32) => format!("encodeU32({expr})"),
        ShapeKind::Scalar(ScalarType::I32) => format!("encodeI32({expr})"),
        ShapeKind::Scalar(ScalarType::U64) => format!("encodeUvarint({expr})"),
        ShapeKind::Scalar(ScalarType::I64) => format!("encodeI64({expr})"),
        ShapeKind::Scalar(ScalarType::F32) => format!("encodeF32({expr})"),
        ShapeKind::Scalar(ScalarType::F64) => format!("encodeF64({expr})"),
        ShapeKind::Scalar(ScalarType::String | ScalarType::Str | ScalarType::CowStr) => {
            format!("encodeString({expr})")
        }
        ShapeKind::Scalar(ScalarType::Unit) => "[]byte{}".into(),
        ShapeKind::List { .. } if is_bytes(shape) => format!("encodeBytes({expr})"),
        _ => format!("encode({expr})"), // Generic fallback
    }
}

/// Generate Go code that decodes a value.
fn generate_decode_stmt(shape: &'static Shape, var_name: &str, offset_var: &str) -> String {
    // Simplified decoding - use a generic decoder
    match classify_shape(shape) {
        ShapeKind::Scalar(ScalarType::Bool) => {
            format!(
                "\t{var_name}, err = readBool(payload, &{offset_var})\n\tif err != nil {{ return nil, err }}\n"
            )
        }
        ShapeKind::Scalar(ScalarType::U8) => {
            format!(
                "\t{var_name}, err = readU8(payload, &{offset_var})\n\tif err != nil {{ return nil, err }}\n"
            )
        }
        ShapeKind::Scalar(ScalarType::I8) => {
            format!(
                "\t{var_name}, err = readI8(payload, &{offset_var})\n\tif err != nil {{ return nil, err }}\n"
            )
        }
        ShapeKind::Scalar(ScalarType::U16) => {
            format!(
                "\t{var_name}, err = readU16(payload, &{offset_var})\n\tif err != nil {{ return nil, err }}\n"
            )
        }
        ShapeKind::Scalar(ScalarType::I16) => {
            format!(
                "\t{var_name}, err = readI16(payload, &{offset_var})\n\tif err != nil {{ return nil, err }}\n"
            )
        }
        ShapeKind::Scalar(ScalarType::U32) => {
            format!(
                "\t{var_name}, err = readU32(payload, &{offset_var})\n\tif err != nil {{ return nil, err }}\n"
            )
        }
        ShapeKind::Scalar(ScalarType::I32) => {
            format!(
                "\t{var_name}, err = readI32(payload, &{offset_var})\n\tif err != nil {{ return nil, err }}\n"
            )
        }
        ShapeKind::Scalar(ScalarType::U64) => {
            format!(
                "\t{var_name}, err = readUvarint(payload, &{offset_var})\n\tif err != nil {{ return nil, err }}\n"
            )
        }
        ShapeKind::Scalar(ScalarType::I64) => {
            format!(
                "\t{var_name}, err = readI64(payload, &{offset_var})\n\tif err != nil {{ return nil, err }}\n"
            )
        }
        ShapeKind::Scalar(ScalarType::F32) => {
            format!(
                "\t{var_name}, err = readF32(payload, &{offset_var})\n\tif err != nil {{ return nil, err }}\n"
            )
        }
        ShapeKind::Scalar(ScalarType::F64) => {
            format!(
                "\t{var_name}, err = readF64(payload, &{offset_var})\n\tif err != nil {{ return nil, err }}\n"
            )
        }
        ShapeKind::Scalar(ScalarType::String | ScalarType::Str | ScalarType::CowStr) => {
            format!(
                "\t{var_name}, err = readString(payload, &{offset_var})\n\tif err != nil {{ return nil, err }}\n"
            )
        }
        ShapeKind::Scalar(ScalarType::Unit) => "\t// Unit type - no decoding needed\n".to_string(),
        ShapeKind::List { .. } if is_bytes(shape) => {
            format!(
                "\t{var_name}, err = readBytes(payload, &{offset_var})\n\tif err != nil {{ return nil, err }}\n"
            )
        }
        _ => format!("\t// TODO: decode {var_name}\n"),
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use facet::Facet;
    use roam_schema::{ArgDetail, MethodDetail, ServiceDetail};
    use std::borrow::Cow;

    #[test]
    fn test_go_type_base_primitives() {
        assert_eq!(go_type_base(<bool as Facet>::SHAPE), "bool");
        assert_eq!(go_type_base(<u32 as Facet>::SHAPE), "uint32");
        assert_eq!(go_type_base(<i64 as Facet>::SHAPE), "int64");
        assert_eq!(go_type_base(<f32 as Facet>::SHAPE), "float32");
        assert_eq!(go_type_base(<f64 as Facet>::SHAPE), "float64");
        assert_eq!(go_type_base(<String as Facet>::SHAPE), "string");
        assert_eq!(go_type_base(<Vec<u8> as Facet>::SHAPE), "[]byte");
        assert_eq!(go_type_base(<() as Facet>::SHAPE), "struct{}");
    }

    #[test]
    fn test_go_type_base_containers() {
        assert_eq!(go_type_base(<Vec<i32> as Facet>::SHAPE), "[]int32");
        assert_eq!(go_type_base(<Option<String> as Facet>::SHAPE), "*string");
    }

    fn sample_service() -> ServiceDetail {
        ServiceDetail {
            name: Cow::Borrowed("Echo"),
            doc: Some(Cow::Borrowed("Simple echo service")),
            methods: vec![MethodDetail {
                service_name: Cow::Borrowed("Echo"),
                method_name: Cow::Borrowed("echo"),
                args: vec![ArgDetail {
                    name: Cow::Borrowed("message"),
                    ty: <String as Facet>::SHAPE,
                }],
                return_type: <String as Facet>::SHAPE,
                doc: Some(Cow::Borrowed("Echo back the message")),
            }],
        }
    }

    #[test]
    fn test_generate_service_contains_interfaces() {
        let service = sample_service();
        let code = generate_service(&service);

        assert!(code.contains("type EchoCaller interface"));
        assert!(code.contains("type EchoHandler interface"));
        assert!(code.contains("type EchoClient struct"));
        assert!(code.contains("EchoDispatcher"));
        assert!(code.contains("MethodIDEcho"));
    }
}
