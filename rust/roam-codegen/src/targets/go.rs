use heck::{ToSnakeCase, ToUpperCamelCase};
use roam_schema::{MethodDetail, ServiceDetail, TypeDetail};

use crate::render::{fq_name, hex_u64};

pub fn generate_method_ids(methods: &[MethodDetail]) -> String {
    let mut items = methods
        .iter()
        .map(|m| (fq_name(m), crate::method_id(m)))
        .collect::<Vec<_>>();
    items.sort_by(|a, b| a.0.cmp(&b.0));

    let mut out = String::new();
    out.push_str("// Code generated by roam-codegen. DO NOT EDIT.\n\n");
    out.push_str("package roam\n\n");
    out.push_str("var MethodID = map[string]uint64{\n");
    for (name, id) in items {
        out.push_str(&format!("    \"{name}\": {hex},\n", hex = hex_u64(id)));
    }
    out.push_str("}\n");
    out
}

/// Generate a complete Go file for a service.
pub fn generate_service(service: &ServiceDetail) -> String {
    let mut out = String::new();
    out.push_str("// Code generated by roam-codegen. DO NOT EDIT.\n\n");
    out.push_str("package roam\n\n");
    out.push_str("import (\n");
    out.push_str("\t\"context\"\n");
    out.push_str("\t\"encoding/binary\"\n");
    out.push_str("\t\"errors\"\n");
    out.push_str(")\n\n");

    let service_name = service.name.to_upper_camel_case();

    // Generate method ID constants
    out.push_str("// Method IDs\n");
    out.push_str("const (\n");
    for method in &service.methods {
        let method_name = method.method_name.to_upper_camel_case();
        let id = crate::method_id(method);
        out.push_str(&format!(
            "\t{service_name}Method{method_name} uint64 = {}\n",
            hex_u64(id)
        ));
    }
    out.push_str(")\n\n");

    // Generate client interface
    out.push_str(&generate_client_interface(service));

    // Generate server handler interface
    out.push_str(&generate_server_handler(service));

    // Generate runtime helper functions
    out.push_str(&generate_runtime_helpers());

    out
}

fn generate_client_interface(service: &ServiceDetail) -> String {
    let mut out = String::new();
    let service_name = service.name.to_upper_camel_case();

    if let Some(doc) = &service.doc {
        out.push_str(&format!("// {service_name}Client - {doc}\n"));
    } else {
        out.push_str(&format!(
            "// {service_name}Client provides client methods for the service.\n"
        ));
    }
    out.push_str(&format!("type {service_name}Client interface {{\n"));

    for method in &service.methods {
        let method_name = method.method_name.to_upper_camel_case();
        let args = method
            .args
            .iter()
            .map(|a| format!("{} {}", a.name.to_snake_case(), go_type(&a.type_info)))
            .collect::<Vec<_>>()
            .join(", ");
        let ret_ty = go_type(&method.return_type);

        if let Some(doc) = &method.doc {
            out.push_str(&format!("\t// {method_name} - {doc}\n"));
        }
        if ret_ty == "()" {
            out.push_str(&format!(
                "\t{method_name}(ctx context.Context, {args}) error\n"
            ));
        } else {
            out.push_str(&format!(
                "\t{method_name}(ctx context.Context, {args}) ({ret_ty}, error)\n"
            ));
        }
    }

    out.push_str("}\n\n");
    out
}

fn generate_server_handler(service: &ServiceDetail) -> String {
    let mut out = String::new();
    let service_name = service.name.to_upper_camel_case();

    out.push_str(&format!(
        "// {service_name}Handler handles server-side method calls.\n"
    ));
    out.push_str(&format!("type {service_name}Handler interface {{\n"));

    for method in &service.methods {
        let method_name = method.method_name.to_upper_camel_case();
        let args = method
            .args
            .iter()
            .map(|a| format!("{} {}", a.name.to_snake_case(), go_type(&a.type_info)))
            .collect::<Vec<_>>()
            .join(", ");
        let ret_ty = go_type(&method.return_type);

        if ret_ty == "()" {
            out.push_str(&format!(
                "\t{method_name}(ctx context.Context, {args}) error\n"
            ));
        } else {
            out.push_str(&format!(
                "\t{method_name}(ctx context.Context, {args}) ({ret_ty}, error)\n"
            ));
        }
    }

    out.push_str("}\n\n");

    // Generate dispatcher function
    out.push_str(&format!(
        "// New{service_name}Dispatcher creates a dispatcher for the service.\n"
    ));
    out.push_str(&format!(
        "func New{service_name}Dispatcher(handler {service_name}Handler) func(ctx context.Context, methodID uint64, payload []byte) ([]byte, error) {{\n"
    ));
    out.push_str(
        "\treturn func(ctx context.Context, methodID uint64, payload []byte) ([]byte, error) {\n",
    );
    out.push_str("\t\tswitch methodID {\n");

    for method in &service.methods {
        let method_name = method.method_name.to_upper_camel_case();
        let id = crate::method_id(method);
        out.push_str(&format!("\t\tcase {}:\n", hex_u64(id)));
        out.push_str("\t\t\toff := 0\n");

        // Decode arguments
        for arg in &method.args {
            let arg_name = arg.name.to_snake_case();
            out.push_str(&format!(
                "\t\t\t{arg_name}, err := readString(payload, &off)\n"
            ));
            out.push_str("\t\t\tif err != nil {\n");
            out.push_str("\t\t\t\treturn encodeInvalidPayloadError(), nil\n");
            out.push_str("\t\t\t}\n");
        }

        // Call handler
        let args_list = method
            .args
            .iter()
            .map(|a| a.name.to_snake_case())
            .collect::<Vec<_>>()
            .join(", ");

        let ret_ty = go_type(&method.return_type);
        if ret_ty == "()" {
            out.push_str(&format!(
                "\t\t\terr = handler.{method_name}(ctx, {args_list})\n"
            ));
            out.push_str("\t\t\tif err != nil {\n");
            out.push_str("\t\t\t\treturn encodeResultErr(err), nil\n");
            out.push_str("\t\t\t}\n");
            out.push_str("\t\t\treturn encodeResultOk(\"\", encodeString), nil\n");
        } else {
            out.push_str(&format!(
                "\t\t\tresult, err := handler.{method_name}(ctx, {args_list})\n"
            ));
            out.push_str("\t\t\tif err != nil {\n");
            out.push_str("\t\t\t\treturn encodeResultErr(err), nil\n");
            out.push_str("\t\t\t}\n");
            out.push_str("\t\t\treturn encodeResultOk(result, encodeString), nil\n");
        }
    }

    out.push_str("\t\tdefault:\n");
    out.push_str("\t\t\treturn encodeUnknownMethodError(), nil\n");
    out.push_str("\t\t}\n");
    out.push_str("\t}\n");
    out.push_str("}\n");

    out
}

fn go_type(ty: &TypeDetail) -> String {
    match ty {
        TypeDetail::Bool => "bool".into(),
        TypeDetail::U8 => "uint8".into(),
        TypeDetail::U16 => "uint16".into(),
        TypeDetail::U32 => "uint32".into(),
        TypeDetail::U64 => "uint64".into(),
        TypeDetail::U128 => "[16]byte".into(), // Go has no native uint128
        TypeDetail::I8 => "int8".into(),
        TypeDetail::I16 => "int16".into(),
        TypeDetail::I32 => "int32".into(),
        TypeDetail::I64 => "int64".into(),
        TypeDetail::I128 => "[16]byte".into(), // Go has no native int128
        TypeDetail::F32 => "float32".into(),
        TypeDetail::F64 => "float64".into(),
        TypeDetail::Char => "rune".into(),
        TypeDetail::String => "string".into(),
        TypeDetail::Unit => "()".into(),
        TypeDetail::Bytes => "[]byte".into(),
        TypeDetail::List(inner) => format!("[]{}", go_type(inner)),
        TypeDetail::Option(inner) => format!("*{}", go_type(inner)),
        TypeDetail::Array { element, len } => format!("[{}]{}", len, go_type(element)),
        TypeDetail::Map { key, value } => format!("map[{}]{}", go_type(key), go_type(value)),
        TypeDetail::Set(inner) => format!("map[{}]struct{{}}", go_type(inner)),
        TypeDetail::Tuple(items) => {
            // Go doesn't have tuples; use a struct
            let inner = items
                .iter()
                .enumerate()
                .map(|(i, t)| format!("F{} {}", i, go_type(t)))
                .collect::<Vec<_>>()
                .join("; ");
            format!("struct {{ {inner} }}")
        }
        TypeDetail::Stream(inner) => format!("<-chan {}", go_type(inner)),
        TypeDetail::Struct { fields } => {
            let inner = fields
                .iter()
                .map(|f| format!("{} {}", f.name.to_upper_camel_case(), go_type(&f.type_info)))
                .collect::<Vec<_>>()
                .join("; ");
            format!("struct {{ {inner} }}")
        }
        TypeDetail::Enum { .. } => "interface{}".into(), // Would need proper type generation
    }
}

fn generate_runtime_helpers() -> String {
    let mut out = String::new();
    out.push_str("// Runtime helper functions\n\n");

    out.push_str("func appendUvarint(dst []byte, v uint64) []byte {\n");
    out.push_str("\tvar tmp [10]byte\n");
    out.push_str("\tn := binary.PutUvarint(tmp[:], v)\n");
    out.push_str("\treturn append(dst, tmp[:n]...)\n");
    out.push_str("}\n\n");

    out.push_str("func readString(buf []byte, off *int) (string, error) {\n");
    out.push_str("\tv, n := binary.Uvarint(buf[*off:])\n");
    out.push_str("\tif n <= 0 {\n");
    out.push_str("\t\treturn \"\", errors.New(\"varint decode error\")\n");
    out.push_str("\t}\n");
    out.push_str("\t*off += n\n");
    out.push_str("\tif v > uint64(len(buf)-*off) {\n");
    out.push_str("\t\treturn \"\", errors.New(\"string: length out of range\")\n");
    out.push_str("\t}\n");
    out.push_str("\ts := string(buf[*off : *off+int(v)])\n");
    out.push_str("\t*off += int(v)\n");
    out.push_str("\treturn s, nil\n");
    out.push_str("}\n\n");

    out.push_str("func encodeString(s string) []byte {\n");
    out.push_str("\tvar out []byte\n");
    out.push_str("\tb := []byte(s)\n");
    out.push_str("\tout = appendUvarint(out, uint64(len(b)))\n");
    out.push_str("\treturn append(out, b...)\n");
    out.push_str("}\n\n");

    out.push_str("func encodeResultOk(value string, encoder func(string) []byte) []byte {\n");
    out.push_str("\tvar out []byte\n");
    out.push_str("\tout = appendUvarint(out, 0) // Result::Ok\n");
    out.push_str("\tout = append(out, encoder(value)...)\n");
    out.push_str("\treturn out\n");
    out.push_str("}\n\n");

    out.push_str("func encodeResultErr(err error) []byte {\n");
    out.push_str("\tvar out []byte\n");
    out.push_str("\tout = appendUvarint(out, 1) // Result::Err\n");
    out.push_str("\tout = appendUvarint(out, 0) // RoamError::User\n");
    out.push_str("\tb := []byte(err.Error())\n");
    out.push_str("\tout = appendUvarint(out, uint64(len(b)))\n");
    out.push_str("\tout = append(out, b...)\n");
    out.push_str("\treturn out\n");
    out.push_str("}\n\n");

    out.push_str("func encodeUnknownMethodError() []byte {\n");
    out.push_str("\tvar out []byte\n");
    out.push_str("\tout = appendUvarint(out, 1) // Result::Err\n");
    out.push_str("\tout = appendUvarint(out, 1) // RoamError::UnknownMethod\n");
    out.push_str("\treturn out\n");
    out.push_str("}\n\n");

    out.push_str("func encodeInvalidPayloadError() []byte {\n");
    out.push_str("\tvar out []byte\n");
    out.push_str("\tout = appendUvarint(out, 1) // Result::Err\n");
    out.push_str("\tout = appendUvarint(out, 2) // RoamError::InvalidPayload\n");
    out.push_str("\treturn out\n");
    out.push_str("}\n");

    out
}
