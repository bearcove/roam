//! Swift code generation for roam services.
//!
//! Generates caller protocols, handler protocols, client implementations,
//! and dispatchers from ServiceDetail.

use std::collections::HashSet;

use facet_core::{ScalarType, Shape};
use heck::{ToLowerCamelCase, ToUpperCamelCase};
use roam_schema::{
    EnumInfo, MethodDetail, ServiceDetail, ShapeKind, StructInfo, VariantKind, classify_shape,
    classify_variant, is_bytes, is_rx, is_tx,
};

use crate::render::{fq_name, hex_u64};

pub fn generate_method_ids(methods: &[MethodDetail]) -> String {
    let mut items = methods
        .iter()
        .map(|m| (fq_name(m), crate::method_id(m)))
        .collect::<Vec<_>>();
    items.sort_by(|a, b| a.0.cmp(&b.0));

    let mut out = String::new();
    out.push_str("// @generated by roam-codegen\n");
    out.push_str("// This file defines canonical roam method IDs.\n\n");
    out.push_str("public enum RoamMethodId {\n");
    out.push_str("    public static let byName: [String: UInt64] = [\n");
    for (name, id) in items {
        out.push_str(&format!("        \"{name}\": {hex},\n", hex = hex_u64(id)));
    }
    out.push_str("    ]\n");
    out.push_str("}\n");
    out
}

/// Generate a complete Swift module for a service.
///
/// r[impl codegen.swift.service] - Generate client, server, and method IDs.
pub fn generate_service(service: &ServiceDetail) -> String {
    let mut out = String::new();
    out.push_str("// @generated by roam-codegen\n");
    out.push_str("// DO NOT EDIT - regenerate with `cargo xtask codegen --swift`\n\n");
    out.push_str("import Foundation\n");
    out.push_str("import RoamRuntime\n\n");

    let service_name = service.name.to_upper_camel_case();

    // Generate method IDs enum
    out.push_str(&format!("// MARK: - {service_name} Method IDs\n\n"));
    out.push_str(&format!("public enum {service_name}MethodId {{\n"));
    for method in &service.methods {
        let method_name = method.method_name.to_lower_camel_case();
        let id = crate::method_id(method);
        out.push_str(&format!(
            "    public static let {method_name}: UInt64 = {}\n",
            hex_u64(id)
        ));
    }
    out.push_str("}\n\n");

    // Collect and generate named types (structs and enums)
    let named_types = collect_named_types(service);
    if !named_types.is_empty() {
        out.push_str(&format!("// MARK: - {service_name} Types\n\n"));
        out.push_str(&generate_named_types(&named_types));
    }

    // Generate caller protocol (for making calls)
    out.push_str(&format!("// MARK: - {service_name} Caller Protocol\n\n"));
    out.push_str(&generate_caller_protocol(service));

    // Generate client implementation
    out.push_str(&format!("// MARK: - {service_name} Client\n\n"));
    out.push_str(&generate_client_impl(service));

    // Generate handler protocol (for handling calls)
    out.push_str(&format!("// MARK: - {service_name} Handler Protocol\n\n"));
    out.push_str(&generate_handler_protocol(service));

    // Generate dispatcher
    out.push_str(&format!("// MARK: - {service_name} Dispatcher\n\n"));
    out.push_str(&generate_dispatcher(service));

    out
}

// ============================================================================
// Named Type Collection and Generation
// ============================================================================

/// Collect all named types (structs and enums with a name) from a service.
fn collect_named_types(service: &ServiceDetail) -> Vec<(String, &'static Shape)> {
    let mut seen: HashSet<String> = HashSet::new();
    let mut types = Vec::new();

    fn visit(
        shape: &'static Shape,
        seen: &mut HashSet<String>,
        types: &mut Vec<(String, &'static Shape)>,
    ) {
        match classify_shape(shape) {
            ShapeKind::Struct(StructInfo {
                name: Some(name),
                fields,
                ..
            }) => {
                if !seen.contains(name) {
                    seen.insert(name.to_string());
                    // Visit nested types first (dependencies before dependents)
                    for field in fields {
                        visit(field.shape(), seen, types);
                    }
                    types.push((name.to_string(), shape));
                }
            }
            ShapeKind::Enum(EnumInfo {
                name: Some(name),
                variants,
            }) => {
                if !seen.contains(name) {
                    seen.insert(name.to_string());
                    // Visit nested types in variants
                    for variant in variants {
                        match classify_variant(variant) {
                            VariantKind::Newtype { inner } => visit(inner, seen, types),
                            VariantKind::Struct { fields } | VariantKind::Tuple { fields } => {
                                for field in fields {
                                    visit(field.shape(), seen, types);
                                }
                            }
                            VariantKind::Unit => {}
                        }
                    }
                    types.push((name.to_string(), shape));
                }
            }
            ShapeKind::List { element } => visit(element, seen, types),
            ShapeKind::Option { inner } => visit(inner, seen, types),
            ShapeKind::Array { element, .. } => visit(element, seen, types),
            ShapeKind::Map { key, value } => {
                visit(key, seen, types);
                visit(value, seen, types);
            }
            ShapeKind::Set { element } => visit(element, seen, types),
            ShapeKind::Tuple { elements } => {
                for param in elements {
                    visit(param.shape, seen, types);
                }
            }
            ShapeKind::Tx { inner } | ShapeKind::Rx { inner } => visit(inner, seen, types),
            ShapeKind::Pointer { pointee } => visit(pointee, seen, types),
            _ => {}
        }
    }

    for method in &service.methods {
        for arg in &method.args {
            visit(arg.ty, &mut seen, &mut types);
        }
        visit(method.return_type, &mut seen, &mut types);
    }

    types
}

/// Generate Swift type definitions for all named types.
fn generate_named_types(named_types: &[(String, &'static Shape)]) -> String {
    let mut out = String::new();

    for (name, shape) in named_types {
        match classify_shape(shape) {
            ShapeKind::Struct(StructInfo { fields, .. }) => {
                out.push_str(&format!("public struct {name}: Codable, Sendable {{\n"));
                for field in fields {
                    let field_name = field.name.to_lower_camel_case();
                    let field_type = swift_type_base(field.shape());
                    out.push_str(&format!("    public var {field_name}: {field_type}\n"));
                }
                out.push_str("\n");
                // Generate init
                if !fields.is_empty() {
                    let params: Vec<String> = fields
                        .iter()
                        .map(|f| {
                            format!(
                                "{}: {}",
                                f.name.to_lower_camel_case(),
                                swift_type_base(f.shape())
                            )
                        })
                        .collect();
                    out.push_str(&format!("    public init({}) {{\n", params.join(", ")));
                    for field in fields {
                        let field_name = field.name.to_lower_camel_case();
                        out.push_str(&format!("        self.{field_name} = {field_name}\n"));
                    }
                    out.push_str("    }\n");
                }
                out.push_str("}\n\n");
            }
            ShapeKind::Enum(EnumInfo { variants, .. }) => {
                out.push_str(&format!("public enum {name}: Codable, Sendable {{\n"));
                for variant in variants {
                    let variant_name = variant.name.to_lower_camel_case();
                    match classify_variant(variant) {
                        VariantKind::Unit => {
                            out.push_str(&format!("    case {variant_name}\n"));
                        }
                        VariantKind::Newtype { inner } => {
                            out.push_str(&format!(
                                "    case {variant_name}({})\n",
                                swift_type_base(inner)
                            ));
                        }
                        VariantKind::Tuple { fields } => {
                            let types: Vec<String> =
                                fields.iter().map(|f| swift_type_base(f.shape())).collect();
                            out.push_str(&format!(
                                "    case {variant_name}({})\n",
                                types.join(", ")
                            ));
                        }
                        VariantKind::Struct { fields } => {
                            let params: Vec<String> = fields
                                .iter()
                                .map(|f| {
                                    format!(
                                        "{}: {}",
                                        f.name.to_lower_camel_case(),
                                        swift_type_base(f.shape())
                                    )
                                })
                                .collect();
                            out.push_str(&format!(
                                "    case {variant_name}({})\n",
                                params.join(", ")
                            ));
                        }
                    }
                }
                out.push_str("}\n\n");
            }
            _ => {}
        }
    }

    out
}

// ============================================================================
// Protocol Generation
// ============================================================================

/// Generate caller protocol (for making calls to the service).
fn generate_caller_protocol(service: &ServiceDetail) -> String {
    let mut out = String::new();
    let service_name = service.name.to_upper_camel_case();

    if let Some(doc) = &service.doc {
        out.push_str(&format!("/// {doc}\n"));
    }
    out.push_str(&format!("public protocol {service_name}Caller {{\n"));

    for method in &service.methods {
        let method_name = method.method_name.to_lower_camel_case();

        if let Some(doc) = &method.doc {
            out.push_str(&format!("    /// {doc}\n"));
        }

        let args: Vec<String> = method
            .args
            .iter()
            .map(|a| {
                format!(
                    "{}: {}",
                    a.name.to_lower_camel_case(),
                    swift_type_client_arg(a.ty)
                )
            })
            .collect();

        let ret_type = swift_type_client_return(method.return_type);
        let has_streaming =
            method.args.iter().any(|a| is_stream(a.ty)) || is_stream(method.return_type);

        if has_streaming {
            out.push_str(&format!(
                "    func {method_name}({}) async throws\n",
                args.join(", ")
            ));
        } else if ret_type == "Void" {
            out.push_str(&format!(
                "    func {method_name}({}) async throws\n",
                args.join(", ")
            ));
        } else {
            out.push_str(&format!(
                "    func {method_name}({}) async throws -> {ret_type}\n",
                args.join(", ")
            ));
        }
    }

    out.push_str("}\n\n");
    out
}

/// Generate handler protocol (for handling incoming calls).
fn generate_handler_protocol(service: &ServiceDetail) -> String {
    let mut out = String::new();
    let service_name = service.name.to_upper_camel_case();

    if let Some(doc) = &service.doc {
        out.push_str(&format!("/// Handler for: {doc}\n"));
    }
    out.push_str(&format!("public protocol {service_name}Handler {{\n"));

    for method in &service.methods {
        let method_name = method.method_name.to_lower_camel_case();

        if let Some(doc) = &method.doc {
            out.push_str(&format!("    /// {doc}\n"));
        }

        // Server perspective - invert Tx/Rx
        let args: Vec<String> = method
            .args
            .iter()
            .map(|a| {
                format!(
                    "{}: {}",
                    a.name.to_lower_camel_case(),
                    swift_type_server_arg(a.ty)
                )
            })
            .collect();

        let ret_type = swift_type_server_return(method.return_type);
        let has_streaming =
            method.args.iter().any(|a| is_stream(a.ty)) || is_stream(method.return_type);

        if has_streaming {
            out.push_str(&format!(
                "    func {method_name}({}) async throws\n",
                args.join(", ")
            ));
        } else if ret_type == "Void" {
            out.push_str(&format!(
                "    func {method_name}({}) async throws\n",
                args.join(", ")
            ));
        } else {
            out.push_str(&format!(
                "    func {method_name}({}) async throws -> {ret_type}\n",
                args.join(", ")
            ));
        }
    }

    out.push_str("}\n\n");
    out
}

// ============================================================================
// Client Implementation
// ============================================================================

/// Generate client implementation (for making calls to the service).
fn generate_client_impl(service: &ServiceDetail) -> String {
    let mut out = String::new();
    let service_name = service.name.to_upper_camel_case();

    out.push_str(&format!(
        "public final class {service_name}Client: {service_name}Caller {{\n"
    ));
    out.push_str("    private let connection: RoamConnection\n\n");
    out.push_str("    public init(connection: RoamConnection) {\n");
    out.push_str("        self.connection = connection\n");
    out.push_str("    }\n\n");

    for method in &service.methods {
        let method_name = method.method_name.to_lower_camel_case();
        let method_id_name = method.method_name.to_lower_camel_case();

        let args: Vec<String> = method
            .args
            .iter()
            .map(|a| {
                format!(
                    "{}: {}",
                    a.name.to_lower_camel_case(),
                    swift_type_client_arg(a.ty)
                )
            })
            .collect();

        let ret_type = swift_type_client_return(method.return_type);
        let has_streaming =
            method.args.iter().any(|a| is_stream(a.ty)) || is_stream(method.return_type);

        if has_streaming {
            out.push_str(&format!(
                "    public func {method_name}({}) async throws {{\n",
                args.join(", ")
            ));
            out.push_str("        // TODO: Implement streaming call\n");
            out.push_str("        throw RoamError.notImplemented\n");
            out.push_str("    }\n\n");
        } else if ret_type == "Void" {
            out.push_str(&format!(
                "    public func {method_name}({}) async throws {{\n",
                args.join(", ")
            ));
            out.push_str(&generate_encode_args(&method.args));
            out.push_str(&format!(
                "        _ = try await connection.call(methodId: {service_name}MethodId.{method_id_name}, payload: payload)\n"
            ));
            out.push_str("    }\n\n");
        } else {
            out.push_str(&format!(
                "    public func {method_name}({}) async throws -> {ret_type} {{\n",
                args.join(", ")
            ));
            out.push_str(&generate_encode_args(&method.args));
            out.push_str(&format!(
                "        let response = try await connection.call(methodId: {service_name}MethodId.{method_id_name}, payload: payload)\n"
            ));
            out.push_str(&generate_decode_return(method.return_type, &ret_type));
            out.push_str("    }\n\n");
        }
    }

    out.push_str("}\n\n");
    out
}

// ============================================================================
// Dispatcher
// ============================================================================

/// Generate dispatcher for handling incoming calls.
fn generate_dispatcher(service: &ServiceDetail) -> String {
    let mut out = String::new();
    let service_name = service.name.to_upper_camel_case();

    out.push_str(&format!("public final class {service_name}Dispatcher {{\n"));
    out.push_str(&format!(
        "    private let handler: {service_name}Handler\n\n"
    ));
    out.push_str(&format!(
        "    public init(handler: {service_name}Handler) {{\n"
    ));
    out.push_str("        self.handler = handler\n");
    out.push_str("    }\n\n");

    out.push_str(
        "    public func dispatch(methodId: UInt64, payload: Data) async throws -> Data {\n",
    );
    out.push_str("        switch methodId {\n");

    for method in &service.methods {
        let method_name = method.method_name.to_lower_camel_case();
        let method_id_name = method.method_name.to_lower_camel_case();

        out.push_str(&format!(
            "        case {service_name}MethodId.{method_id_name}:\n"
        ));
        out.push_str(&format!(
            "            return try await dispatch{method_name}(payload: payload)\n"
        ));
    }

    out.push_str("        default:\n");
    out.push_str("            throw RoamError.unknownMethod\n");
    out.push_str("        }\n");
    out.push_str("    }\n\n");

    // Generate individual dispatch methods
    for method in &service.methods {
        let method_name = method.method_name.to_lower_camel_case();
        let has_streaming =
            method.args.iter().any(|a| is_stream(a.ty)) || is_stream(method.return_type);

        out.push_str(&format!(
            "    private func dispatch{method_name}(payload: Data) async throws -> Data {{\n"
        ));

        if has_streaming {
            out.push_str("        // TODO: Implement streaming dispatch\n");
            out.push_str("        throw RoamError.notImplemented\n");
        } else {
            // Decode arguments
            out.push_str(&generate_decode_args(&method.args));

            // Call handler
            let arg_names: Vec<String> = method
                .args
                .iter()
                .map(|a| {
                    format!(
                        "{}: {}",
                        a.name.to_lower_camel_case(),
                        a.name.to_lower_camel_case()
                    )
                })
                .collect();

            let ret_type = swift_type_server_return(method.return_type);

            if ret_type == "Void" {
                out.push_str(&format!(
                    "        try await handler.{method_name}({})\n",
                    arg_names.join(", ")
                ));
                out.push_str("        return Data()\n");
            } else {
                out.push_str(&format!(
                    "        let result = try await handler.{method_name}({})\n",
                    arg_names.join(", ")
                ));
                out.push_str(&generate_encode_return(method.return_type));
            }
        }

        out.push_str("    }\n\n");
    }

    out.push_str("}\n");
    out
}

// ============================================================================
// Code Generation Helpers
// ============================================================================

/// Generate code to encode method arguments.
fn generate_encode_args(args: &[roam_schema::ArgDetail]) -> String {
    let mut out = String::new();

    if args.is_empty() {
        out.push_str("        let payload = Data()\n");
        return out;
    }

    out.push_str("        var encoder = RoamEncoder()\n");
    for arg in args {
        let arg_name = arg.name.to_lower_camel_case();
        out.push_str(&format!("        try encoder.encode({arg_name})\n"));
    }
    out.push_str("        let payload = encoder.data\n");

    out
}

/// Generate code to decode method arguments.
fn generate_decode_args(args: &[roam_schema::ArgDetail]) -> String {
    let mut out = String::new();

    if args.is_empty() {
        out.push_str("        // No arguments to decode\n");
        return out;
    }

    out.push_str("        var decoder = RoamDecoder(data: payload)\n");
    for arg in args {
        let arg_name = arg.name.to_lower_camel_case();
        let arg_type = swift_type_server_arg(arg.ty);
        out.push_str(&format!(
            "        let {arg_name}: {arg_type} = try decoder.decode()\n"
        ));
    }

    out
}

/// Generate code to decode return value.
fn generate_decode_return(_shape: &'static Shape, swift_type: &str) -> String {
    let mut out = String::new();
    out.push_str("        var decoder = RoamDecoder(data: response)\n");
    out.push_str(&format!(
        "        let result: {swift_type} = try decoder.decode()\n"
    ));
    out.push_str("        return result\n");
    out
}

/// Generate code to encode return value.
fn generate_encode_return(_shape: &'static Shape) -> String {
    let mut out = String::new();
    out.push_str("        var encoder = RoamEncoder()\n");
    out.push_str("        try encoder.encode(result)\n");
    out.push_str("        return encoder.data\n");
    out
}

// ============================================================================
// Type Conversion Functions
// ============================================================================

/// Check if a shape is a stream (Tx or Rx).
fn is_stream(shape: &'static Shape) -> bool {
    is_tx(shape) || is_rx(shape)
}

/// Convert ScalarType to Swift type string.
fn swift_scalar_type(scalar: ScalarType) -> String {
    match scalar {
        ScalarType::Bool => "Bool".into(),
        ScalarType::U8 => "UInt8".into(),
        ScalarType::U16 => "UInt16".into(),
        ScalarType::U32 => "UInt32".into(),
        ScalarType::U64 => "UInt64".into(),
        ScalarType::U128 => "UInt128".into(),
        ScalarType::USize => "UInt".into(),
        ScalarType::I8 => "Int8".into(),
        ScalarType::I16 => "Int16".into(),
        ScalarType::I32 => "Int32".into(),
        ScalarType::I64 => "Int64".into(),
        ScalarType::I128 => "Int128".into(),
        ScalarType::ISize => "Int".into(),
        ScalarType::F32 => "Float".into(),
        ScalarType::F64 => "Double".into(),
        ScalarType::Char => "Character".into(),
        ScalarType::Str | ScalarType::CowStr | ScalarType::String => "String".into(),
        ScalarType::Unit => "Void".into(),
        _ => "Any".into(),
    }
}

/// Convert Shape to base Swift type (non-streaming, non-perspective-aware).
fn swift_type_base(shape: &'static Shape) -> String {
    // Check for bytes first
    if is_bytes(shape) {
        return "Data".into();
    }

    match classify_shape(shape) {
        ShapeKind::Scalar(scalar) => swift_scalar_type(scalar),
        ShapeKind::List { element } => format!("[{}]", swift_type_base(element)),
        ShapeKind::Slice { element } => format!("[{}]", swift_type_base(element)),
        ShapeKind::Option { inner } => format!("{}?", swift_type_base(inner)),
        ShapeKind::Array { element, len } => {
            // Swift doesn't have fixed-size arrays, use regular array
            format!("[{}] /* size: {} */", swift_type_base(element), len)
        }
        ShapeKind::Map { key, value } => {
            format!("[{}: {}]", swift_type_base(key), swift_type_base(value))
        }
        ShapeKind::Set { element } => format!("Set<{}>", swift_type_base(element)),
        ShapeKind::Tuple { elements } => {
            let inner = elements
                .iter()
                .map(|p| swift_type_base(p.shape))
                .collect::<Vec<_>>()
                .join(", ");
            format!("({inner})")
        }
        ShapeKind::Tx { inner } => format!("Tx<{}>", swift_type_base(inner)),
        ShapeKind::Rx { inner } => format!("Rx<{}>", swift_type_base(inner)),
        ShapeKind::Struct(StructInfo {
            name: Some(name), ..
        }) => name.to_string(),
        ShapeKind::Struct(StructInfo {
            name: None, fields, ..
        }) => {
            // Anonymous struct - use tuple
            let inner = fields
                .iter()
                .map(|f| swift_type_base(f.shape()))
                .collect::<Vec<_>>()
                .join(", ");
            format!("({inner})")
        }
        ShapeKind::Enum(EnumInfo {
            name: Some(name), ..
        }) => name.to_string(),
        ShapeKind::Enum(EnumInfo {
            name: None,
            variants,
        }) => {
            // Check for Result pattern
            if variants.len() == 2 {
                let ok_variant = variants.iter().find(|v| v.name == "Ok");
                let err_variant = variants.iter().find(|v| v.name == "Err");

                if let (Some(ok_v), Some(err_v)) = (ok_variant, err_variant) {
                    if let (
                        VariantKind::Newtype { inner: ok_ty },
                        VariantKind::Newtype { inner: err_ty },
                    ) = (classify_variant(ok_v), classify_variant(err_v))
                    {
                        return format!(
                            "Result<{}, {}>",
                            swift_type_base(ok_ty),
                            swift_type_base(err_ty)
                        );
                    }
                }
            }
            // Anonymous enum - fallback to Any
            "Any /* anonymous enum */".into()
        }
        ShapeKind::Pointer { pointee } => swift_type_base(pointee),
        ShapeKind::Result { ok, err } => {
            format!("Result<{}, {}>", swift_type_base(ok), swift_type_base(err))
        }
        ShapeKind::Opaque => "Any".into(),
    }
}

/// Convert Shape to Swift type for client arguments.
/// Schema types are from CALLER's perspective (per spec r[streaming.caller-pov]).
/// Caller uses types as-is: Tx = caller sends, Rx = caller receives.
fn swift_type_client_arg(shape: &'static Shape) -> String {
    match classify_shape(shape) {
        ShapeKind::Tx { inner } => format!("Tx<{}>", swift_type_base(inner)),
        ShapeKind::Rx { inner } => format!("Rx<{}>", swift_type_base(inner)),
        _ => swift_type_base(shape),
    }
}

/// Convert Shape to Swift type for client returns.
/// Schema types are from CALLER's perspective - no transformation needed.
fn swift_type_client_return(shape: &'static Shape) -> String {
    match classify_shape(shape) {
        ShapeKind::Tx { inner } => format!("Tx<{}>", swift_type_base(inner)),
        ShapeKind::Rx { inner } => format!("Rx<{}>", swift_type_base(inner)),
        ShapeKind::Scalar(ScalarType::Unit) => "Void".into(),
        ShapeKind::Tuple { elements } if elements.is_empty() => "Void".into(),
        _ => swift_type_base(shape),
    }
}

/// Convert Shape to Swift type for server/handler arguments.
/// Schema types are from caller's perspective, so we INVERT for handler.
/// Caller's Tx (sends) becomes handler's Rx (receives).
/// Caller's Rx (receives) becomes handler's Tx (sends).
///
/// r[impl streaming.caller-pov] - Schema is from caller's perspective, server inverts.
fn swift_type_server_arg(shape: &'static Shape) -> String {
    match classify_shape(shape) {
        ShapeKind::Tx { inner } => format!("Rx<{}>", swift_type_base(inner)),
        ShapeKind::Rx { inner } => format!("Tx<{}>", swift_type_base(inner)),
        _ => swift_type_base(shape),
    }
}

/// Convert Shape to Swift type for server/handler returns.
/// Schema types are from caller's perspective, so we INVERT for handler.
fn swift_type_server_return(shape: &'static Shape) -> String {
    match classify_shape(shape) {
        ShapeKind::Tx { inner } => format!("Rx<{}>", swift_type_base(inner)),
        ShapeKind::Rx { inner } => format!("Tx<{}>", swift_type_base(inner)),
        ShapeKind::Scalar(ScalarType::Unit) => "Void".into(),
        ShapeKind::Tuple { elements } if elements.is_empty() => "Void".into(),
        _ => swift_type_base(shape),
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use facet::Facet;
    use roam_schema::{ArgDetail, MethodDetail, ServiceDetail};
    use std::borrow::Cow;

    #[test]
    fn test_swift_type_base_primitives() {
        assert_eq!(swift_type_base(<bool as Facet>::SHAPE), "Bool");
        assert_eq!(swift_type_base(<u32 as Facet>::SHAPE), "UInt32");
        assert_eq!(swift_type_base(<i64 as Facet>::SHAPE), "Int64");
        assert_eq!(swift_type_base(<f32 as Facet>::SHAPE), "Float");
        assert_eq!(swift_type_base(<f64 as Facet>::SHAPE), "Double");
        assert_eq!(swift_type_base(<String as Facet>::SHAPE), "String");
        assert_eq!(swift_type_base(<Vec<u8> as Facet>::SHAPE), "Data");
        assert_eq!(swift_type_base(<() as Facet>::SHAPE), "Void");
    }

    #[test]
    fn test_swift_type_base_containers() {
        assert_eq!(swift_type_base(<Vec<i32> as Facet>::SHAPE), "[Int32]");
        assert_eq!(swift_type_base(<Option<String> as Facet>::SHAPE), "String?");
    }

    fn sample_service() -> ServiceDetail {
        ServiceDetail {
            name: Cow::Borrowed("Echo"),
            doc: Some(Cow::Borrowed("Simple echo service")),
            methods: vec![MethodDetail {
                service_name: Cow::Borrowed("Echo"),
                method_name: Cow::Borrowed("echo"),
                args: vec![ArgDetail {
                    name: Cow::Borrowed("message"),
                    ty: <String as Facet>::SHAPE,
                }],
                return_type: <String as Facet>::SHAPE,
                doc: Some(Cow::Borrowed("Echo back the message")),
            }],
        }
    }

    #[test]
    fn test_generate_service_contains_protocols() {
        let service = sample_service();
        let code = generate_service(&service);

        assert!(code.contains("protocol EchoCaller"));
        assert!(code.contains("protocol EchoHandler"));
        assert!(code.contains("EchoClient"));
        assert!(code.contains("EchoDispatcher"));
        assert!(code.contains("EchoMethodId"));
    }
}
