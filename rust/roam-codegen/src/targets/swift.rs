use heck::{ToLowerCamelCase, ToUpperCamelCase};
use roam_schema::{MethodDetail, ServiceDetail, TypeDetail};

use crate::render::{fq_name, hex_u64};

pub fn generate_method_ids(methods: &[MethodDetail]) -> String {
    let mut items = methods
        .iter()
        .map(|m| (fq_name(m), crate::method_id(m)))
        .collect::<Vec<_>>();
    items.sort_by(|a, b| a.0.cmp(&b.0));

    let mut out = String::new();
    out.push_str("// @generated by roam-codegen\n");
    out.push_str("// This file defines canonical roam method IDs.\n\n");
    out.push_str("public enum RoamMethodId {\n");
    out.push_str("    public static let byName: [String: UInt64] = [\n");
    for (name, id) in items {
        out.push_str(&format!("        \"{name}\": {hex},\n", hex = hex_u64(id)));
    }
    out.push_str("    ]\n");
    out.push_str("}\n");
    out
}

/// Generate a complete Swift module for a service.
pub fn generate_service(service: &ServiceDetail) -> String {
    let mut out = String::new();
    out.push_str("// @generated by roam-codegen\n");
    out.push_str("// DO NOT EDIT - regenerate with `cargo run -p roam-codegen`\n\n");
    out.push_str("import Foundation\n");
    out.push_str("import RoamRuntime\n\n");

    let service_name = service.name.to_upper_camel_case();

    // Generate method IDs
    out.push_str(&format!("public enum {service_name}MethodId {{\n"));
    for method in &service.methods {
        let method_name = method.method_name.to_lower_camel_case();
        let id = crate::method_id(method);
        out.push_str(&format!(
            "    public static let {method_name}: UInt64 = {}\n",
            hex_u64(id)
        ));
    }
    out.push_str("}\n\n");

    // Generate client protocol
    out.push_str(&generate_client_protocol(service));

    // Generate server handler protocol
    out.push_str(&generate_server_handler(service));

    out
}

fn generate_client_protocol(service: &ServiceDetail) -> String {
    let mut out = String::new();
    let service_name = service.name.to_upper_camel_case();

    if let Some(doc) = &service.doc {
        out.push_str(&format!("/// {doc}\n"));
    }
    out.push_str(&format!("public protocol {service_name}Client {{\n"));

    for method in &service.methods {
        let method_name = method.method_name.to_lower_camel_case();
        let args = method
            .args
            .iter()
            .map(|a| {
                format!(
                    "{}: {}",
                    a.name.to_lower_camel_case(),
                    swift_type(&a.type_info)
                )
            })
            .collect::<Vec<_>>()
            .join(", ");
        let ret_ty = swift_type(&method.return_type);

        if let Some(doc) = &method.doc {
            out.push_str(&format!("    /// {doc}\n"));
        }
        out.push_str(&format!(
            "    func {method_name}({args}) async throws -> {ret_ty}\n"
        ));
    }

    out.push_str("}\n\n");
    out
}

fn generate_server_handler(service: &ServiceDetail) -> String {
    let mut out = String::new();
    let service_name = service.name.to_upper_camel_case();

    out.push_str(&format!("/// Server handler protocol for {service_name}\n"));
    out.push_str(&format!("public protocol {service_name}Handler {{\n"));

    for method in &service.methods {
        let method_name = method.method_name.to_lower_camel_case();
        let args = method
            .args
            .iter()
            .map(|a| {
                format!(
                    "{}: {}",
                    a.name.to_lower_camel_case(),
                    swift_type(&a.type_info)
                )
            })
            .collect::<Vec<_>>()
            .join(", ");
        let ret_ty = swift_type(&method.return_type);

        out.push_str(&format!(
            "    func {method_name}({args}) async throws -> {ret_ty}\n"
        ));
    }

    out.push_str("}\n\n");

    // Generate dispatcher function
    out.push_str(&format!(
        "public func create{service_name}Dispatcher(handler: any {service_name}Handler) -> (UInt64, Data) async throws -> Data {{\n"
    ));
    out.push_str("    return { methodId, payload in\n");
    out.push_str("        switch methodId {\n");

    for method in &service.methods {
        let method_name = method.method_name.to_lower_camel_case();
        let id = crate::method_id(method);
        out.push_str(&format!("        case {}:\n", hex_u64(id)));
        out.push_str("            do {\n");
        out.push_str("                var offset = 0\n");

        // Decode arguments
        for (i, arg) in method.args.iter().enumerate() {
            let arg_name = arg.name.to_lower_camel_case();
            out.push_str(&format!(
                "                let {arg_name} = try decodeString(from: payload, offset: &offset)\n"
            ));
        }

        // Call handler
        let args_list = method
            .args
            .iter()
            .map(|a| {
                let name = a.name.to_lower_camel_case();
                format!("{name}: {name}")
            })
            .collect::<Vec<_>>()
            .join(", ");
        out.push_str(&format!(
            "                let result = try await handler.{method_name}({args_list})\n"
        ));

        // Encode result
        out.push_str(
            "                return Data(encodeResultOk(result, encoder: encodeString))\n",
        );
        out.push_str("            } catch {\n");
        out.push_str("                return Data(encodeInvalidPayloadError())\n");
        out.push_str("            }\n");
    }

    out.push_str("        default:\n");
    out.push_str("            return Data(encodeUnknownMethodError())\n");
    out.push_str("        }\n");
    out.push_str("    }\n");
    out.push_str("}\n");

    out
}

fn swift_type(ty: &TypeDetail) -> String {
    match ty {
        TypeDetail::Bool => "Bool".into(),
        TypeDetail::U8 => "UInt8".into(),
        TypeDetail::U16 => "UInt16".into(),
        TypeDetail::U32 => "UInt32".into(),
        TypeDetail::U64 => "UInt64".into(),
        TypeDetail::U128 => "UInt128".into(),
        TypeDetail::I8 => "Int8".into(),
        TypeDetail::I16 => "Int16".into(),
        TypeDetail::I32 => "Int32".into(),
        TypeDetail::I64 => "Int64".into(),
        TypeDetail::I128 => "Int128".into(),
        TypeDetail::F32 => "Float".into(),
        TypeDetail::F64 => "Double".into(),
        TypeDetail::Char => "Character".into(),
        TypeDetail::String => "String".into(),
        TypeDetail::Unit => "Void".into(),
        TypeDetail::Bytes => "Data".into(),
        TypeDetail::List(inner) => format!("[{}]", swift_type(inner)),
        TypeDetail::Option(inner) => format!("{}?", swift_type(inner)),
        TypeDetail::Array { element, len } => format!("[{}; {}]", swift_type(element), len),
        TypeDetail::Map { key, value } => format!("[{}: {}]", swift_type(key), swift_type(value)),
        TypeDetail::Set(inner) => format!("Set<{}>", swift_type(inner)),
        TypeDetail::Tuple(items) => {
            let inner = items.iter().map(swift_type).collect::<Vec<_>>().join(", ");
            format!("({inner})")
        }
        TypeDetail::Stream(inner) => format!("AsyncThrowingStream<{}, Error>", swift_type(inner)),
        TypeDetail::Struct { fields } => {
            let inner = fields
                .iter()
                .map(|f| format!("{}: {}", f.name, swift_type(&f.type_info)))
                .collect::<Vec<_>>()
                .join(", ");
            format!("({inner})")
        }
        TypeDetail::Enum { .. } => "Any".into(), // Would need proper enum generation
    }
}
