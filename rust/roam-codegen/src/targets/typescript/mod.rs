//! TypeScript code generation for roam services.
//!
//! This module generates TypeScript client and server code from service definitions.
//! The generated code includes:
//! - Type definitions for all named types (structs, enums)
//! - Client interface and implementation for making RPC calls
//! - Server handler interface for implementing services
//! - Encoding/decoding logic for all types
//! - Runtime schema information for channel binding

pub mod client;
pub mod decode;
pub mod encode;
pub mod http_client;
pub mod schema;
pub mod server;
pub mod types;

use crate::code_writer::CodeWriter;
use roam_schema::{MethodDetail, ServiceDetail};

pub use client::generate_client;
pub use http_client::generate_http_client;
pub use schema::generate_schemas;
pub use server::generate_server;
pub use types::{collect_named_types, generate_named_types};

/// Generate method IDs as a TypeScript constant record.
pub fn generate_method_ids(methods: &[MethodDetail]) -> String {
    use crate::render::{fq_name, hex_u64};

    let mut items = methods
        .iter()
        .map(|m| (fq_name(m), crate::method_id(m)))
        .collect::<Vec<_>>();
    items.sort_by(|a, b| a.0.cmp(&b.0));

    let mut out = String::new();
    out.push_str("// @generated by roam-codegen\n");
    out.push_str("// This file defines canonical roam method IDs.\n\n");
    out.push_str("export const METHOD_ID: Record<string, bigint> = {\n");
    for (name, id) in items {
        out.push_str(&format!("  \"{name}\": {}n,\n", hex_u64(id)));
    }
    out.push_str("} as const;\n");
    out
}

/// Generate a complete TypeScript module for a service.
///
/// This is the main entry point for TypeScript code generation.
pub fn generate_service(service: &ServiceDetail) -> String {
    use crate::code_writer::CodeWriter;
    use crate::{cw_writeln, render::hex_u64};
    use heck::ToLowerCamelCase;

    let mut output = String::new();
    let mut w = CodeWriter::with_indent_spaces(&mut output, 2);

    // Header
    cw_writeln!(w, "// @generated by roam-codegen").unwrap();
    cw_writeln!(
        w,
        "// DO NOT EDIT - regenerate with `cargo xtask codegen --typescript`"
    )
    .unwrap();
    w.blank_line().unwrap();

    // TODO: This import list should probably be in roam-core or generated more intelligently
    generate_imports(service, &mut w);
    w.blank_line().unwrap();

    // Method IDs
    cw_writeln!(w, "export const METHOD_ID = {{").unwrap();
    {
        let _indent = w.indent();
        for method in &service.methods {
            let id = crate::method_id(method);
            let method_name = method.method_name.to_lower_camel_case();
            cw_writeln!(w, "{method_name}: {}n,", hex_u64(id)).unwrap();
        }
    }
    cw_writeln!(w, "}} as const;").unwrap();
    w.blank_line().unwrap();

    // Named types (structs and enums)
    let named_types = collect_named_types(service);
    output.push_str(&generate_named_types(&named_types));

    // Type aliases for request/response (only if they don't conflict with named types)
    output.push_str(&generate_request_response_types(service, &named_types));

    // Client
    output.push_str(&generate_client(service));

    // Server
    output.push_str(&generate_server(service));

    // Schemas
    output.push_str(&generate_schemas(service));

    output
}

/// Generate imports for the service module.
///
/// Uses namespace imports for postcard encoding functions to avoid tracking
/// which specific functions are used. The bundler will tree-shake unused exports.
fn generate_imports(service: &ServiceDetail, w: &mut CodeWriter<&mut String>) {
    use crate::cw_writeln;
    use roam_schema::{ShapeKind, classify_shape, is_rx, is_tx};

    // Check if any method uses channels
    let has_streaming = service.methods.iter().any(|m| {
        m.args.iter().any(|a| is_tx(a.ty) || is_rx(a.ty))
            || is_tx(m.return_type)
            || is_rx(m.return_type)
    });

    // Check if any method returns Result<T, E> (fallible methods)
    let has_fallible = service
        .methods
        .iter()
        .any(|m| matches!(classify_shape(m.return_type), ShapeKind::Result { .. }));

    // Type imports
    cw_writeln!(
        w,
        "import type {{ MethodHandler, MethodSchema, Caller }} from \"@bearcove/roam-core\";"
    )
    .unwrap();

    // Namespace import for all postcard encoding/decoding functions
    // This avoids tracking which specific functions are used - bundler will tree-shake
    cw_writeln!(w, "import * as pc from \"@bearcove/roam-postcard\";").unwrap();

    // Core runtime imports (non-postcard)
    cw_writeln!(
        w,
        "import {{ encodeResultOk, encodeResultErr, encodeInvalidPayload, encodeWithSchema, decodeWithSchema, helloExchangeInitiator, defaultHello, CallBuilder }} from \"@bearcove/roam-core\";"
    )
    .unwrap();

    // WebSocket transport for connect helper
    cw_writeln!(w, "import {{ connectWs }} from \"@bearcove/roam-ws\";").unwrap();

    // RpcError for fallible methods (methods returning Result<T, E>)
    if has_fallible {
        cw_writeln!(w, "import {{ RpcError }} from \"@bearcove/roam-core\";").unwrap();
    }

    if has_streaming {
        cw_writeln!(
            w,
            "import {{ Tx, Rx, createServerTx, createServerRx, bindChannels }} from \"@bearcove/roam-core\";"
        )
        .unwrap();
        cw_writeln!(
            w,
            "import type {{ ChannelId, ChannelRegistry, TaskSender, BindingSerializers, Schema }} from \"@bearcove/roam-core\";"
        )
        .unwrap();
    }
}

/// Generate request/response type aliases, skipping any that conflict with named types
fn generate_request_response_types(
    service: &ServiceDetail,
    named_types: &[(String, &'static facet_core::Shape)],
) -> String {
    use heck::ToUpperCamelCase;
    use std::collections::HashSet;
    use types::ts_type;

    // Collect just the type names for conflict checking
    let type_names: HashSet<&str> = named_types.iter().map(|(name, _)| name.as_str()).collect();

    let mut out = String::new();
    out.push_str("// Request/Response type aliases\n");

    for method in &service.methods {
        let method_name = method.method_name.to_upper_camel_case();
        let request_name = format!("{method_name}Request");
        let response_name = format!("{method_name}Response");

        // Only generate request type alias if it doesn't conflict with a named type
        if !type_names.contains(request_name.as_str()) {
            if method.args.is_empty() {
                out.push_str(&format!("export type {request_name} = [];\n"));
            } else if method.args.len() == 1 {
                let ty = ts_type(method.args[0].ty);
                out.push_str(&format!("export type {request_name} = [{ty}];\n"));
            } else {
                out.push_str(&format!("export type {request_name} = [\n"));
                for arg in &method.args {
                    let ty = ts_type(arg.ty);
                    out.push_str(&format!("  {ty}, // {}\n", arg.name));
                }
                out.push_str("];\n");
            }
        }

        // Only generate response type alias if it doesn't conflict with a named type
        if !type_names.contains(response_name.as_str()) {
            let ret_ty = ts_type(method.return_type);
            out.push_str(&format!("export type {response_name} = {ret_ty};\n"));
        }

        out.push('\n');
    }

    out
}
