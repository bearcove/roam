//! TypeScript code generation for roam services.
//!
//! This module generates TypeScript client and server code from service definitions.
//! The generated code includes:
//! - Type definitions for all named types (structs, enums)
//! - Client interface and implementation for making RPC calls
//! - Server handler interface for implementing services
//! - Encoding/decoding logic for all types
//! - Runtime schema information for streaming channel binding

pub mod client;
pub mod decode;
pub mod encode;
pub mod http_client;
pub mod schema;
pub mod server;
pub mod types;

use crate::code_writer::CodeWriter;
use roam_schema::{MethodDetail, ServiceDetail};

pub use client::generate_client;
pub use http_client::generate_http_client;
pub use schema::generate_schemas;
pub use server::generate_server;
pub use types::{collect_named_types, generate_named_types};

/// Generate method IDs as a TypeScript constant record.
pub fn generate_method_ids(methods: &[MethodDetail]) -> String {
    use crate::render::{fq_name, hex_u64};

    let mut items = methods
        .iter()
        .map(|m| (fq_name(m), crate::method_id(m)))
        .collect::<Vec<_>>();
    items.sort_by(|a, b| a.0.cmp(&b.0));

    let mut out = String::new();
    out.push_str("// @generated by roam-codegen\n");
    out.push_str("// This file defines canonical roam method IDs.\n\n");
    out.push_str("export const METHOD_ID: Record<string, bigint> = {\n");
    for (name, id) in items {
        out.push_str(&format!("  \"{name}\": {}n,\n", hex_u64(id)));
    }
    out.push_str("} as const;\n");
    out
}

/// Generate a complete TypeScript module for a service.
///
/// This is the main entry point for TypeScript code generation.
pub fn generate_service(service: &ServiceDetail) -> String {
    use crate::code_writer::CodeWriter;
    use crate::{cw_writeln, render::hex_u64};
    use heck::ToLowerCamelCase;

    let mut output = String::new();
    let mut w = CodeWriter::with_indent_spaces(&mut output, 2);

    // Header
    cw_writeln!(w, "// @generated by roam-codegen").unwrap();
    cw_writeln!(
        w,
        "// DO NOT EDIT - regenerate with `cargo xtask codegen --typescript`"
    )
    .unwrap();
    w.blank_line().unwrap();

    // TODO: This import list should probably be in roam-core or generated more intelligently
    generate_imports(service, &mut w);
    w.blank_line().unwrap();

    // Method IDs
    cw_writeln!(w, "export const METHOD_ID = {{").unwrap();
    {
        let _indent = w.indent();
        for method in &service.methods {
            let id = crate::method_id(method);
            let method_name = method.method_name.to_lower_camel_case();
            cw_writeln!(w, "{method_name}: {}n,", hex_u64(id)).unwrap();
        }
    }
    cw_writeln!(w, "}} as const;").unwrap();
    w.blank_line().unwrap();

    // Named types (structs and enums)
    let named_types = collect_named_types(service);
    output.push_str(&generate_named_types(&named_types));

    // Type aliases for request/response (only if they don't conflict with named types)
    output.push_str(&generate_request_response_types(service, &named_types));

    // Client
    output.push_str(&generate_client(service));

    // Server
    output.push_str(&generate_server(service));

    // Schemas
    output.push_str(&generate_schemas(service));

    output
}

/// Tracks which imports are needed based on the types used in a service.
#[derive(Default)]
struct ImportTracker {
    // Scalars
    bool: bool,
    u8: bool,
    i8: bool,
    u16: bool,
    i16: bool,
    u32: bool,
    i32: bool,
    u64: bool,
    i64: bool,
    f32: bool,
    f64: bool,
    string: bool,
    bytes: bool,
    // Composites
    option: bool,
    vec: bool,
    tuple2: bool,
    tuple3: bool,
    enum_variant: bool,
    // Always needed
    concat: bool,
}

impl ImportTracker {
    fn visit_service(&mut self, service: &ServiceDetail) {
        for method in &service.methods {
            for arg in &method.args {
                self.visit_shape(arg.ty);
            }
            self.visit_shape(method.return_type);
        }
    }

    fn visit_shape(&mut self, shape: &'static facet_core::Shape) {
        use facet_core::ScalarType;
        use roam_schema::{
            EnumInfo, ShapeKind, StructInfo, VariantKind, classify_shape, classify_variant,
            is_bytes,
        };

        if is_bytes(shape) {
            self.bytes = true;
            return;
        }

        match classify_shape(shape) {
            ShapeKind::Scalar(scalar) => match scalar {
                ScalarType::Bool => self.bool = true,
                ScalarType::U8 => self.u8 = true,
                ScalarType::I8 => self.i8 = true,
                ScalarType::U16 => self.u16 = true,
                ScalarType::I16 => self.i16 = true,
                ScalarType::U32 => self.u32 = true,
                ScalarType::I32 => self.i32 = true,
                ScalarType::U64 => self.u64 = true,
                ScalarType::I64 => self.i64 = true,
                ScalarType::F32 => self.f32 = true,
                ScalarType::F64 => self.f64 = true,
                // String-like types
                ScalarType::Char | ScalarType::Str | ScalarType::String | ScalarType::CowStr => {
                    self.string = true
                }
                // Unit type doesn't need any imports
                ScalarType::Unit => {}
                // Large integers (u128/i128) and size types - treat as u64/i64
                ScalarType::U128 | ScalarType::USize => self.u64 = true,
                ScalarType::I128 | ScalarType::ISize => self.i64 = true,
                // Catch-all for any future scalar types
                _ => {}
            },
            ShapeKind::List { element }
            | ShapeKind::Array { element, .. }
            | ShapeKind::Slice { element }
            | ShapeKind::Set { element } => {
                self.vec = true;
                self.visit_shape(element);
            }
            ShapeKind::Option { inner } => {
                self.option = true;
                self.visit_shape(inner);
            }
            ShapeKind::Map { key, value } => {
                self.vec = true;
                self.concat = true;
                self.visit_shape(key);
                self.visit_shape(value);
            }
            ShapeKind::Tuple { elements } => {
                if elements.len() == 2 {
                    self.tuple2 = true;
                } else if elements.len() == 3 {
                    self.tuple3 = true;
                }
                if elements.len() > 1 {
                    self.concat = true;
                }
                for elem in elements {
                    self.visit_shape(elem.shape);
                }
            }
            ShapeKind::TupleStruct { fields } => {
                if fields.len() == 2 {
                    self.tuple2 = true;
                } else if fields.len() == 3 {
                    self.tuple3 = true;
                }
                if fields.len() > 1 {
                    self.concat = true;
                }
                for field in fields {
                    self.visit_shape(field.shape());
                }
            }
            ShapeKind::Struct(StructInfo { fields, .. }) => {
                if fields.len() > 1 {
                    self.concat = true;
                }
                for field in fields {
                    self.visit_shape(field.shape());
                }
            }
            ShapeKind::Enum(EnumInfo { variants, .. }) => {
                self.enum_variant = true;
                for variant in variants {
                    match classify_variant(variant) {
                        VariantKind::Unit => {}
                        VariantKind::Newtype { inner } => {
                            self.concat = true;
                            self.visit_shape(inner);
                        }
                        VariantKind::Struct { fields } | VariantKind::Tuple { fields } => {
                            self.concat = true;
                            for field in fields {
                                self.visit_shape(field.shape());
                            }
                        }
                    }
                }
            }
            ShapeKind::Result { ok, err } => {
                self.visit_shape(ok);
                self.visit_shape(err);
            }
            ShapeKind::Tx { inner } | ShapeKind::Rx { inner } => {
                self.visit_shape(inner);
            }
            ShapeKind::Pointer { pointee } => {
                self.visit_shape(pointee);
            }
            ShapeKind::Opaque => {}
        }
    }

    fn generate_scalar_imports(&self) -> Vec<&'static str> {
        let mut imports = Vec::new();
        if self.bool {
            imports.push("encodeBool");
            imports.push("decodeBool");
        }
        if self.u8 {
            imports.push("encodeU8");
            imports.push("decodeU8");
        }
        if self.i8 {
            imports.push("encodeI8");
            imports.push("decodeI8");
        }
        if self.u16 {
            imports.push("encodeU16");
            imports.push("decodeU16");
        }
        if self.i16 {
            imports.push("encodeI16");
            imports.push("decodeI16");
        }
        if self.u32 {
            imports.push("encodeU32");
            imports.push("decodeU32");
        }
        if self.i32 {
            imports.push("encodeI32");
            imports.push("decodeI32");
        }
        if self.u64 {
            imports.push("encodeU64");
            imports.push("decodeU64");
        }
        if self.i64 {
            imports.push("encodeI64");
            imports.push("decodeI64");
        }
        if self.f32 {
            imports.push("encodeF32");
            imports.push("decodeF32");
        }
        if self.f64 {
            imports.push("encodeF64");
            imports.push("decodeF64");
        }
        if self.string {
            imports.push("encodeString");
            imports.push("decodeString");
        }
        if self.bytes {
            imports.push("encodeBytes");
            imports.push("decodeBytes");
        }
        imports
    }

    fn generate_composite_imports(&self) -> Vec<&'static str> {
        let mut imports = Vec::new();
        if self.option {
            imports.push("encodeOption");
            imports.push("decodeOption");
        }
        if self.vec {
            imports.push("encodeVec");
            imports.push("decodeVec");
        }
        if self.tuple2 {
            imports.push("encodeTuple2");
            imports.push("decodeTuple2");
        }
        if self.tuple3 {
            imports.push("encodeTuple3");
            imports.push("decodeTuple3");
        }
        if self.enum_variant {
            imports.push("encodeEnumVariant");
            imports.push("decodeEnumVariant");
        }
        imports
    }
}

/// Generate imports from @bearcove/roam-core
fn generate_imports(service: &ServiceDetail, w: &mut CodeWriter<&mut String>) {
    use crate::cw_writeln;
    use roam_schema::{ShapeKind, classify_shape, is_rx, is_tx};

    // Analyze what types are used
    let mut tracker = ImportTracker::default();
    tracker.visit_service(service);

    // Check if any method uses streaming
    let has_streaming = service.methods.iter().any(|m| {
        m.args.iter().any(|a| is_tx(a.ty) || is_rx(a.ty))
            || is_tx(m.return_type)
            || is_rx(m.return_type)
    });

    // Check if any method returns Result<T, E> (fallible methods)
    let has_fallible = service
        .methods
        .iter()
        .any(|m| matches!(classify_shape(m.return_type), ShapeKind::Result { .. }));

    // Type imports - only include what's actually used
    let type_imports = ["MethodHandler", "MethodSchema", "Caller"];
    // Connection, MessageTransport, DecodeResult are not currently used in generated code
    cw_writeln!(
        w,
        "import type {{ {} }} from \"@bearcove/roam-core\";",
        type_imports.join(", ")
    )
    .unwrap();

    // Collect runtime function imports
    let mut runtime_imports = vec![
        "encodeResultOk",
        "encodeResultErr",
        "encodeInvalidPayload",
        "decodeRpcResult",
        "encodeWithSchema",
        "decodeWithSchema",
        "helloExchangeInitiator",
        "defaultHello",
        "CallBuilder",
    ];

    // Add concat if needed
    if tracker.concat || tracker.vec || tracker.option || tracker.enum_variant {
        runtime_imports.push("concat");
    }

    // Add scalar encode/decode functions
    runtime_imports.extend(tracker.generate_scalar_imports());

    // Add composite encode/decode functions
    runtime_imports.extend(tracker.generate_composite_imports());

    // Generate the import statement
    cw_writeln!(w, "import {{").unwrap();
    {
        let _indent = w.indent();
        // Group imports nicely (8 per line max)
        for chunk in runtime_imports.chunks(6) {
            cw_writeln!(w, "{},", chunk.join(", ")).unwrap();
        }
    }
    cw_writeln!(w, "}} from \"@bearcove/roam-core\";").unwrap();

    // WebSocket transport for connect helper
    cw_writeln!(w, "import {{ connectWs }} from \"@bearcove/roam-ws\";").unwrap();

    // RpcError for fallible methods (methods returning Result<T, E>)
    if has_fallible {
        cw_writeln!(w, "import {{ RpcError }} from \"@bearcove/roam-core\";").unwrap();
    }

    if has_streaming {
        cw_writeln!(
            w,
            "import {{ Tx, Rx, createServerTx, createServerRx, bindChannels }} from \"@bearcove/roam-core\";"
        )
        .unwrap();
        cw_writeln!(
            w,
            "import type {{ ChannelId, ChannelRegistry, TaskSender, BindingSerializers, Schema }} from \"@bearcove/roam-core\";"
        )
        .unwrap();
    }
}

/// Generate request/response type aliases, skipping any that conflict with named types
fn generate_request_response_types(
    service: &ServiceDetail,
    named_types: &[(String, &'static facet_core::Shape)],
) -> String {
    use heck::ToUpperCamelCase;
    use std::collections::HashSet;
    use types::ts_type;

    // Collect just the type names for conflict checking
    let type_names: HashSet<&str> = named_types.iter().map(|(name, _)| name.as_str()).collect();

    let mut out = String::new();
    out.push_str("// Request/Response type aliases\n");

    for method in &service.methods {
        let method_name = method.method_name.to_upper_camel_case();
        let request_name = format!("{method_name}Request");
        let response_name = format!("{method_name}Response");

        // Only generate request type alias if it doesn't conflict with a named type
        if !type_names.contains(request_name.as_str()) {
            if method.args.is_empty() {
                out.push_str(&format!("export type {request_name} = [];\n"));
            } else if method.args.len() == 1 {
                let ty = ts_type(method.args[0].ty);
                out.push_str(&format!("export type {request_name} = [{ty}];\n"));
            } else {
                out.push_str(&format!("export type {request_name} = [\n"));
                for arg in &method.args {
                    let ty = ts_type(arg.ty);
                    out.push_str(&format!("  {ty}, // {}\n", arg.name));
                }
                out.push_str("];\n");
            }
        }

        // Only generate response type alias if it doesn't conflict with a named type
        if !type_names.contains(response_name.as_str()) {
            let ret_ty = ts_type(method.return_type);
            out.push_str(&format!("export type {response_name} = {ret_ty};\n"));
        }

        out.push('\n');
    }

    out
}
