//! TypeScript code generation for roam services.
//!
//! This module generates TypeScript client and server code from service definitions.
//! The generated code includes:
//! - Type definitions for all named types (structs, enums)
//! - Client interface and implementation for making RPC calls
//! - Server handler interface for implementing services
//! - Encoding/decoding logic for all types
//! - Runtime schema information for streaming channel binding

pub mod client;
pub mod decode;
pub mod encode;
pub mod http_client;
pub mod schema;
pub mod server;
pub mod types;

use crate::code_writer::CodeWriter;
use roam_schema::{MethodDetail, ServiceDetail};

pub use client::generate_client;
pub use http_client::generate_http_client;
pub use schema::generate_schemas;
pub use server::generate_server;
pub use types::{collect_named_types, generate_named_types};

/// Generate method IDs as a TypeScript constant record.
pub fn generate_method_ids(methods: &[MethodDetail]) -> String {
    use crate::render::{fq_name, hex_u64};

    let mut items = methods
        .iter()
        .map(|m| (fq_name(m), crate::method_id(m)))
        .collect::<Vec<_>>();
    items.sort_by(|a, b| a.0.cmp(&b.0));

    let mut out = String::new();
    out.push_str("// @generated by roam-codegen\n");
    out.push_str("// This file defines canonical roam method IDs.\n\n");
    out.push_str("export const METHOD_ID: Record<string, bigint> = {\n");
    for (name, id) in items {
        out.push_str(&format!("  \"{name}\": {}n,\n", hex_u64(id)));
    }
    out.push_str("} as const;\n");
    out
}

/// Generate a complete TypeScript module for a service.
///
/// This is the main entry point for TypeScript code generation.
pub fn generate_service(service: &ServiceDetail) -> String {
    use crate::code_writer::CodeWriter;
    use crate::{cw_writeln, render::hex_u64};
    use heck::ToLowerCamelCase;

    let mut output = String::new();
    let mut w = CodeWriter::with_indent_spaces(&mut output, 2);

    // Header
    cw_writeln!(w, "// @generated by roam-codegen").unwrap();
    cw_writeln!(
        w,
        "// DO NOT EDIT - regenerate with `cargo xtask codegen --typescript`"
    )
    .unwrap();
    w.blank_line().unwrap();

    // TODO: This import list should probably be in roam-core or generated more intelligently
    generate_imports(service, &mut w);
    w.blank_line().unwrap();

    // Method IDs
    cw_writeln!(w, "export const METHOD_ID = {{").unwrap();
    {
        let _indent = w.indent();
        for method in &service.methods {
            let id = crate::method_id(method);
            let method_name = method.method_name.to_lower_camel_case();
            cw_writeln!(w, "{method_name}: {}n,", hex_u64(id)).unwrap();
        }
    }
    cw_writeln!(w, "}} as const;").unwrap();
    w.blank_line().unwrap();

    // Named types (structs and enums)
    let named_types = collect_named_types(service);
    output.push_str(&generate_named_types(&named_types));

    // Type aliases for request/response
    output.push_str(&generate_request_response_types(service));

    // Client
    output.push_str(&generate_client(service));

    // Server
    output.push_str(&generate_server(service));

    // Schemas
    output.push_str(&generate_schemas(service));

    output
}

/// Generate imports from @bearcove/roam-core
fn generate_imports(service: &ServiceDetail, w: &mut CodeWriter<&mut String>) {
    use crate::cw_writeln;
    use roam_schema::{is_rx, is_tx};

    // Check if any method uses streaming
    let has_streaming = service.methods.iter().any(|m| {
        m.args.iter().any(|a| is_tx(a.ty) || is_rx(a.ty))
            || is_tx(m.return_type)
            || is_rx(m.return_type)
    });

    // Type imports
    cw_writeln!(w, "import type {{ MethodHandler, Connection, MessageTransport, DecodeResult, MethodSchema }} from \"@bearcove/roam-core\";").unwrap();

    // Runtime function imports
    cw_writeln!(w, "import {{").unwrap();
    {
        let _indent = w.indent();
        cw_writeln!(w, "encodeResultOk, encodeResultErr, encodeInvalidPayload,").unwrap();
        cw_writeln!(
            w,
            "concat, encodeVarint, decodeVarintNumber, decodeRpcResult,"
        )
        .unwrap();
        cw_writeln!(w, "encodeBool, decodeBool,").unwrap();
        cw_writeln!(w, "encodeU8, decodeU8, encodeI8, decodeI8,").unwrap();
        cw_writeln!(w, "encodeU16, decodeU16, encodeI16, decodeI16,").unwrap();
        cw_writeln!(w, "encodeU32, decodeU32, encodeI32, decodeI32,").unwrap();
        cw_writeln!(w, "encodeU64, decodeU64, encodeI64, decodeI64,").unwrap();
        cw_writeln!(w, "encodeF32, decodeF32, encodeF64, decodeF64,").unwrap();
        cw_writeln!(w, "encodeString, decodeString,").unwrap();
        cw_writeln!(w, "encodeBytes, decodeBytes,").unwrap();
        cw_writeln!(w, "encodeOption, decodeOption,").unwrap();
        cw_writeln!(w, "encodeVec, decodeVec,").unwrap();
        cw_writeln!(w, "encodeTuple2, decodeTuple2, encodeTuple3, decodeTuple3,").unwrap();
        cw_writeln!(w, "encodeEnumVariant, decodeEnumVariant,").unwrap();
    }
    cw_writeln!(w, "}} from \"@bearcove/roam-core\";").unwrap();

    if has_streaming {
        cw_writeln!(
            w,
            "import {{ Tx, Rx, createServerTx, createServerRx, bindChannels }} from \"@bearcove/roam-core\";"
        )
        .unwrap();
        cw_writeln!(
            w,
            "import type {{ ChannelId, ChannelRegistry, TaskSender, BindingSerializers, Schema }} from \"@bearcove/roam-core\";"
        )
        .unwrap();
    }
}

/// Generate request/response type aliases
fn generate_request_response_types(service: &ServiceDetail) -> String {
    use heck::ToUpperCamelCase;
    use types::ts_type;

    let mut out = String::new();
    out.push_str("// Type definitions\n");

    for method in &service.methods {
        let method_name = method.method_name.to_upper_camel_case();

        // Request type (tuple of args)
        if method.args.is_empty() {
            out.push_str(&format!("export type {method_name}Request = [];\n"));
        } else if method.args.len() == 1 {
            let ty = ts_type(method.args[0].ty);
            out.push_str(&format!("export type {method_name}Request = [{ty}];\n"));
        } else {
            out.push_str(&format!("export type {method_name}Request = [\n"));
            for arg in &method.args {
                let ty = ts_type(arg.ty);
                out.push_str(&format!("  {ty}, // {}\n", arg.name));
            }
            out.push_str("];\n");
        }

        // Response type
        let ret_ty = ts_type(method.return_type);
        out.push_str(&format!(
            "export type {method_name}Response = {ret_ty};\n\n"
        ));
    }

    out
}
