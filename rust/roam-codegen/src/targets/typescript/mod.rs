//! TypeScript code generation for roam services.
//!
//! This module generates TypeScript client and server code from service definitions.
//! The generated code includes:
//! - Type definitions for all named types (structs, enums)
//! - Client interface and implementation for making RPC calls
//! - Handler interface for implementing the service
//! - A Dispatcher class that routes calls to handler methods
//! - A service descriptor for runtime schema-driven encode/decode

pub mod client;
pub mod decode;
pub mod encode;
pub mod http_client;
pub mod schema;
pub mod server;
pub mod types;

use crate::code_writer::CodeWriter;
use roam_types::{MethodDescriptor, ServiceDescriptor};

pub use client::generate_client;
pub use http_client::generate_http_client;
pub use schema::generate_descriptor;
pub use server::generate_server;
pub use types::{collect_named_types, generate_named_types};

/// Generate method IDs as a TypeScript constant record.
pub fn generate_method_ids(methods: &[&MethodDescriptor]) -> String {
    use crate::render::{fq_name, hex_u64};

    let mut items = methods
        .iter()
        .map(|m| (fq_name(m), m.id.0))
        .collect::<Vec<_>>();
    items.sort_by(|a, b| a.0.cmp(&b.0));

    let mut out = String::new();
    out.push_str("// @generated by roam-codegen\n");
    out.push_str("// This file defines canonical roam method IDs.\n\n");
    out.push_str("export const METHOD_ID: Record<string, bigint> = {\n");
    for (name, id) in items {
        out.push_str(&format!("  \"{name}\": {}n,\n", hex_u64(id)));
    }
    out.push_str("} as const;\n");
    out
}

/// Generate a complete TypeScript module for a service.
///
/// This is the main entry point for TypeScript code generation.
pub fn generate_service(service: &ServiceDescriptor) -> String {
    use crate::code_writer::CodeWriter;
    use crate::cw_writeln;

    let mut output = String::new();
    let mut w = CodeWriter::with_indent_spaces(&mut output, 2);

    // Header
    cw_writeln!(w, "// @generated by roam-codegen").unwrap();
    cw_writeln!(
        w,
        "// DO NOT EDIT - regenerate with `cargo xtask codegen --typescript`"
    )
    .unwrap();
    w.blank_line().unwrap();

    generate_imports(service, &mut w);
    w.blank_line().unwrap();

    // Named types (structs and enums)
    let named_types = collect_named_types(service);
    output.push_str(&generate_named_types(&named_types));

    // Request/Response type aliases
    output.push_str(&generate_request_response_types(service, &named_types));

    // Client
    output.push_str(&generate_client(service));

    // Server (handler interface + dispatcher)
    output.push_str(&generate_server(service));

    // Service descriptor
    output.push_str(&generate_descriptor(service));

    output
}

/// Generate imports for the service module.
fn generate_imports(service: &ServiceDescriptor, w: &mut CodeWriter<&mut String>) {
    use crate::cw_writeln;
    use roam_types::{ShapeKind, classify_shape, is_rx, is_tx};

    // Check if any method uses channels
    let has_streaming = service.methods.iter().any(|m| {
        m.args.iter().any(|a| is_tx(a.shape) || is_rx(a.shape))
            || is_tx(m.return_shape)
            || is_rx(m.return_shape)
    });

    // Check if any method returns Result<T, E> (fallible methods)
    let has_fallible = service
        .methods
        .iter()
        .any(|m| matches!(classify_shape(m.return_shape), ShapeKind::Result { .. }));

    // Core runtime: descriptor types + Caller + CallBuilder + connection helpers
    cw_writeln!(
        w,
        "import type {{ Caller, MethodDescriptor, ServiceDescriptor, RoamCall, ChannelingDispatcher }} from \"@bearcove/roam-core\";"
    )
    .unwrap();
    cw_writeln!(
        w,
        "import {{ CallBuilder, helloExchangeInitiator, defaultHello }} from \"@bearcove/roam-core\";"
    )
    .unwrap();

    // WebSocket transport for connect helper
    cw_writeln!(w, "import {{ connectWs }} from \"@bearcove/roam-ws\";").unwrap();

    // RpcError for fallible client methods
    if has_fallible {
        cw_writeln!(w, "import {{ RpcError }} from \"@bearcove/roam-core\";").unwrap();
    }

    // Tx/Rx and bindChannels for streaming handler args and type aliases
    if has_streaming {
        cw_writeln!(
            w,
            "import {{ Tx, Rx, bindChannels }} from \"@bearcove/roam-core\";"
        )
        .unwrap();
    }
}

/// Generate request/response type aliases, skipping any that conflict with named types
fn generate_request_response_types(
    service: &ServiceDescriptor,
    named_types: &[(String, &'static facet_core::Shape)],
) -> String {
    use heck::ToUpperCamelCase;
    use std::collections::HashSet;
    use types::ts_type;

    // Collect just the type names for conflict checking
    let type_names: HashSet<&str> = named_types.iter().map(|(name, _)| name.as_str()).collect();

    let mut out = String::new();
    out.push_str("// Request/Response type aliases\n");

    for method in service.methods {
        let method_name = method.method_name.to_upper_camel_case();
        let request_name = format!("{method_name}Request");
        let response_name = format!("{method_name}Response");

        // Only generate request type alias if it doesn't conflict with a named type
        if !type_names.contains(request_name.as_str()) {
            if method.args.is_empty() {
                out.push_str(&format!("export type {request_name} = [];\n"));
            } else if method.args.len() == 1 {
                let ty = ts_type(method.args[0].shape);
                out.push_str(&format!("export type {request_name} = [{ty}];\n"));
            } else {
                out.push_str(&format!("export type {request_name} = [\n"));
                for arg in method.args {
                    let ty = ts_type(arg.shape);
                    out.push_str(&format!("  {ty}, // {}\n", arg.name));
                }
                out.push_str("];\n");
            }
        }

        // Only generate response type alias if it doesn't conflict with a named type
        if !type_names.contains(response_name.as_str()) {
            let ret_ty = ts_type(method.return_shape);
            out.push_str(&format!("export type {response_name} = {ret_ty};\n"));
        }

        out.push('\n');
    }

    out
}
