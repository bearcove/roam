use rapace_schema::{MethodDetail, ServiceDetail, TypeDetail};

use crate::render::{fq_name, hex_u64};

pub fn generate_method_ids(methods: &[MethodDetail]) -> String {
    let mut items = methods
        .iter()
        .map(|m| (fq_name(m), crate::method_id(m)))
        .collect::<Vec<_>>();
    items.sort_by(|a, b| a.0.cmp(&b.0));

    let mut out = String::new();
    out.push_str("# @generated by rapace-codegen\n");
    out.push_str("# This file defines canonical Rapace method IDs.\n\n");
    out.push_str("METHOD_ID: dict[str, int] = {\n");
    for (name, id) in items {
        out.push_str(&format!("    \"{name}\": {},\n", hex_u64(id)));
    }
    out.push_str("}\n");
    out
}

/// Generate a complete Python module for a service.
pub fn generate_service(service: &ServiceDetail) -> String {
    let mut out = String::new();
    out.push_str("# @generated by rapace-codegen\n");
    out.push_str("# DO NOT EDIT - regenerate with `cargo run -p rapace-codegen`\n\n");
    out.push_str("from abc import ABC, abstractmethod\n");
    out.push_str("from typing import Protocol\n\n");

    // Generate method IDs
    out.push_str("METHOD_ID = {\n");
    for method in &service.methods {
        let id = crate::method_id(method);
        let method_name = to_snake_case(&method.method_name);
        out.push_str(&format!("    \"{method_name}\": {},\n", hex_u64(id)));
    }
    out.push_str("}\n\n");

    // Generate client protocol
    out.push_str(&generate_client_protocol(service));

    // Generate server handler
    out.push_str(&generate_server_handler(service));

    out
}

fn generate_client_protocol(service: &ServiceDetail) -> String {
    let mut out = String::new();
    let service_name = to_pascal_case(&service.name);

    if let Some(doc) = &service.doc {
        out.push_str(&format!("\"\"\"{}\"\"\"\n\n", doc));
    }

    out.push_str(&format!("class {service_name}Client(Protocol):\n"));
    out.push_str("    \"\"\"Client protocol for calling service methods.\"\"\"\n\n");

    for method in &service.methods {
        let method_name = to_snake_case(&method.method_name);
        let args = method
            .args
            .iter()
            .map(|a| format!("{}: {}", to_snake_case(&a.name), py_type(&a.type_info)))
            .collect::<Vec<_>>()
            .join(", ");
        let ret_ty = py_type(&method.return_type);

        if let Some(doc) = &method.doc {
            out.push_str(&format!("    def {method_name}(self, {args}) -> {ret_ty}:\n"));
            out.push_str(&format!("        \"\"\"{}\"\"\"\n", doc));
            out.push_str("        ...\n\n");
        } else {
            out.push_str(&format!("    def {method_name}(self, {args}) -> {ret_ty}: ...\n\n"));
        }
    }

    out
}

fn generate_server_handler(service: &ServiceDetail) -> String {
    let mut out = String::new();
    let service_name = to_pascal_case(&service.name);

    out.push_str(&format!("class {service_name}Handler(ABC):\n"));
    out.push_str("    \"\"\"Abstract base class for implementing the service.\"\"\"\n\n");

    for method in &service.methods {
        let method_name = to_snake_case(&method.method_name);
        let args = method
            .args
            .iter()
            .map(|a| format!("{}: {}", to_snake_case(&a.name), py_type(&a.type_info)))
            .collect::<Vec<_>>()
            .join(", ");
        let ret_ty = py_type(&method.return_type);

        out.push_str("    @abstractmethod\n");
        out.push_str(&format!("    def {method_name}(self, {args}) -> {ret_ty}:\n"));
        if let Some(doc) = &method.doc {
            out.push_str(&format!("        \"\"\"{}\"\"\"\n", doc));
        }
        out.push_str("        ...\n\n");
    }

    // Generate dispatcher
    out.push_str(&format!(
        "\ndef create_{}_dispatcher(handler: {service_name}Handler):\n",
        to_snake_case(&service.name)
    ));
    out.push_str("    \"\"\"Create a dispatcher function for the service.\"\"\"\n");
    out.push_str("    def dispatch(method_id: int, payload: bytes) -> bytes:\n");
    out.push_str("        match method_id:\n");

    for method in &service.methods {
        let method_name = to_snake_case(&method.method_name);
        let id = crate::method_id(method);
        out.push_str(&format!("            case {}:\n", hex_u64(id)));
        out.push_str("                # TODO: decode payload, call handler, encode response\n");
        out.push_str(&format!(
            "                raise NotImplementedError(\"{method_name}\")\n"
        ));
    }

    out.push_str("            case _:\n");
    out.push_str("                raise ValueError(f\"Unknown method ID: {method_id}\")\n");
    out.push_str("    return dispatch\n");

    out
}

fn py_type(ty: &TypeDetail) -> String {
    match ty {
        TypeDetail::Bool => "bool".into(),
        TypeDetail::U8 | TypeDetail::U16 | TypeDetail::U32 | TypeDetail::U64 | TypeDetail::U128 => {
            "int".into()
        }
        TypeDetail::I8 | TypeDetail::I16 | TypeDetail::I32 | TypeDetail::I64 | TypeDetail::I128 => {
            "int".into()
        }
        TypeDetail::F32 | TypeDetail::F64 => "float".into(),
        TypeDetail::Char | TypeDetail::String => "str".into(),
        TypeDetail::Unit => "None".into(),
        TypeDetail::Bytes => "bytes".into(),
        TypeDetail::List(inner) => format!("list[{}]", py_type(inner)),
        TypeDetail::Option(inner) => format!("{} | None", py_type(inner)),
        TypeDetail::Array { element, .. } => format!("list[{}]", py_type(element)),
        TypeDetail::Map { key, value } => format!("dict[{}, {}]", py_type(key), py_type(value)),
        TypeDetail::Set(inner) => format!("set[{}]", py_type(inner)),
        TypeDetail::Tuple(items) => {
            let inner = items.iter().map(py_type).collect::<Vec<_>>().join(", ");
            format!("tuple[{inner}]")
        }
        TypeDetail::Stream(inner) => format!("AsyncIterator[{}]", py_type(inner)),
        TypeDetail::Struct { fields } => {
            // Use TypedDict for inline structs
            let inner = fields
                .iter()
                .map(|f| format!("\"{}\": {}", f.name, py_type(&f.type_info)))
                .collect::<Vec<_>>()
                .join(", ");
            format!("dict[{{{inner}}}]")
        }
        TypeDetail::Enum { .. } => {
            // Enums would need proper class generation
            "object".into()
        }
    }
}

fn to_snake_case(s: &str) -> String {
    let mut result = String::new();
    let mut prev_lower = false;

    for c in s.chars() {
        if c == '-' || c == '_' {
            if !result.is_empty() && !result.ends_with('_') {
                result.push('_');
            }
            prev_lower = false;
        } else if c.is_ascii_uppercase() {
            if prev_lower && !result.ends_with('_') {
                result.push('_');
            }
            result.push(c.to_ascii_lowercase());
            prev_lower = false;
        } else {
            result.push(c);
            prev_lower = c.is_ascii_lowercase();
        }
    }

    result
}

fn to_pascal_case(s: &str) -> String {
    let mut result = String::new();
    let mut capitalize_next = true;

    for c in s.chars() {
        if c == '_' || c == '-' {
            capitalize_next = true;
        } else if capitalize_next {
            result.push(c.to_ascii_uppercase());
            capitalize_next = false;
        } else {
            result.push(c);
        }
    }

    result
}
