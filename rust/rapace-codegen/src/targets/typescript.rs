use rapace_schema::{MethodDetail, ServiceDetail, TypeDetail};

use crate::render::{fq_name, hex_u64};

pub fn generate_method_ids(methods: &[MethodDetail]) -> String {
    let mut items = methods
        .iter()
        .map(|m| (fq_name(m), crate::method_id(m)))
        .collect::<Vec<_>>();
    items.sort_by(|a, b| a.0.cmp(&b.0));

    let mut out = String::new();
    out.push_str("// @generated by rapace-codegen\n");
    out.push_str("// This file defines canonical Rapace method IDs.\n\n");
    out.push_str("export const METHOD_ID: Record<string, bigint> = {\n");
    for (name, id) in items {
        out.push_str(&format!("  \"{name}\": {}n,\n", hex_u64(id)));
    }
    out.push_str("} as const;\n");
    out
}

/// Generate a complete TypeScript module for a service.
pub fn generate_service(service: &ServiceDetail) -> String {
    let mut out = String::new();
    out.push_str("// @generated by rapace-codegen\n");
    out.push_str("// DO NOT EDIT - regenerate with `cargo run -p rapace-codegen`\n\n");

    // Generate method IDs
    out.push_str("export const METHOD_ID = {\n");
    for method in &service.methods {
        let id = crate::method_id(method);
        let method_name = to_camel_case(&method.method_name);
        out.push_str(&format!("  {method_name}: {}n,\n", hex_u64(id)));
    }
    out.push_str("} as const;\n\n");

    // Generate type aliases
    out.push_str(&generate_types(service));

    // Generate client interface
    out.push_str(&generate_client_interface(service));

    // Generate server interface
    out.push_str(&generate_server_interface(service));

    out
}

fn generate_types(service: &ServiceDetail) -> String {
    let mut out = String::new();
    out.push_str("// Type definitions\n");

    for method in &service.methods {
        let method_name = to_pascal_case(&method.method_name);

        // Request type (tuple of args)
        if method.args.is_empty() {
            out.push_str(&format!("export type {method_name}Request = [];\n"));
        } else if method.args.len() == 1 {
            let ty = ts_type(&method.args[0].type_info);
            out.push_str(&format!("export type {method_name}Request = [{ty}];\n"));
        } else {
            out.push_str(&format!("export type {method_name}Request = [\n"));
            for arg in &method.args {
                let ty = ts_type(&arg.type_info);
                out.push_str(&format!("  {ty}, // {}\n", arg.name));
            }
            out.push_str("];\n");
        }

        // Response type
        let ret_ty = ts_type(&method.return_type);
        out.push_str(&format!("export type {method_name}Response = {ret_ty};\n\n"));
    }

    out
}

fn generate_client_interface(service: &ServiceDetail) -> String {
    let mut out = String::new();
    let service_name = to_pascal_case(&service.name);

    out.push_str(&format!("// Client interface for {service_name}\n"));
    out.push_str(&format!("export interface {service_name}Client {{\n"));

    for method in &service.methods {
        let method_name = to_camel_case(&method.method_name);
        let args = method
            .args
            .iter()
            .map(|a| format!("{}: {}", to_camel_case(&a.name), ts_type(&a.type_info)))
            .collect::<Vec<_>>()
            .join(", ");
        let ret_ty = ts_type(&method.return_type);

        if let Some(doc) = &method.doc {
            out.push_str(&format!("  /** {} */\n", doc));
        }
        out.push_str(&format!("  {method_name}({args}): Promise<{ret_ty}>;\n"));
    }

    out.push_str("}\n\n");
    out
}

fn generate_server_interface(service: &ServiceDetail) -> String {
    let mut out = String::new();
    let service_name = to_pascal_case(&service.name);

    out.push_str(&format!("// Server handler interface for {service_name}\n"));
    out.push_str(&format!("export interface {service_name}Handler {{\n"));

    for method in &service.methods {
        let method_name = to_camel_case(&method.method_name);
        let args = method
            .args
            .iter()
            .map(|a| format!("{}: {}", to_camel_case(&a.name), ts_type(&a.type_info)))
            .collect::<Vec<_>>()
            .join(", ");
        let ret_ty = ts_type(&method.return_type);

        out.push_str(&format!(
            "  {method_name}({args}): Promise<{ret_ty}> | {ret_ty};\n"
        ));
    }

    out.push_str("}\n\n");

    // Generate dispatcher function
    out.push_str(&format!(
        "export function create{service_name}Dispatcher(handler: {service_name}Handler) {{\n"
    ));
    out.push_str("  return async (methodId: bigint, payload: Uint8Array): Promise<Uint8Array> => {\n");
    out.push_str("    switch (methodId) {\n");

    for method in &service.methods {
        let method_name = to_camel_case(&method.method_name);
        let id = crate::method_id(method);
        out.push_str(&format!("      case {}n: {{\n", hex_u64(id)));
        out.push_str("        // TODO: decode payload, call handler, encode response\n");
        out.push_str(&format!(
            "        throw new Error('{method_name}: not yet implemented');\n"
        ));
        out.push_str("      }\n");
    }

    out.push_str("      default:\n");
    out.push_str("        throw new Error(`Unknown method ID: ${methodId}`);\n");
    out.push_str("    }\n");
    out.push_str("  };\n");
    out.push_str("}\n");

    out
}

fn ts_type(ty: &TypeDetail) -> String {
    match ty {
        TypeDetail::Bool => "boolean".into(),
        TypeDetail::U8 | TypeDetail::U16 | TypeDetail::U32 | TypeDetail::I8 | TypeDetail::I16 | TypeDetail::I32 | TypeDetail::F32 | TypeDetail::F64 => "number".into(),
        TypeDetail::U64 | TypeDetail::U128 | TypeDetail::I64 | TypeDetail::I128 => "bigint".into(),
        TypeDetail::Char | TypeDetail::String => "string".into(),
        TypeDetail::Unit => "void".into(),
        TypeDetail::Bytes => "Uint8Array".into(),
        TypeDetail::List(inner) => format!("{}[]", ts_type(inner)),
        TypeDetail::Option(inner) => format!("{} | null", ts_type(inner)),
        TypeDetail::Array { element, len } => format!("[{}; {}]", ts_type(element), len),
        TypeDetail::Map { key, value } => format!("Map<{}, {}>", ts_type(key), ts_type(value)),
        TypeDetail::Set(inner) => format!("Set<{}>", ts_type(inner)),
        TypeDetail::Tuple(items) => {
            let inner = items.iter().map(ts_type).collect::<Vec<_>>().join(", ");
            format!("[{inner}]")
        }
        TypeDetail::Stream(inner) => format!("AsyncIterable<{}>", ts_type(inner)),
        TypeDetail::Struct { fields } => {
            let inner = fields
                .iter()
                .map(|f| format!("{}: {}", f.name, ts_type(&f.type_info)))
                .collect::<Vec<_>>()
                .join("; ");
            format!("{{ {inner} }}")
        }
        TypeDetail::Enum { variants } => {
            // Simple union type for now
            variants
                .iter()
                .map(|v| format!("{{ tag: '{}' }}", v.name))
                .collect::<Vec<_>>()
                .join(" | ")
        }
    }
}

fn to_camel_case(s: &str) -> String {
    let mut result = String::new();
    let mut capitalize_next = false;

    for c in s.chars() {
        if c == '_' || c == '-' {
            capitalize_next = true;
        } else if capitalize_next {
            result.push(c.to_ascii_uppercase());
            capitalize_next = false;
        } else {
            result.push(c);
        }
    }

    // Ensure first char is lowercase
    let mut chars = result.chars();
    match chars.next() {
        None => String::new(),
        Some(first) => first.to_lowercase().chain(chars).collect(),
    }
}

fn to_pascal_case(s: &str) -> String {
    let camel = to_camel_case(s);
    let mut chars = camel.chars();
    match chars.next() {
        None => String::new(),
        Some(first) => first.to_uppercase().chain(chars).collect(),
    }
}
