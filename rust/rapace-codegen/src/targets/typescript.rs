use heck::{ToLowerCamelCase, ToUpperCamelCase};
use rapace_schema::{MethodDetail, ServiceDetail, TypeDetail};

use crate::render::{fq_name, hex_u64};

pub fn generate_method_ids(methods: &[MethodDetail]) -> String {
    let mut items = methods
        .iter()
        .map(|m| (fq_name(m), crate::method_id(m)))
        .collect::<Vec<_>>();
    items.sort_by(|a, b| a.0.cmp(&b.0));

    let mut out = String::new();
    out.push_str("// @generated by rapace-codegen\n");
    out.push_str("// This file defines canonical Rapace method IDs.\n\n");
    out.push_str("export const METHOD_ID: Record<string, bigint> = {\n");
    for (name, id) in items {
        out.push_str(&format!("  \"{name}\": {}n,\n", hex_u64(id)));
    }
    out.push_str("} as const;\n");
    out
}

/// Generate a complete TypeScript module for a service.
pub fn generate_service(service: &ServiceDetail) -> String {
    let mut out = String::new();
    out.push_str("// @generated by rapace-codegen\n");
    out.push_str("// DO NOT EDIT - regenerate with `cargo xtask codegen --typescript`\n\n");

    // Import runtime primitives
    out.push_str("import type { MethodHandler } from \"../src/index.ts\";\n");
    out.push_str("import { encodeResultOk, encodeResultErr, encodeInvalidPayload } from \"../src/index.ts\";\n");
    out.push_str("import { encodeString, decodeString } from \"../src/index.ts\";\n\n");

    // Generate method IDs
    out.push_str("export const METHOD_ID = {\n");
    for method in &service.methods {
        let id = crate::method_id(method);
        let method_name = method.method_name.to_lower_camel_case();
        out.push_str(&format!("  {method_name}: {}n,\n", hex_u64(id)));
    }
    out.push_str("} as const;\n\n");

    // Generate type aliases
    out.push_str(&generate_types(service));

    // Generate client interface
    out.push_str(&generate_client_interface(service));

    // Generate server interface and handlers
    out.push_str(&generate_server_interface(service));

    out
}

fn generate_types(service: &ServiceDetail) -> String {
    let mut out = String::new();
    out.push_str("// Type definitions\n");

    for method in &service.methods {
        let method_name = method.method_name.to_upper_camel_case();

        // Request type (tuple of args)
        if method.args.is_empty() {
            out.push_str(&format!("export type {method_name}Request = [];\n"));
        } else if method.args.len() == 1 {
            let ty = ts_type(&method.args[0].type_info);
            out.push_str(&format!("export type {method_name}Request = [{ty}];\n"));
        } else {
            out.push_str(&format!("export type {method_name}Request = [\n"));
            for arg in &method.args {
                let ty = ts_type(&arg.type_info);
                out.push_str(&format!("  {ty}, // {}\n", arg.name));
            }
            out.push_str("];\n");
        }

        // Response type
        let ret_ty = ts_type(&method.return_type);
        out.push_str(&format!("export type {method_name}Response = {ret_ty};\n\n"));
    }

    out
}

fn generate_client_interface(service: &ServiceDetail) -> String {
    let mut out = String::new();
    let service_name = service.name.to_upper_camel_case();

    out.push_str(&format!("// Client interface for {service_name}\n"));
    out.push_str(&format!("export interface {service_name}Client {{\n"));

    for method in &service.methods {
        let method_name = method.method_name.to_lower_camel_case();
        let args = method
            .args
            .iter()
            .map(|a| format!("{}: {}", a.name.to_lower_camel_case(), ts_type(&a.type_info)))
            .collect::<Vec<_>>()
            .join(", ");
        let ret_ty = ts_type(&method.return_type);

        if let Some(doc) = &method.doc {
            out.push_str(&format!("  /** {} */\n", doc));
        }
        out.push_str(&format!("  {method_name}({args}): Promise<{ret_ty}>;\n"));
    }

    out.push_str("}\n\n");
    out
}

fn generate_server_interface(service: &ServiceDetail) -> String {
    let mut out = String::new();
    let service_name = service.name.to_upper_camel_case();

    out.push_str(&format!("// Server handler interface for {service_name}\n"));
    out.push_str(&format!("export interface {service_name}Handler {{\n"));

    for method in &service.methods {
        let method_name = method.method_name.to_lower_camel_case();
        let args = method
            .args
            .iter()
            .map(|a| format!("{}: {}", a.name.to_lower_camel_case(), ts_type(&a.type_info)))
            .collect::<Vec<_>>()
            .join(", ");
        let ret_ty = ts_type(&method.return_type);

        out.push_str(&format!(
            "  {method_name}({args}): Promise<{ret_ty}> | {ret_ty};\n"
        ));
    }

    out.push_str("}\n\n");

    // Generate method handlers map
    out.push_str(&format!("// Method handlers for {service_name}\n"));
    out.push_str(&format!("export const {}_methodHandlers = new Map<bigint, MethodHandler<{service_name}Handler>>([\n", service_name.to_lower_camel_case()));

    for method in &service.methods {
        let method_name = method.method_name.to_lower_camel_case();
        let method_name_upper = method.method_name.to_upper_camel_case();
        let id = crate::method_id(method);

        out.push_str(&format!("  [{}n, async (handler, payload) => {{\n", hex_u64(id)));
        out.push_str("    try {\n");

        // Decode arguments
        if method.args.len() == 1 && matches!(method.args[0].type_info, TypeDetail::String) {
            // Single string argument - simple case for Echo service
            out.push_str("      const decoded = decodeString(payload, 0);\n");
            out.push_str("      if (decoded.next !== payload.length) throw new Error(\"args: trailing bytes\");\n");
            let arg_name = method.args[0].name.to_lower_camel_case();
            out.push_str(&format!("      const {arg_name} = decoded.value;\n"));
        } else {
            // TODO: Handle other argument types
            out.push_str("      // TODO: decode arguments for complex types\n");
            out.push_str("      throw new Error(\"Complex argument decoding not yet implemented\");\n");
        }

        // Call handler
        let arg_names = method.args.iter()
            .map(|a| a.name.to_lower_camel_case())
            .collect::<Vec<_>>()
            .join(", ");
        out.push_str(&format!("      const result = await handler.{method_name}({arg_names});\n"));

        // Encode response
        if matches!(method.return_type, TypeDetail::String) {
            out.push_str("      return encodeResultOk(encodeString(result));\n");
        } else {
            // TODO: Handle other return types
            out.push_str("      // TODO: encode response for complex types\n");
            out.push_str("      throw new Error(\"Complex response encoding not yet implemented\");\n");
        }

        out.push_str("    } catch (e) {\n");
        out.push_str("      return encodeResultErr(encodeInvalidPayload());\n");
        out.push_str("    }\n");
        out.push_str("  }],\n");
    }

    out.push_str("]);\n");

    out
}

fn ts_type(ty: &TypeDetail) -> String {
    match ty {
        TypeDetail::Bool => "boolean".into(),
        TypeDetail::U8 | TypeDetail::U16 | TypeDetail::U32 | TypeDetail::I8 | TypeDetail::I16 | TypeDetail::I32 | TypeDetail::F32 | TypeDetail::F64 => "number".into(),
        TypeDetail::U64 | TypeDetail::U128 | TypeDetail::I64 | TypeDetail::I128 => "bigint".into(),
        TypeDetail::Char | TypeDetail::String => "string".into(),
        TypeDetail::Unit => "void".into(),
        TypeDetail::Bytes => "Uint8Array".into(),
        TypeDetail::List(inner) => format!("{}[]", ts_type(inner)),
        TypeDetail::Option(inner) => format!("{} | null", ts_type(inner)),
        TypeDetail::Array { element, len } => format!("[{}; {}]", ts_type(element), len),
        TypeDetail::Map { key, value } => format!("Map<{}, {}>", ts_type(key), ts_type(value)),
        TypeDetail::Set(inner) => format!("Set<{}>", ts_type(inner)),
        TypeDetail::Tuple(items) => {
            let inner = items.iter().map(ts_type).collect::<Vec<_>>().join(", ");
            format!("[{inner}]")
        }
        TypeDetail::Stream(inner) => format!("AsyncIterable<{}>", ts_type(inner)),
        TypeDetail::Struct { fields } => {
            let inner = fields
                .iter()
                .map(|f| format!("{}: {}", f.name, ts_type(&f.type_info)))
                .collect::<Vec<_>>()
                .join("; ");
            format!("{{ {inner} }}")
        }
        TypeDetail::Enum { variants } => {
            // Simple union type for now
            variants
                .iter()
                .map(|v| format!("{{ tag: '{}' }}", v.name))
                .collect::<Vec<_>>()
                .join(" | ")
        }
    }
}
