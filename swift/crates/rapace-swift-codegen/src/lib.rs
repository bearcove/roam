//! Swift code generator for rapace services.
//!
//! This crate generates Swift client code from rapace service definitions
//! using facet's Shape introspection.
//!
//! # Usage
//!
//! ```ignore
//! use rapace_swift_codegen::SwiftCodegen;
//! use rapace::registry::ServiceRegistry;
//!
//! // Register your services first
//! ServiceRegistry::with_global_mut(|registry| {
//!     my_proto::my_service_register(registry);
//! });
//!
//! // Generate Swift code
//! let mut codegen = SwiftCodegen::new();
//! ServiceRegistry::with_global(|registry| {
//!     codegen.generate_from_registry(registry);
//! });
//!
//! // Write to file
//! std::fs::write("Generated.swift", codegen.output()).unwrap();
//! ```

use facet_core::{Def, ScalarType, Shape, StructKind, Type, UserType};
use rapace::registry::{MethodEntry, ServiceEntry, ServiceRegistry};
use std::collections::HashSet;
use std::fmt::Write;

/// Swift code generator for rapace services.
pub struct SwiftCodegen {
    output: String,
    generated_types: HashSet<&'static str>,
    indent: usize,
}

impl SwiftCodegen {
    /// Create a new Swift codegen instance.
    pub fn new() -> Self {
        Self {
            output: String::new(),
            generated_types: HashSet::new(),
            indent: 0,
        }
    }

    /// Get the generated Swift code.
    pub fn output(&self) -> &str {
        &self.output
    }

    /// Consume and return the generated Swift code.
    pub fn into_output(self) -> String {
        self.output
    }

    /// Generate Swift code from the service registry.
    pub fn generate_from_registry(&mut self, registry: &ServiceRegistry) {
        self.write_header();

        // First pass: collect all types that need to be generated
        let mut types_to_generate: Vec<&'static Shape> = Vec::new();
        for service in registry.services() {
            for method in service.iter_methods() {
                self.collect_types(method.request_shape, &mut types_to_generate);
                self.collect_types(method.response_shape, &mut types_to_generate);
            }
        }

        // Generate types in dependency order (simple types first)
        // For now, just generate them in collected order
        self.writeln("// MARK: - Types\n");
        for shape in types_to_generate {
            self.generate_type(shape);
        }

        // Generate client classes
        self.writeln("\n// MARK: - Clients\n");
        for service in registry.services() {
            self.generate_client(service);
        }
    }

    fn write_header(&mut self) {
        self.writeln("// Generated by rapace-swift-codegen");
        self.writeln("// DO NOT EDIT");
        self.writeln("");
        self.writeln("import Foundation");
        self.writeln("import Rapace");
        self.writeln("import Postcard");
        self.writeln("");
    }

    fn collect_types(&mut self, shape: &'static Shape, types: &mut Vec<&'static Shape>) {
        // Skip if already collected
        if self.generated_types.contains(shape.type_identifier) {
            return;
        }

        // Handle tuple types (collect inner types but don't generate the tuple itself)
        if shape.type_identifier.starts_with('(') {
            if let Type::User(UserType::Struct(s)) = &shape.ty {
                for field in s.fields.iter() {
                    self.collect_types(field.shape(), types);
                }
            }
            return;
        }

        // Check if this is a type we need to generate
        match &shape.ty {
            Type::User(UserType::Struct(_)) | Type::User(UserType::Enum(_)) => {
                // Recursively collect nested types first
                self.collect_nested_types(shape, types);

                // Then add this type
                if !self.generated_types.contains(shape.type_identifier) {
                    self.generated_types.insert(shape.type_identifier);
                    types.push(shape);
                }
            }
            _ => {
                // For container types, collect inner types
                self.collect_nested_types(shape, types);
            }
        }
    }

    fn collect_nested_types(&mut self, shape: &'static Shape, types: &mut Vec<&'static Shape>) {
        match &shape.def {
            Def::Option(opt) => self.collect_types(opt.t(), types),
            Def::List(list) => self.collect_types(list.t(), types),
            Def::Map(map) => {
                self.collect_types(map.k(), types);
                self.collect_types(map.v(), types);
            }
            Def::Array(arr) => self.collect_types(arr.t(), types),
            Def::Result(res) => {
                self.collect_types(res.t(), types);
                self.collect_types(res.e(), types);
            }
            _ => {}
        }

        // Also check struct/enum fields
        match &shape.ty {
            Type::User(UserType::Struct(s)) => {
                for field in s.fields.iter() {
                    self.collect_types(field.shape(), types);
                }
            }
            Type::User(UserType::Enum(e)) => {
                for variant in e.variants.iter() {
                    for field in variant.data.fields.iter() {
                        self.collect_types(field.shape(), types);
                    }
                }
            }
            _ => {}
        }
    }

    fn generate_type(&mut self, shape: &'static Shape) {
        // Skip unit type
        if shape.type_identifier == "()" {
            return;
        }

        // Skip tuple types (they start with '(')
        if shape.type_identifier.starts_with('(') {
            return;
        }

        match &shape.ty {
            Type::User(UserType::Struct(struct_type)) => {
                self.generate_struct(shape.type_identifier, struct_type);
            }
            Type::User(UserType::Enum(enum_type)) => {
                self.generate_enum(shape.type_identifier, enum_type);
            }
            _ => {}
        }
    }

    fn generate_struct(
        &mut self,
        name: &str,
        struct_type: &facet_core::StructType,
    ) {
        // Clean up the name (remove module path)
        let swift_name = clean_type_name(name);

        self.writeln(&format!("public struct {}: PostcardEncodable, Sendable {{", swift_name));
        self.indent += 1;

        // Generate fields
        for field in struct_type.fields.iter() {
            let swift_type = self.shape_to_swift_type(field.shape());
            self.writeln(&format!("public var {}: {}", field.name, swift_type));
        }

        self.writeln("");

        // Generate init
        let params: Vec<String> = struct_type
            .fields
            .iter()
            .map(|f| format!("{}: {}", f.name, self.shape_to_swift_type(f.shape())))
            .collect();

        self.writeln(&format!("public init({}) {{", params.join(", ")));
        self.indent += 1;
        for field in struct_type.fields.iter() {
            self.writeln(&format!("self.{} = {}", field.name, field.name));
        }
        self.indent -= 1;
        self.writeln("}");

        self.writeln("");

        // Generate encode method
        self.writeln("public func encode(to encoder: inout PostcardEncoder) {");
        self.indent += 1;
        for field in struct_type.fields.iter() {
            self.generate_encode_field(field.name, field.shape());
        }
        self.indent -= 1;
        self.writeln("}");

        self.indent -= 1;
        self.writeln("}");
        self.writeln("");
    }

    fn generate_enum(
        &mut self,
        name: &str,
        enum_type: &facet_core::EnumType,
    ) {
        let swift_name = clean_type_name(name);

        self.writeln(&format!("public enum {}: PostcardEncodable, Sendable {{", swift_name));
        self.indent += 1;

        // Generate cases
        for variant in enum_type.variants.iter() {
            if variant.data.fields.is_empty() {
                // Unit variant
                self.writeln(&format!("case {}", to_camel_case(variant.name)));
            } else if variant.data.kind == StructKind::Tuple && variant.data.fields.len() == 1 {
                // Newtype variant
                let field = &variant.data.fields[0];
                let swift_type = self.shape_to_swift_type(field.shape());
                self.writeln(&format!("case {}({})", to_camel_case(variant.name), swift_type));
            } else {
                // Struct variant
                let params: Vec<String> = variant
                    .data
                    .fields
                    .iter()
                    .map(|f| format!("{}: {}", f.name, self.shape_to_swift_type(f.shape())))
                    .collect();
                self.writeln(&format!(
                    "case {}({})",
                    to_camel_case(variant.name),
                    params.join(", ")
                ));
            }
        }

        self.writeln("");

        // Generate encode method
        self.writeln("public func encode(to encoder: inout PostcardEncoder) {");
        self.indent += 1;
        self.writeln("switch self {");
        for (idx, variant) in enum_type.variants.iter().enumerate() {
            let case_name = to_camel_case(variant.name);
            if variant.data.fields.is_empty() {
                self.writeln(&format!("case .{}:", case_name));
                self.indent += 1;
                self.writeln(&format!("encoder.encode(UInt32({}))", idx));
                self.indent -= 1;
            } else if variant.data.kind == StructKind::Tuple && variant.data.fields.len() == 1 {
                self.writeln(&format!("case .{}(let value):", case_name));
                self.indent += 1;
                self.writeln(&format!("encoder.encode(UInt32({}))", idx));
                let field = &variant.data.fields[0];
                self.generate_encode_value("value", field.shape());
                self.indent -= 1;
            } else {
                let bindings: Vec<String> = variant
                    .data
                    .fields
                    .iter()
                    .map(|f| f.name.to_string())
                    .collect();
                self.writeln(&format!(
                    "case .{}(let {}):",
                    case_name,
                    bindings.join(", let ")
                ));
                self.indent += 1;
                self.writeln(&format!("encoder.encode(UInt32({}))", idx));
                for field in variant.data.fields.iter() {
                    self.generate_encode_value(field.name, field.shape());
                }
                self.indent -= 1;
            }
        }
        self.writeln("}");
        self.indent -= 1;
        self.writeln("}");

        self.indent -= 1;
        self.writeln("}");
        self.writeln("");
    }

    fn generate_encode_field(&mut self, name: &str, shape: &'static Shape) {
        self.generate_encode_value(name, shape);
    }

    fn generate_encode_value(&mut self, expr: &str, shape: &'static Shape) {
        // Handle container types
        match &shape.def {
            Def::Option(_opt) => {
                self.writeln(&format!(
                    "encoder.encode({}, using: {{ enc, val in val.encode(to: &enc) }})",
                    expr
                ));
                return;
            }
            Def::List(list) => {
                let item_shape = list.t();
                // Vec<u8> and Vec<String> have direct encode methods
                if is_u8_type(item_shape) || is_string_type(item_shape) {
                    self.writeln(&format!("encoder.encode({})", expr));
                } else {
                    self.writeln(&format!(
                        "encoder.encode({}, using: {{ enc, val in val.encode(to: &enc) }})",
                        expr
                    ));
                }
                return;
            }
            _ => {}
        }

        // Handle scalar types
        if shape.scalar_type().is_some() {
            self.writeln(&format!("encoder.encode({})", expr));
            return;
        }

        // Handle struct/enum types (they implement PostcardEncodable)
        match &shape.ty {
            Type::User(UserType::Struct(_)) | Type::User(UserType::Enum(_)) => {
                self.writeln(&format!("{}.encode(to: &encoder)", expr));
            }
            _ => {
                self.writeln(&format!("encoder.encode({})", expr));
            }
        }
    }

    fn generate_client(&mut self, service: &ServiceEntry) {
        let class_name = format!("{}Client", service.name);

        self.writeln(&format!("public actor {} {{", class_name));
        self.indent += 1;

        self.writeln("private let client: RapaceClient");
        self.writeln("");

        // Constructor
        self.writeln("public init(client: RapaceClient) {");
        self.indent += 1;
        self.writeln("self.client = client");
        self.indent -= 1;
        self.writeln("}");
        self.writeln("");

        // Convenience constructor
        self.writeln("public init(host: String, port: UInt16) async throws {");
        self.indent += 1;
        self.writeln("self.client = try await RapaceClient(host: host, port: port)");
        self.indent -= 1;
        self.writeln("}");
        self.writeln("");

        // Generate method stubs
        for method in service.iter_methods() {
            self.generate_method(service.name, method);
        }

        self.indent -= 1;
        self.writeln("}");
        self.writeln("");
    }

    fn generate_method(&mut self, service_name: &str, method: &MethodEntry) {
        let method_id = method.id.0;
        let request_type = self.shape_to_swift_type(method.request_shape);
        let response_type = self.shape_to_swift_type(method.response_shape);

        // Build parameter list
        let params = if method.args.is_empty() {
            String::new()
        } else if method.args.len() == 1 {
            format!("_ {}: {}", method.args[0].name, request_type)
        } else {
            method
                .args
                .iter()
                .map(|arg| format!("{}: {}", arg.name, self.arg_type_to_swift(&arg.type_name)))
                .collect::<Vec<_>>()
                .join(", ")
        };

        if method.is_streaming {
            // Streaming method - TODO: implement properly
            self.writeln(&format!(
                "// TODO: Streaming method {}",
                method.name
            ));
            self.writeln(&format!(
                "// public func {}({}) async throws -> AsyncStream<{}> {{ ... }}",
                to_camel_case(method.name),
                params,
                response_type
            ));
        } else {
            // Unary method
            self.writeln(&format!(
                "public func {}({}) async throws -> {} {{",
                to_camel_case(method.name),
                params,
                response_type
            ));
            self.indent += 1;

            // Encode request
            if method.args.is_empty() {
                self.writeln("let encoder = PostcardEncoder()");
            } else {
                self.writeln("var encoder = PostcardEncoder()");
            }

            if method.args.len() == 1 {
                // Single argument - encode it directly
                let arg = &method.args[0];
                self.generate_encode_value(arg.name, method.request_shape);
            } else if method.args.len() > 1 {
                // Multiple arguments - encode each
                for arg in &method.args {
                    self.writeln(&format!("encoder.encode({})", arg.name));
                }
            }

            self.writeln("");
            self.writeln(&format!(
                "let response = try await client.call(methodId: 0x{:08X}, requestPayload: encoder.bytes)",
                method_id
            ));
            self.writeln("");

            // Decode response
            self.writeln("var responseData = Data(response)");
            self.generate_decode_return(method.response_shape);

            self.indent -= 1;
            self.writeln("}");
        }
        self.writeln("");
    }

    fn generate_decode_return(&mut self, shape: &'static Shape) {
        // Handle unit type - no decoding needed
        if shape.type_identifier == "()" {
            self.writeln("return");
            return;
        }

        // Handle container types
        match &shape.def {
            Def::Option(opt) => {
                let inner_type = self.shape_to_swift_type(opt.t());
                self.writeln("let tag = responseData.removeFirst()");
                self.writeln("if tag == 0 {");
                self.indent += 1;
                self.writeln("return nil");
                self.indent -= 1;
                self.writeln("} else {");
                self.indent += 1;
                self.generate_decode_value(opt.t(), "inner");
                self.writeln("return inner");
                self.indent -= 1;
                self.writeln("}");
                return;
            }
            _ => {}
        }

        // Handle scalar types
        if let Some(scalar) = shape.scalar_type() {
            match scalar {
                ScalarType::String | ScalarType::Str | ScalarType::CowStr => {
                    self.writeln("let len = try decodeVarint(from: &responseData)");
                    self.writeln("let bytes = responseData.prefix(Int(len))");
                    self.writeln("return String(data: Data(bytes), encoding: .utf8) ?? \"\"");
                }
                ScalarType::Bool => {
                    self.writeln("return responseData.removeFirst() != 0");
                }
                ScalarType::I8 => {
                    self.writeln("return Int8(bitPattern: responseData.removeFirst())");
                }
                ScalarType::U8 => {
                    self.writeln("return responseData.removeFirst()");
                }
                ScalarType::I16 | ScalarType::I32 | ScalarType::I64 => {
                    let swift_type = scalar_to_swift(scalar);
                    self.writeln(&format!(
                        "return {}(try decodeSignedVarint(from: &responseData))",
                        swift_type
                    ));
                }
                ScalarType::U16 | ScalarType::U32 | ScalarType::U64 => {
                    let swift_type = scalar_to_swift(scalar);
                    self.writeln(&format!(
                        "return {}(try decodeVarint(from: &responseData))",
                        swift_type
                    ));
                }
                ScalarType::F32 => {
                    self.writeln("let bytes = responseData.prefix(4)");
                    self.writeln("responseData = responseData.dropFirst(4)");
                    self.writeln(
                        "return bytes.withUnsafeBytes { $0.load(as: Float.self) }",
                    );
                }
                ScalarType::F64 => {
                    self.writeln("let bytes = responseData.prefix(8)");
                    self.writeln("responseData = responseData.dropFirst(8)");
                    self.writeln(
                        "return bytes.withUnsafeBytes { $0.load(as: Double.self) }",
                    );
                }
                _ => {
                    self.writeln("// TODO: decode this type");
                    self.writeln("fatalError(\"Not implemented\")");
                }
            }
            return;
        }

        // Handle struct types
        match &shape.ty {
            Type::User(UserType::Struct(s)) => {
                let type_name = clean_type_name(shape.type_identifier);
                // Decode each field
                for field in s.fields.iter() {
                    self.generate_decode_value(field.shape(), field.name);
                }
                // Construct the struct
                let field_args: Vec<String> = s
                    .fields
                    .iter()
                    .map(|f| format!("{}: {}", f.name, f.name))
                    .collect();
                self.writeln(&format!("return {}({})", type_name, field_args.join(", ")));
            }
            Type::User(UserType::Enum(e)) => {
                let type_name = clean_type_name(shape.type_identifier);
                self.writeln("let variantIndex = try decodeVarint(from: &responseData)");
                self.writeln("switch variantIndex {");
                for (idx, variant) in e.variants.iter().enumerate() {
                    let case_name = to_camel_case(variant.name);
                    self.writeln(&format!("case {}:", idx));
                    self.indent += 1;
                    if variant.data.fields.is_empty() {
                        self.writeln(&format!("return .{}", case_name));
                    } else if variant.data.kind == StructKind::Tuple && variant.data.fields.len() == 1 {
                        let field = &variant.data.fields[0];
                        self.generate_decode_value(field.shape(), "value");
                        self.writeln(&format!("return .{}(value)", case_name));
                    } else {
                        for field in variant.data.fields.iter() {
                            self.generate_decode_value(field.shape(), field.name);
                        }
                        let field_args: Vec<String> = variant
                            .data
                            .fields
                            .iter()
                            .map(|f| format!("{}: {}", f.name, f.name))
                            .collect();
                        self.writeln(&format!("return .{}({})", case_name, field_args.join(", ")));
                    }
                    self.indent -= 1;
                }
                self.writeln("default:");
                self.indent += 1;
                self.writeln(&format!("fatalError(\"Unknown {} variant: \\(variantIndex)\")", type_name));
                self.indent -= 1;
                self.writeln("}");
            }
            _ => {
                self.writeln("// TODO: decode this type");
                self.writeln("fatalError(\"Not implemented\")");
            }
        }
    }

    fn generate_decode_value(&mut self, shape: &'static Shape, var_name: &str) {
        // Handle container types
        match &shape.def {
            Def::Option(opt) => {
                let inner_type = self.shape_to_swift_type(opt.t());
                self.writeln(&format!("let {}: {}?", var_name, inner_type));
                self.writeln("let optTag = responseData.removeFirst()");
                self.writeln("if optTag == 0 {");
                self.indent += 1;
                self.writeln(&format!("{} = nil", var_name));
                self.indent -= 1;
                self.writeln("} else {");
                self.indent += 1;
                self.generate_decode_value(opt.t(), &format!("{}_inner", var_name));
                self.writeln(&format!("{} = {}_inner", var_name, var_name));
                self.indent -= 1;
                self.writeln("}");
                return;
            }
            Def::List(list) => {
                let item_shape = list.t();
                // Vec<u8> is decoded as raw bytes
                if is_u8_type(item_shape) {
                    self.writeln(&format!("let {}_len = try decodeVarint(from: &responseData)", var_name));
                    self.writeln(&format!("let {} = Array(responseData.prefix(Int({}_len)))", var_name, var_name));
                    self.writeln(&format!("responseData = responseData.dropFirst(Int({}_len))", var_name));
                } else {
                    let item_type = self.shape_to_swift_type(item_shape);
                    self.writeln(&format!("let {}_count = try decodeVarint(from: &responseData)", var_name));
                    self.writeln(&format!("var {}: [{}] = []", var_name, item_type));
                    self.writeln(&format!("for _ in 0..<{}_count {{", var_name));
                    self.indent += 1;
                    self.generate_decode_value(item_shape, &format!("{}_item", var_name));
                    self.writeln(&format!("{}.append({}_item)", var_name, var_name));
                    self.indent -= 1;
                    self.writeln("}");
                }
                return;
            }
            _ => {}
        }

        // Handle scalar types
        if let Some(scalar) = shape.scalar_type() {
            let swift_type = scalar_to_swift(scalar);
            match scalar {
                ScalarType::String | ScalarType::Str | ScalarType::CowStr => {
                    self.writeln(&format!("let {}_len = try decodeVarint(from: &responseData)", var_name));
                    self.writeln(&format!("let {}_bytes = responseData.prefix(Int({}_len))", var_name, var_name));
                    self.writeln(&format!("responseData = responseData.dropFirst(Int({}_len))", var_name));
                    self.writeln(&format!(
                        "let {} = String(data: Data({}_bytes), encoding: .utf8) ?? \"\"",
                        var_name, var_name
                    ));
                }
                ScalarType::Bool => {
                    self.writeln(&format!("let {} = responseData.removeFirst() != 0", var_name));
                }
                ScalarType::I8 => {
                    self.writeln(&format!(
                        "let {} = Int8(bitPattern: responseData.removeFirst())",
                        var_name
                    ));
                }
                ScalarType::U8 => {
                    self.writeln(&format!("let {} = responseData.removeFirst()", var_name));
                }
                ScalarType::I16 | ScalarType::I32 | ScalarType::I64 => {
                    self.writeln(&format!(
                        "let {} = {}(try decodeSignedVarint(from: &responseData))",
                        var_name, swift_type
                    ));
                }
                ScalarType::U16 | ScalarType::U32 | ScalarType::U64 => {
                    self.writeln(&format!(
                        "let {} = {}(try decodeVarint(from: &responseData))",
                        var_name, swift_type
                    ));
                }
                ScalarType::F32 => {
                    self.writeln(&format!("let {}_bytes = responseData.prefix(4)", var_name));
                    self.writeln("responseData = responseData.dropFirst(4)");
                    self.writeln(&format!(
                        "let {} = {}_bytes.withUnsafeBytes {{ $0.load(as: Float.self) }}",
                        var_name, var_name
                    ));
                }
                ScalarType::F64 => {
                    self.writeln(&format!("let {}_bytes = responseData.prefix(8)", var_name));
                    self.writeln("responseData = responseData.dropFirst(8)");
                    self.writeln(&format!(
                        "let {} = {}_bytes.withUnsafeBytes {{ $0.load(as: Double.self) }}",
                        var_name, var_name
                    ));
                }
                _ => {
                    self.writeln(&format!("let {}: {} = 0 // TODO", var_name, swift_type));
                }
            }
            return;
        }

        // Handle struct/enum types
        match &shape.ty {
            Type::User(UserType::Struct(s)) => {
                let type_name = clean_type_name(shape.type_identifier);
                // Decode each field
                for field in s.fields.iter() {
                    self.generate_decode_value(field.shape(), &format!("{}_{}", var_name, field.name));
                }
                // Construct the struct
                let field_args: Vec<String> = s
                    .fields
                    .iter()
                    .map(|f| format!("{}: {}_{}", f.name, var_name, f.name))
                    .collect();
                self.writeln(&format!("let {} = {}({})", var_name, type_name, field_args.join(", ")));
            }
            Type::User(UserType::Enum(e)) => {
                let type_name = clean_type_name(shape.type_identifier);
                self.writeln(&format!("let {}_index = try decodeVarint(from: &responseData)", var_name));
                self.writeln(&format!("let {}: {}", var_name, type_name));
                self.writeln(&format!("switch {}_index {{", var_name));
                for (idx, variant) in e.variants.iter().enumerate() {
                    let case_name = to_camel_case(variant.name);
                    self.writeln(&format!("case {}:", idx));
                    self.indent += 1;
                    if variant.data.fields.is_empty() {
                        self.writeln(&format!("{} = .{}", var_name, case_name));
                    } else if variant.data.kind == StructKind::Tuple && variant.data.fields.len() == 1 {
                        let field = &variant.data.fields[0];
                        self.generate_decode_value(field.shape(), &format!("{}_value", var_name));
                        self.writeln(&format!("{} = .{}({}_value)", var_name, case_name, var_name));
                    } else {
                        for field in variant.data.fields.iter() {
                            self.generate_decode_value(field.shape(), &format!("{}_{}_{}", var_name, case_name, field.name));
                        }
                        let field_args: Vec<String> = variant
                            .data
                            .fields
                            .iter()
                            .map(|f| format!("{}: {}_{}_{}", f.name, var_name, case_name, f.name))
                            .collect();
                        self.writeln(&format!("{} = .{}({})", var_name, case_name, field_args.join(", ")));
                    }
                    self.indent -= 1;
                }
                self.writeln("default:");
                self.indent += 1;
                self.writeln(&format!("fatalError(\"Unknown {} variant: \\({}_index)\")", type_name, var_name));
                self.indent -= 1;
                self.writeln("}");
            }
            _ => {
                let swift_type = self.shape_to_swift_type(shape);
                self.writeln(&format!("let {}: {} // TODO: decode", var_name, swift_type));
            }
        }
    }

    fn shape_to_swift_type(&self, shape: &'static Shape) -> String {
        // Handle unit type
        if shape.type_identifier == "()" {
            return "Void".to_string();
        }

        // Handle container types
        match &shape.def {
            Def::Option(opt) => {
                return format!("{}?", self.shape_to_swift_type(opt.t()));
            }
            Def::List(list) => {
                return format!("[{}]", self.shape_to_swift_type(list.t()));
            }
            Def::Map(map) => {
                return format!(
                    "[{}: {}]",
                    self.shape_to_swift_type(map.k()),
                    self.shape_to_swift_type(map.v())
                );
            }
            Def::Array(arr) => {
                // Swift doesn't have fixed-size arrays, use regular array
                return format!("[{}]", self.shape_to_swift_type(arr.t()));
            }
            Def::Result(res) => {
                return format!(
                    "Result<{}, {}>",
                    self.shape_to_swift_type(res.t()),
                    self.shape_to_swift_type(res.e())
                );
            }
            _ => {}
        }

        // Handle scalar types
        if let Some(scalar) = shape.scalar_type() {
            return scalar_to_swift(scalar).to_string();
        }

        // Handle user types
        match &shape.ty {
            Type::User(UserType::Struct(_)) | Type::User(UserType::Enum(_)) => {
                clean_type_name(shape.type_identifier)
            }
            _ => "Any".to_string(),
        }
    }

    fn arg_type_to_swift(&self, rust_type: &str) -> String {
        // Handle common type aliases and primitives
        match rust_type {
            "String" | "&str" => "String".to_string(),
            "bool" => "Bool".to_string(),
            "i8" => "Int8".to_string(),
            "i16" => "Int16".to_string(),
            "i32" => "Int32".to_string(),
            "i64" => "Int64".to_string(),
            "u8" => "UInt8".to_string(),
            "u16" => "UInt16".to_string(),
            "u32" => "UInt32".to_string(),
            "u64" => "UInt64".to_string(),
            "f32" => "Float".to_string(),
            "f64" => "Double".to_string(),
            // Handle ItemId type alias
            "ItemId" => "UInt64".to_string(),
            _ => {
                // Handle Vec<u8> -> [UInt8]
                if rust_type.starts_with("Vec") && rust_type.contains("u8") {
                    return "[UInt8]".to_string();
                }
                // Handle Vec<T> -> [T]
                if rust_type.starts_with("Vec<") && rust_type.ends_with('>') {
                    let inner = &rust_type[4..rust_type.len() - 1].trim();
                    return format!("[{}]", self.arg_type_to_swift(inner));
                }
                // Handle Option<T> -> T?
                if rust_type.starts_with("Option<") && rust_type.ends_with('>') {
                    let inner = &rust_type[7..rust_type.len() - 1].trim();
                    return format!("{}?", self.arg_type_to_swift(inner));
                }
                clean_type_name(rust_type)
            }
        }
    }

    fn writeln(&mut self, line: &str) {
        let indent = "    ".repeat(self.indent);
        writeln!(self.output, "{}{}", indent, line).unwrap();
    }
}

impl Default for SwiftCodegen {
    fn default() -> Self {
        Self::new()
    }
}

// Helper functions

fn clean_type_name(name: &str) -> String {
    // Remove module path, get just the type name
    name.rsplit("::").next().unwrap_or(name).to_string()
}

fn to_camel_case(name: &str) -> String {
    // Convert snake_case to camelCase
    let mut result = String::new();
    let mut capitalize_next = false;

    for (i, c) in name.chars().enumerate() {
        if c == '_' {
            capitalize_next = true;
        } else if capitalize_next {
            result.push(c.to_ascii_uppercase());
            capitalize_next = false;
        } else if i == 0 {
            result.push(c.to_ascii_lowercase());
        } else {
            result.push(c);
        }
    }

    result
}

fn scalar_to_swift(scalar: ScalarType) -> &'static str {
    match scalar {
        ScalarType::String | ScalarType::Str | ScalarType::CowStr => "String",
        ScalarType::Bool => "Bool",
        ScalarType::Char => "Character",
        ScalarType::I8 => "Int8",
        ScalarType::I16 => "Int16",
        ScalarType::I32 => "Int32",
        ScalarType::I64 => "Int64",
        ScalarType::I128 => "Int64", // Swift doesn't have Int128
        ScalarType::ISize => "Int",
        ScalarType::U8 => "UInt8",
        ScalarType::U16 => "UInt16",
        ScalarType::U32 => "UInt32",
        ScalarType::U64 => "UInt64",
        ScalarType::U128 => "UInt64", // Swift doesn't have UInt128
        ScalarType::USize => "UInt",
        ScalarType::F32 => "Float",
        ScalarType::F64 => "Double",
        _ => "Any",
    }
}

fn is_string_type(shape: &Shape) -> bool {
    matches!(
        shape.scalar_type(),
        Some(ScalarType::String | ScalarType::Str | ScalarType::CowStr)
    )
}

fn is_u8_type(shape: &Shape) -> bool {
    matches!(shape.scalar_type(), Some(ScalarType::U8))
}

fn is_bytes_vec(shape: &Shape) -> bool {
    if let Def::List(list) = &shape.def {
        is_u8_type(list.t())
    } else {
        false
    }
}
