/* Generated by cbindgen — do not edit manually */

#ifndef ROAM_SHM_FFI_H
#define ROAM_SHM_FFI_H

#include <stdint.h>
#include <stdbool.h>
#include <stddef.h>

/**
 * Opaque wrapper around the Rust VarSlotPool (heap-allocated, Box'd).
 */
typedef struct RoamVarSlotPool RoamVarSlotPool;

/**
 * A size class descriptor for variable-size slot pools.
 */
typedef struct RoamSizeClass {
  uint32_t slot_size;
  uint32_t count;
} RoamSizeClass;

/**
 * Handle to an allocated variable-size slot.
 */
typedef struct RoamVarSlotHandle {
  uint8_t class_idx;
  uint8_t extent_idx;
  uint32_t slot_idx;
  uint32_t generation;
} RoamVarSlotHandle;

uint32_t roam_bipbuf_header_size(void);

/**
 * Initialize a BipBuffer header. The caller must provide a zeroed 128-byte
 * region at `header_ptr` followed by `capacity` bytes of data space.
 */
void roam_bipbuf_init(void *header_ptr, uint32_t capacity);

uint32_t roam_bipbuf_capacity(const void *header_ptr);

uint32_t roam_bipbuf_load_write_acquire(const void *header_ptr);

uint32_t roam_bipbuf_load_read_acquire(const void *header_ptr);

uint32_t roam_bipbuf_load_watermark_acquire(const void *header_ptr);

/**
 * Try to reserve `len` bytes for writing.
 *
 * Returns 1 on success (offset written to `*out_offset`),
 * 0 if there isn't enough contiguous space (would block),
 * -1 if `len` exceeds the buffer capacity (error).
 */
int32_t roam_bipbuf_try_grant(void *header_ptr, uint32_t len, uint32_t *out_offset);

/**
 * Commit `len` previously granted bytes, making them visible to the consumer.
 *
 * Returns 0 on success, -1 on overflow.
 */
int32_t roam_bipbuf_commit(void *header_ptr, uint32_t len);

/**
 * Try to read contiguous bytes from the buffer.
 *
 * On success, writes the readable region's offset and length to the out
 * pointers and returns 1. Returns 0 if the buffer is empty.
 */
int32_t roam_bipbuf_try_read(void *header_ptr, uint32_t *out_offset, uint32_t *out_len);

/**
 * Release `len` bytes from the consumer side.
 *
 * Returns 0 on success, -1 on overflow.
 */
int32_t roam_bipbuf_release(void *header_ptr, uint32_t len);

/**
 * Create a VarSlotPool view over an existing shared memory region.
 *
 * Does NOT initialize the pool — call `roam_var_slot_pool_init` for that.
 * Returns a heap-allocated opaque handle, or null on failure.
 */
struct RoamVarSlotPool *roam_var_slot_pool_attach(uint8_t *region_ptr,
                                                  uintptr_t region_len,
                                                  uint64_t base_offset,
                                                  const struct RoamSizeClass *classes,
                                                  uintptr_t num_classes);

/**
 * Initialize all extent-0 slots and free lists. Call once during segment creation.
 */
void roam_var_slot_pool_init(struct RoamVarSlotPool *pool);

/**
 * Update the region pointer after a resize/remap.
 */
void roam_var_slot_pool_update_region(struct RoamVarSlotPool *pool,
                                      uint8_t *region_ptr,
                                      uintptr_t region_len);

/**
 * Allocate a slot that can hold `size` bytes.
 *
 * Returns 1 on success (handle written to `*out_handle`), 0 if exhausted.
 */
int32_t roam_var_slot_pool_alloc(const struct RoamVarSlotPool *pool,
                                 uint32_t size,
                                 uint8_t owner,
                                 struct RoamVarSlotHandle *out_handle);

/**
 * Transition a slot from Allocated to InFlight.
 *
 * Returns 0 on success, -1 on error (generation mismatch or wrong state).
 */
int32_t roam_var_slot_pool_mark_in_flight(const struct RoamVarSlotPool *pool,
                                          struct RoamVarSlotHandle handle);

/**
 * Free an in-flight slot back to its pool.
 *
 * Returns 0 on success, -1 on error.
 */
int32_t roam_var_slot_pool_free(const struct RoamVarSlotPool *pool,
                                struct RoamVarSlotHandle handle);

/**
 * Free an allocated (never sent) slot back to its pool.
 *
 * Returns 0 on success, -1 on error.
 */
int32_t roam_var_slot_pool_free_allocated(const struct RoamVarSlotPool *pool,
                                          struct RoamVarSlotHandle handle);

/**
 * Get a pointer to the slot's payload data area.
 *
 * Returns null if the handle is invalid.
 */
uint8_t *roam_var_slot_pool_payload_ptr(const struct RoamVarSlotPool *pool,
                                        struct RoamVarSlotHandle handle);

/**
 * Get the slot size for a given class index.
 *
 * Returns 0 if the class index is out of range.
 */
uint32_t roam_var_slot_pool_slot_size(const struct RoamVarSlotPool *pool, uint8_t class_idx);

/**
 * Recover all slots owned by a crashed peer.
 */
void roam_var_slot_pool_recover_peer(const struct RoamVarSlotPool *pool, uint8_t peer_id);

/**
 * Calculate the total size needed for a variable slot pool (extent 0 only).
 */
uint64_t roam_var_slot_pool_calculate_size(const struct RoamSizeClass *classes,
                                           uintptr_t num_classes);

/**
 * Destroy a VarSlotPool, freeing its heap allocation.
 */
void roam_var_slot_pool_destroy(struct RoamVarSlotPool *pool);

uint32_t roam_atomic_load_u32_acquire(const uint32_t *ptr);

void roam_atomic_store_u32_release(uint32_t *ptr, uint32_t value);

int32_t roam_atomic_compare_exchange_u32(uint32_t *ptr, uint32_t *expected, uint32_t desired);

uint32_t roam_atomic_fetch_add_u32(uint32_t *ptr, uint32_t value);

uint64_t roam_atomic_load_u64_acquire(const uint64_t *ptr);

void roam_atomic_store_u64_release(uint64_t *ptr, uint64_t value);

int32_t roam_atomic_compare_exchange_u64(uint64_t *ptr, uint64_t *expected, uint64_t desired);

#endif  /* ROAM_SHM_FFI_H */
