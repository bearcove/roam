+++
title = "Rust Specification"
description = "Implementation details specific to the Rust implementation"
weight = 20
+++

# Introduction

This document specifies implementation details for the Rust implementation of
roam. These details are NOT required for implementations in other languages
— Swift, TypeScript, etc. get their types and method identities from code
generated by the Rust proto crate.

# Method Identity

Every method has a unique 64-bit identifier computed from its service name,
method name, and signature.

> rs[method.identity.computation]
>
> The method ID MUST be computed as:
> ```
> method_id = blake3(kebab(ServiceName) + "." + kebab(methodName) + sig_bytes)[0..8]
> ```
> Where:
> - `kebab()` converts to kebab-case (e.g. `TemplateHost` → `template-host`)
> - `sig_bytes` is the BLAKE3 hash of the method's argument and return types
> - `[0..8]` takes the first 8 bytes as a u64

This means:
- Renaming a service or method changes the ID (breaking change)
- Changing the signature changes the ID (breaking change)
- Case variations normalize to the same ID (`loadTemplate` = `load_template`)

# Signature Hash

The `sig_bytes` used in method identity is a BLAKE3 hash of the method's
structural signature. This is computed at compile time by the `#[roam::service]`
macro using [facet](https://facet.rs) type introspection.

> rs[signature.hash.algorithm]
>
> The signature hash MUST be computed by hashing a canonical byte
> representation of the method signature using BLAKE3.

> rs[signature.varint]
>
> Variable-length integers (`varint`) in signature encoding use the
> same format as [POSTCARD]: unsigned LEB128. Each byte contains 7
> data bits; the high bit indicates continuation (1 = more bytes).

> rs[signature.endianness]
>
> All fixed-width integers in signature encoding are little-endian.
> The final u64 method ID is extracted as the first 8 bytes of the
> BLAKE3 hash, interpreted as little-endian.

The canonical representation encodes the method signature as a tuple (see
`rs[signature.method]` below). Each type within is encoded recursively:

## Primitive Types

> rs[signature.primitive]
>
> Primitive types MUST be encoded as a single byte tag:

| Type | Tag |
|------|-----|
| `bool` | `0x01` |
| `u8` | `0x02` |
| `u16` | `0x03` |
| `u32` | `0x04` |
| `u64` | `0x05` |
| `u128` | `0x06` |
| `i8` | `0x07` |
| `i16` | `0x08` |
| `i32` | `0x09` |
| `i64` | `0x0A` |
| `i128` | `0x0B` |
| `f32` | `0x0C` |
| `f64` | `0x0D` |
| `char` | `0x0E` |
| `String` | `0x0F` |
| `()` (unit) | `0x10` |
| `bytes` | `0x11` |

## Container Types

> rs[signature.container]
>
> Container types MUST be encoded as a tag byte followed by their element type(s):

| Type | Tag | Encoding |
|------|-----|----------|
| List | `0x20` | tag + encode(element) |
| Option | `0x21` | tag + encode(inner) |
| Array | `0x22` | tag + varint(len) + encode(element) |
| Map | `0x23` | tag + encode(key) + encode(value) |
| Set | `0x24` | tag + encode(element) |
| Tuple | `0x25` | tag + varint(len) + encode(T1) + encode(T2) + ... |
| Stream | `0x26` | tag + encode(element) |

Note: These are wire-format types, not Rust types. `Vec`, `VecDeque`, and
`LinkedList` all encode as List. `HashMap` and `BTreeMap` both encode as Map.

> rs[signature.bytes.equivalence]
>
> Any "bytes" type MUST use the `bytes` tag (`0x11`) in signature encoding.
> This includes the dedicated `bytes` wire-format type and a list of `u8`.
> As a result, `bytes` and `List<u8>` MUST produce identical signature hashes.

## Struct Types

> rs[signature.struct]
>
> Struct types MUST be encoded as:
> ```
> 0x30 + varint(field_count) + (field_name + field_type)*
> ```
> Where each `field_name` is encoded as `varint(len) + utf8_bytes`.
> Fields MUST be encoded in declaration order.

Note: The struct's *name* is NOT included — only field names and types.
This allows renaming types without breaking compatibility.

## Enum Types

> rs[signature.enum]
>
> Enum types MUST be encoded as:
> ```
> 0x31 + varint(variant_count) + (variant_name + variant_payload)*
> ```
> Where each `variant_name` is encoded as `varint(len) + utf8_bytes`.
> `variant_payload` is:
> - `0x00` for unit variants
> - `0x01` + encode(T) for newtype variants
> - `0x02` + struct encoding (without the 0x30 tag) for struct variants

Variants MUST be encoded in declaration order.

## Recursive Types

> rs[signature.recursive]
>
> When encoding types that reference themselves (directly or indirectly),
> implementations MUST detect cycles and emit a back-reference tag (`0x32`)
> instead of infinitely recursing. Cycles can occur through any chain of
> type references: containers, struct fields, enum variants, or combinations
> thereof.
>
> The back-reference tag is a single byte that indicates "this type was
> already encoded earlier in this signature". This ensures:
> - No stack overflow during encoding
> - Deterministic output (same type always produces same bytes)
> - Finite signature size for recursive types

## Method Signature Encoding

> rs[signature.method]
>
> A method signature MUST be encoded as a tuple of its arguments followed
> by the return type:
> ```
> 0x25 + varint(arg_count) + encode(arg1) + ... + encode(argN) + encode(return_type)
> ```

This structure ensures unambiguous parsing — without the argument count,
`fn add(a: i32, b: i32) -> i64` would have the same bytes as
`fn foo(a: i32, b: i32, c: i64)` (which returns unit).

## Example

For a method:
```rust
async fn add(&self, a: i32, b: i32) -> i64;
```

The canonical bytes would be:
```
0x25          // Tuple tag (method signature)
0x02          // 2 arguments
0x09          // a: i32
0x09          // b: i32
0x0A          // return: i64
```

BLAKE3 hash of these bytes gives `sig_bytes`.

# Introspection Types

The `Diagnostic` service uses these types for introspection and debugging.
Type information uses `facet::Shape` directly rather than a parallel type system.

```rust
struct ServiceDetail {
    name: Cow<'static, str>,
    methods: Vec<MethodDetail>,
    doc: Option<Cow<'static, str>>,
}

struct MethodDetail {
    service_name: Cow<'static, str>,
    method_name: Cow<'static, str>,
    args: Vec<ArgDetail>,
    return_type: &'static Shape,  // facet Shape, not TypeDetail
    doc: Option<Cow<'static, str>>,
}

struct ArgDetail {
    name: Cow<'static, str>,
    ty: &'static Shape,  // facet Shape
}

struct ServiceSummary {
    name: Cow<'static, str>,
    method_count: u32,
    doc: Option<Cow<'static, str>>,
}

struct MethodSummary {
    name: Cow<'static, str>,
    method_id: u64,
    doc: Option<Cow<'static, str>>,
}

enum MismatchExplanation {
    /// Service doesn't exist
    UnknownService { closest: Option<Cow<'static, str>> },
    /// Service exists but method doesn't
    UnknownMethod { service: Cow<'static, str>, closest: Option<Cow<'static, str>> },
    /// Method exists but signature differs
    SignatureMismatch { 
        service: Cow<'static, str>,
        method: Cow<'static, str>,
        expected: MethodDetail,
    },
}
```

## Using Shape for Type Introspection

Instead of a custom `TypeDetail` enum, roam uses `facet::Shape` directly.
Use `facet_core` to inspect shapes:

- `shape.def` reveals if it's a struct, enum, list, option, etc.
- `shape.type_params` gives generic parameters
- `shape.scalar_type()` returns the scalar type for primitives
- `roam_schema::classify_shape()` provides high-level classification for codegen

Helper functions in `roam_schema`:
- `is_tx(shape)` / `is_rx(shape)` — check for streaming types
- `is_channel(shape)` — check for any channel type
- `contains_channels(shape)` — recursively check for channels
- `is_bytes(shape)` — check for `Vec<u8>` or `&[u8]`

## Usage

When `Diagnostic.explain_mismatch` returns `SignatureMismatch`, the client
can diff its local `MethodDetail` against the `expected` field to show
exactly where the types diverge:

```
Method `TemplateHost.load_template` signature mismatch:
  arg `context_id`: expected ContextId { id: u64 }
                        got ContextId { id: u32 }
                                           ^^^
```

# Wire Type Mappings

Certain roam types have special wire representations that differ from
their Rust representation.

## Tx<T> / Rx<T> (Channeling)

Roam uses directional channel handles in Rust:
- `Tx<T>` for caller → callee data flow
- `Rx<T>` for callee → caller data flow

On the wire, both are encoded as `u64` channel IDs in payload values.
The element type `T` is known from the method schema.

Channel IDs are also carried in Request/Response framing (`channels` fields),
and payload IDs are patched from framing IDs during prepare/bind. See
`rs[call.request.channels]` and `rs[call.request.channels.schema-driven]` in the
main specification.

```rust
// Method signature:
async fn sum(&self, numbers: Tx<u32>) -> u32;
async fn range(&self, n: u32, output: Rx<u32>);

// Payload representation: channel IDs only
// payload(sum)   = postcard::to_vec(&(numbers_channel_id: u64,))?;
// payload(range) = postcard::to_vec(&(n, output_channel_id: u64))?;
```

The `#[roam::service]` proc macro MUST reject methods where `Tx<T>` or `Rx<T>`
appear inside the error type `E` of `Result<T, E>`, enforcing
`rs[streaming.error-no-streams]` from the main specification.

# RoamError

The `RoamError<E>` type is defined in the [main specification](@/spec/_index.md#roamerror).
The Rust implementation provides this type with Facet derivation:

```rust
#[derive(Facet)]
pub enum RoamError<E> {
    User(E),         // discriminant 0
    UnknownMethod,   // discriminant 1
    InvalidPayload,  // discriminant 2
    Cancelled,       // discriminant 3
}
```

The variant order MUST match the main spec — Postcard encodes enum
discriminants as varints starting from 0.

## Generated Client Types

For a method:
```rust
async fn get_user(&self, id: UserId) -> Result<User, UserError>;
```

The generated client method returns:
```rust
async fn get_user(&self, id: UserId) -> Result<User, RoamError<UserError>>;
```

Callers can distinguish application errors from protocol errors:
```rust
match client.get_user(id).await {
    Ok(user) => { /* success */ }
    Err(RoamError::User(e)) => { /* application error: e */ }
    Err(RoamError::UnknownMethod) => { /* protocol version mismatch? */ }
    Err(RoamError::Cancelled) => { /* we or they cancelled */ }
    // ...
}
```

# Rust Runtime Layering

This section defines Rust implementation layering in terms of Messages,
connections, virtual connections, and channels.

## Terms and Definitions

> rs[term.transport]
>
> A **transport** is a mechanism that sends and receives roam `Message`
> values between peers.

> rs[term.connection]
>
> A **connection** is a concrete instantiation of a transport between two peers
> (called a "link" in the main specification; see `r[core.link]`).

> rs[term.virtual-connection]
>
> A **virtual connection** is a `conn_id`-scoped communication context
> multiplexed on top of a connection (`r[core.link]`, `r[core.conn.independence]`).

> rs[term.channel]
>
> A **channel** is a directional `channel_id`-scoped data path within a virtual
> connection. `Tx<T>` and `Rx<T>` are Rust-level handles over that protocol
> mechanism (`r[channeling.type]`, `r[channeling.allocation.caller]`).

## Layer Responsibilities

> rs[layer.generated-client]
>
> Generated Rust service clients are typed API stubs. They own method
> descriptors and typed argument construction, and MUST NOT own connection I/O,
> reconnect/retry control flow, or channel protocol mechanics.

> rs[client.nongeneric]
>
> Generated Rust service clients SHOULD expose non-generic concrete types.
> Runtime polymorphism, when needed, is an internal runtime concern.

> rs[layer.call-runtime]
>
> The Rust call runtime owns the typed-to-message boundary:
> - argument encoding into Request payload (`r[call.request.payload-encoding]`)
> - schema-driven channel ID collection for Request.channels
>   (`r[call.request.channels]`, `r[call.request.channels.schema-driven]`)
> - response decoding (`r[call.response.encoding]`)
> - response-side `Rx<T>` binding

> rs[layer.connection-runtime]
>
> The Rust connection runtime owns virtual-connection call execution:
> send Request, correlate Response by `request_id`, and map transport failures
> to transport errors.

> rs[layer.transport]
>
> Transport adapters own transport-specific mechanics only:
> - message transports: each transport message carries one roam `Message`
>   (`r[transport.message.one-to-one]`)
> - byte streams: length-prefix bytes and decode/encode to roam `Message`
>   (`r[transport.bytestream.length-prefix]`)
> - shm: shared-memory signaling/buffer mechanics

## What a Call Entails (Rust)

> rs[call.steps]
>
> A Rust call path MUST perform:
> 1. Encode typed args as Request payload tuple
> 2. Collect all channel IDs from args using schema-driven traversal
> 3. Send Request with `method_id`, `metadata`, `channels`, and `payload`
> 4. Correlate Response by `request_id`
> 5. Decode `Result<T, RoamError<E>>` from response payload
> 6. Bind response `Rx<T>` handles using response channels + method schema

## Reconnection and Retry Ownership

> rs[reconnect.owner]
>
> Automatic reconnection and call retry are owned by reconnecting connection
> runtime implementations (not by generated service clients).

> rs[reconnect.trigger]
>
> Reconnect/retry behavior MUST follow reconnect-spec rules:
> - trigger on transport failures (`r[reconnect.trigger.transport]`)
> - do NOT trigger on RPC-level errors (`r[reconnect.trigger.not-rpc]`)
> - apply retry policy/backoff (`r[reconnect.policy]`, `r[reconnect.policy.backoff]`)
> - preserve shared/single-reconnect concurrency semantics
>   (`r[reconnect.concurrency.shared]`, `r[reconnect.concurrency.single-reconnect]`)

> rs[retry.semantic]
>
> Retry means re-issuing the same logical call after reconnect due to transport
> failure. This is transport-failure recovery behavior, not application-level
> retry policy.

## Channel Binding Ownership

> rs[channel.binding.request]
>
> Request-side channel ownership is caller-side and schema-driven
> (`r[channeling.allocation.caller]`, `r[call.request.channels.schema-driven]`).

> rs[channel.binding.server]
>
> On dispatch, Rust MUST treat Request.channels as authoritative and patch IDs
> into deserialized args before binding streams (`r[channeling.allocation.caller]`).

> rs[channel.binding.response]
>
> On the caller side, Rust MUST bind response `Rx<T>` handles after decoding
> a successful response, using response channel IDs and method schema.

> rs[channel.binding.transport-agnostic]
>
> Channel binding semantics are transport-agnostic and MUST be identical across
> message, byte-stream, and shm transports.
