+++
title = "Rust Specification"
description = "Implementation details specific to the Rust implementation"
weight = 20
+++

# Introduction

This document specifies implementation details for the Rust implementation of
roam. These details are NOT required for implementations in other languages
— Swift, TypeScript, etc. get their types and method identities from code
generated by the Rust proto crate.

# Layers

This section is prescriptive: it defines the target Rust architecture.

## Terms and Definitions

> rs[term.message]
>
> A **Message** is one roam protocol message (for example: `Request`,
> `Response`, `Data`, `Close`, `Credit`, `Goodbye`) as defined by the main
> specification's message model.
>
> Example: `Request { conn_id: 0, request_id: 42, ... }`.

> rs[term.payload]
>
> A **Payload** is one opaque binary unit moved by a link.
> In Rust this is `roam_types::Payload` (a `#[repr(transparent)]` wrapper over
> `Vec<u8>`): uninterpreted bytes at the link boundary.
>
> Example: the postcard encoding of one `Message`, or the raw bytes carried in
> a WebSocket binary message.

> rs[term.transport]
>
> A **transport** is a mechanism that sends and receives roam `Payload`
> values between peers.
>
> Example: TCP byte stream, WebSocket message transport, or SHM transport.

> rs[term.link]
>
> A **link** is one concrete instantiation of a transport between two peers
> (`r[core.link]`).
>
> Example: one established TCP socket between peer A and peer B.

> rs[term.virtual-connection]
>
> A **virtual connection** is a `conn_id`-scoped context carried on a link.
> Every link has an implicit root virtual connection (`conn_id = 0`) and can
> carry additional virtual connections opened with `Connect`/`Accept`
> (`r[core.link.connection-zero]`, `r[core.conn.open]`).
>
> Example: calls on `conn_id = 0` and `conn_id = 7` are independent but share
> the same link.

> rs[term.channel]
>
> A **channel** is a directional data path identified by `(conn_id, channel_id)`.
> `Tx<T>` and `Rx<T>` are Rust-level handles over that mechanism
> (`r[channeling.type]`, `r[channeling.allocation.caller]`, `r[message.conn-id]`).
>
> Example: `Data { conn_id: 0, channel_id: 3, ... }` and
> `Data { conn_id: 7, channel_id: 3, ... }` refer to different channels.

## Trait Boundaries

> rs[layer.trait-boundaries]
>
> Each layer MUST correspond to one primary Rust trait boundary. Layer
> responsibilities MUST NOT leak across trait boundaries.

## Transports

> rs[layer.transport]
>
> The transport layer is responsible only for moving roam `Payload` values
> and transport-specific framing/signaling.

> rs[layer.link.interface]
>
> Rust MUST provide one shared **link** interface for all transports
> (stream, framed, shm), with a split sender/receiver model for roam
> `Payload` values.

```rust
pub trait Link {
    type Sender: LinkSender;
    type Receiver: LinkReceiver;
    fn split(self) -> (Self::Sender, Self::Receiver);
}

pub trait LinkSender {
    type Permit<'a>: LinkSendPermit
    where
        Self: 'a;

    /// Wait for outbound capacity for exactly one payload and reserve it for
    /// the caller.
    ///
    /// Cancellation of `reserve` MUST NOT leak capacity; if reservation
    /// succeeds, dropping the returned permit MUST return that capacity.
    async fn reserve(&self) -> io::Result<Self::Permit<'_>>;

    /// Request a graceful close of the outbound direction.
    ///
    /// This consumes `self` so it cannot be called twice.
    async fn close(self) -> io::Result<()>
    where
        Self: Sized;
}

pub trait LinkSendPermit {
    /// Enqueue exactly one payload into the reserved capacity.
    ///
    /// This MUST NOT block: backpressure happens at `reserve`, not at `send`.
    fn send(self, payload: Payload);
}

pub trait LinkReceiver {
    async fn recv(&mut self) -> io::Result<Option<Payload>>;
}
```

> rs[layer.link.serialization]
>
> `Message` ↔ `Payload` serialization is NOT owned by `Link`.
> Rust runtimes above `Link` MUST serialize `Message` to `Payload` before
> sending and MUST deserialize `Payload` back to `Message` after `recv`.
> For Rust, this serialization MUST use postcard.

> rs[layer.link.permits]
>
> Link outbound buffering and backpressure MUST be permit-based:
>
> - `LinkSender::reserve` MUST await until outbound capacity for exactly one
>   payload is available, then reserve it for the caller by returning a permit.
>   Capacity reservation MUST be FIFO-fair: if multiple tasks call `reserve`,
>   permits MUST be handed out in the order reservations were requested.
>   Cancelling a `reserve` call MUST forfeit the caller's place in that FIFO
>   order, but MUST NOT leak capacity.
>
> - `LinkSendPermit::send` MUST enqueue exactly one payload into the reserved
>   capacity and MUST NOT block.
>
> - Dropping a permit without calling `send` MUST release the reserved capacity
>   back to the link.
>
> - A link MUST have an internal outbound buffer (queue) with finite capacity.
>   This buffer is what permits reserve.
>
> Link receive and close behavior:
> - `LinkReceiver::recv` MUST await until one inbound `Payload` is available
>   (`Ok(Some(payload))`), the inbound direction closes cleanly (`Ok(None)`), or
>   an I/O/framing error occurs (`Err(...)`).
> - `LinkSender::close` MUST stop handing out new permits, MUST drain/flush all
>   already-enqueued payload bytes, then MUST perform transport-level outbound
>   close (or return `Err(...)` if drain/flush/close fails).
>   The purpose of `close` is to let higher layers shut down a link without
>   losing already-enqueued outbound bytes; it does not perform any roam-level
>   shutdown.
>
> Concurrency, ordering, and loss:
> - Link implementations MUST support concurrent send and receive on the same
>   link (one task reserving/sending while another receives).
> - Link implementations MUST preserve payload ordering per direction.
> - Link implementations MUST NOT duplicate or silently drop enqueued payloads.

> rs[layer.link.blind]
>
> `Link` is protocol-blind: it MUST treat payload bytes as opaque and MUST NOT
> make decisions based on roam semantics (method IDs, request lifecycle, channel
> lifecycle, etc.). Transport-specific framing/signaling is allowed, but roam
> protocol behavior is not.

> rs[layer.link.connector]
>
> Rust MUST provide a transport-agnostic connector interface that yields fresh
> `Link` instances. Any component that needs to (re)establish links MUST depend
> on this interface.

```rust
pub trait TransportConnector {
    type Link: Link;
    async fn connect(&self) -> io::Result<Self::Link>;
}
```

> rs[layer.transport.stream]
>
> Stream transports (for example: TCP, Unix sockets) MUST use 4-byte
> little-endian length-prefix framing (`r[transport.bytestream.length-prefix]`).
> Each frame payload MUST carry exactly one roam `Payload`.
>
> Stream outbound queuing and draining entail:
> - `reserve` awaits queue capacity (in-process buffer).
> - `permit.send(payload)` enqueues one payload into that queue.
> - a stream writer task drains the queue in order:
>   - compute 4-byte little-endian length prefix for `payload.0.len()`
>   - write `len_prefix || payload_bytes` to the byte stream in order
>   - if the OS/socket cannot currently accept the full write, await until it can
>   - if an I/O error occurs, the link enters a failed state and subsequent
>     `reserve` MUST return `Err(...)`.
>
> Stream `recv` entails:
> - read exactly 4 bytes to obtain the length prefix
> - read exactly that many bytes into a new `Payload`
> - if the remote cleanly closes before a full prefix/payload is read, return
>   `Ok(None)` (end-of-stream)
> - if the stream ends mid-frame, return `Err(...)`
>
> Stream `close` entails:
> - flush any user-space buffered bytes for previously-enqueued payloads
> - then perform a half-close of the outbound stream direction (for example:
>   `shutdown(SHUT_WR)`), while leaving inbound receive possible until the peer
>   closes or an error occurs
>
> Stream buffering and backpressure entail:
> - buffering:
>   - in-process outbound queue (finite) is required by `rs[layer.link.permits]`
>   - OS socket send/receive buffers and user-space read/write buffers are also
>     part of the transport
> - backpressure: when the outbound queue is full, `reserve` MUST await; when
>   the OS socket send buffer is full, the writer task awaits; payloads MUST NOT
>   be dropped to relieve pressure.

> rs[layer.transport.framed]
>
> Framed transports (for example: WebSocket) MUST map one transport frame to
> one roam `Payload` (`r[transport.message.one-to-one]`).
>
> Framed outbound queuing and draining entail:
> - `reserve` awaits queue capacity (in-process buffer).
> - `permit.send(payload)` enqueues one payload into that queue.
> - a framed writer task drains the queue in order and submits exactly one
>   transport frame per payload, carrying exactly `payload.0` bytes.
> - if the framed sink reports an error, the link enters a failed state and
>   subsequent `reserve` MUST return `Err(...)`.
>
> Framed `recv` entails:
> - await exactly one inbound transport frame
> - return its bytes as one `Payload`
> - if the transport indicates a clean close, return `Ok(None)`
>
> Framed `close` entails:
> - flush any already-enqueued outbound frames
> - then perform the framed transport's graceful close procedure (for example:
>   WebSocket close handshake), without emitting any roam payloads on its own
>
> Framed buffering and backpressure entail:
> - buffering:
>   - in-process outbound queue (finite) is required by `rs[layer.link.permits]`
>   - frame queues and internal codec buffers are part of the framed transport
> - backpressure: when the outbound queue is full, `reserve` MUST await; when
>   the framed sink is not ready, the writer task awaits. `permit.send` MUST NOT
>   block.

> rs[layer.transport.shm]
>
> SHM transport MUST preserve the same link/virtual-connection semantics.
> Transport signaling/buffering is SHM-specific.
>
> SHM outbound queuing and draining entail:
> - `reserve` awaits queue capacity (in-process buffer).
> - `permit.send(payload)` enqueues one payload into that queue.
> - an SHM producer task drains the queue in order:
>   - copy payload bytes into exactly one outbound SHM slot/entry
>   - publish/signal availability to the peer
>   - if there is no SHM slot capacity, await until capacity is available
>   - if an SHM error occurs, the link enters a failed state and subsequent
>     `reserve` MUST return `Err(...)`.
>
> SHM `recv` entails:
> - await a signal indicating an inbound slot/entry is available
> - consume exactly one entry and copy its bytes into one `Payload`
> - if the peer has closed and no further entries remain, return `Ok(None)`
>
> SHM `close` entails:
> - publish a transport-level "producer closed" state for the outbound direction
> - wake any blocked receivers as required by the SHM transport design
> - ensure no additional outbound entries are published after close begins
>
> SHM buffering and backpressure entail:
> - buffering:
>   - in-process outbound queue (finite) is required by `rs[layer.link.permits]`
>   - bounded SHM rings/queues are also transport buffers; each entry is exactly
>     one payload
> - backpressure: when the outbound queue is full, `reserve` MUST await; when
>   the SHM ring/queue is full, the SHM producer task awaits. `permit.send` MUST
>   NOT block.

## Link Runtime

> rs[layer.link-runtime]
>
> The link runtime owns protocol state machine concerns over a live link:
> - hello/negotiation for link-level limits
> - virtual-connection lifecycle (`Connect`/`Accept`/`Reject`/`Goodbye`)
> - request/response correlation by `(conn_id, request_id)`
> - channel message routing (`Data`/`Close`/`Reset`/`Credit`)
> - protocol violation handling and error mapping

> rs[layer.link-runtime.shutdown]
>
> Protocol-level shutdown behavior (including when/why to send `Goodbye`) is
> owned by the link runtime, not by the transport/link abstraction.

> rs[layer.link-runtime.interface]
>
> Rust MUST provide one primary link-runtime interface that consumes a
> `Link`, exposes root virtual-connection call capability, exposes incoming
> virtual-connection requests, and runs the receive/send loop.

```rust
pub trait LinkRuntime {
    type IncomingVirtualConnections;

    fn root(&self) -> VirtualConnectionHandle;
    fn incoming(&mut self) -> &mut Self::IncomingVirtualConnections;
    fn run(self) -> impl Future<Output = Result<(), LinkError>>;
}
```

## Flow Control

> rs[layer.flow-control.owner]
>
> Channel flow control is owned by the link runtime, not by generated clients
> and not by method-specific call code.

> rs[layer.flow-control.rules]
>
> Flow control semantics MUST follow main-spec rules
> (`r[flow.channel.credit-based]`, `r[flow.channel.all-transports]`,
> `r[flow.channel.credit-grant]`, `r[flow.channel.credit-consume]`,
> `r[flow.channel.zero-credit]`) for all transports. Transport-specific
> mechanics are allowed:
> - stream/framed: wire `Credit` messages
> - shm: shared-memory credit counters
>
> These differences MUST remain observationally equivalent at the protocol
> level.

> rs[layer.flow-control.interface]
>
> Rust MUST define a dedicated flow-control trait used by the link runtime.

```rust
pub trait FlowControl {
    fn on_data_received(&mut self, channel_id: ChannelId, bytes: u32);
    fn wait_for_send_credit(
        &mut self,
        channel_id: ChannelId,
        bytes: u32,
    ) -> impl Future<Output = io::Result<()>>;
    fn consume_send_credit(&mut self, channel_id: ChannelId, bytes: u32);
}
```

## Call Runtime

> rs[layer.call-runtime]
>
> The call runtime owns the typed-to-message boundary:
> - argument encoding into Request payload (`r[call.request.payload-encoding]`)
> - schema-driven channel ID collection for Request.channels
>   (`r[call.request.channels]`, `r[call.request.channels.schema-driven]`)
> - response decoding (`r[call.response.encoding]`)
> - response-side `Rx<T>` binding

> rs[layer.call-runtime.interface]
>
> Rust MUST define one primary call-runtime interface for typed method calls.

## Generated Clients

> rs[layer.generated-client]
>
> Generated Rust service clients are concrete typed API structs with method
> impls. They own method descriptors, typed argument construction, and one
> inner call-runtime handle; they MUST NOT own link I/O, reconnect/retry
> control flow, or channel protocol mechanics.

> rs[client.nongeneric]
>
> Generated Rust service clients MUST expose non-generic concrete types.
> Runtime polymorphism, when needed, is an internal runtime concern.

## What a Call Entails (Rust)

> rs[call.steps]
>
> A Rust call path MUST perform:
> 1. Encode typed args as Request payload tuple
> 2. Collect all channel IDs from args using schema-driven traversal
> 3. Send Request with `method_id`, `metadata`, `channels`, and `payload`
> 4. Correlate Response by `request_id`
> 5. Decode `Result<T, RoamError<E>>` from response payload
> 6. Bind response `Rx<T>` handles using response channels + method schema

## Reconnection and Retry

> rs[reconnect.owner]
>
> Automatic reconnection and call retry are owned by reconnecting link-runtime
> implementations (not by generated service clients).

> rs[reconnect.new-link]
>
> Reconnection creates a new link instance. It does not resume the previous
> link instance.

> rs[reconnect.state-reset]
>
> On reconnect, link-scoped runtime state resets (request/channel id spaces,
> root virtual connection state, and channel routing tables).

> rs[reconnect.trigger]
>
> Reconnect/retry behavior MUST follow reconnect-spec rules:
> - trigger on transport failures (`r[reconnect.trigger.transport]`)
> - do NOT trigger on RPC-level errors (`r[reconnect.trigger.not-rpc]`)
> - apply retry policy/backoff (`r[reconnect.policy]`, `r[reconnect.policy.backoff]`)
> - preserve shared/single-reconnect concurrency semantics
>   (`r[reconnect.concurrency.shared]`, `r[reconnect.concurrency.single-reconnect]`)

> rs[retry.semantic]
>
> Retry means re-issuing the same logical call after reconnect due to transport
> failure. This is transport-failure recovery behavior, not application-level
> retry policy.

> rs[reconnect.inflight.requests]
>
> In-flight requests on a failed link MUST complete with transport failure
> unless explicitly retried by reconnect logic.

> rs[reconnect.inflight.channels]
>
> Channels on a failed link are terminated with that link.

> rs[reconnect.no-channel-resume]
>
> Implementations MUST NOT transparently resume an existing channel stream
> across reconnect. If recovery is desired, the call must be restarted and
> new channels established on the new link.

## Channel Binding

> rs[channel.binding.request]
>
> Request-side channel ownership is caller-side and schema-driven
> (`r[channeling.allocation.caller]`, `r[call.request.channels.schema-driven]`).

> rs[channel.binding.server]
>
> On dispatch, Rust MUST treat Request.channels as authoritative and patch IDs
> into deserialized args before binding streams (`r[channeling.allocation.caller]`).

> rs[channel.binding.response]
>
> On the caller side, Rust MUST bind response `Rx<T>` handles after decoding
> a successful response, using response channel IDs and method schema.

> rs[channel.binding.transport-agnostic]
>
> Channel binding semantics are transport-agnostic and MUST be identical across
> framed, stream, and shm transports.

# Method Identity

Every method has a unique 64-bit identifier computed from its service name,
method name, and signature.

> rs[method.identity.computation]
>
> The method ID MUST be computed as:
> ```
> method_id = blake3(kebab(ServiceName) + "." + kebab(methodName) + sig_bytes)[0..8]
> ```
> Where:
> - `kebab()` converts to kebab-case (e.g. `TemplateHost` → `template-host`)
> - `sig_bytes` is the BLAKE3 hash of the method's argument and return types
> - `[0..8]` takes the first 8 bytes as a u64

This means:
- Renaming a service or method changes the ID (breaking change)
- Changing the signature changes the ID (breaking change)
- Case variations normalize to the same ID (`loadTemplate` = `load_template`)

# Signature Hash

The `sig_bytes` used in method identity is a BLAKE3 hash of the method's
structural signature. This is computed at compile time by the `#[roam::service]`
macro using [facet](https://facet.rs) type introspection.

> rs[signature.hash.algorithm]
>
> The signature hash MUST be computed by hashing a canonical byte
> representation of the method signature using BLAKE3.

> rs[signature.varint]
>
> Variable-length integers (`varint`) in signature encoding use the
> same format as [POSTCARD]: unsigned LEB128. Each byte contains 7
> data bits; the high bit indicates continuation (1 = more bytes).

> rs[signature.endianness]
>
> All fixed-width integers in signature encoding are little-endian.
> The final u64 method ID is extracted as the first 8 bytes of the
> BLAKE3 hash, interpreted as little-endian.

The canonical representation encodes the method signature as a tuple (see
`rs[signature.method]` below). Each type within is encoded recursively:

## Primitive Types

> rs[signature.primitive]
>
> Primitive types MUST be encoded as a single byte tag:

| Type | Tag |
|------|-----|
| `bool` | `0x01` |
| `u8` | `0x02` |
| `u16` | `0x03` |
| `u32` | `0x04` |
| `u64` | `0x05` |
| `u128` | `0x06` |
| `i8` | `0x07` |
| `i16` | `0x08` |
| `i32` | `0x09` |
| `i64` | `0x0A` |
| `i128` | `0x0B` |
| `f32` | `0x0C` |
| `f64` | `0x0D` |
| `char` | `0x0E` |
| `String` | `0x0F` |
| `()` (unit) | `0x10` |
| `bytes` | `0x11` |

## Container Types

> rs[signature.container]
>
> Container types MUST be encoded as a tag byte followed by their element type(s):

| Type | Tag | Encoding |
|------|-----|----------|
| List | `0x20` | tag + encode(element) |
| Option | `0x21` | tag + encode(inner) |
| Array | `0x22` | tag + varint(len) + encode(element) |
| Map | `0x23` | tag + encode(key) + encode(value) |
| Set | `0x24` | tag + encode(element) |
| Tuple | `0x25` | tag + varint(len) + encode(T1) + encode(T2) + ... |
| Stream | `0x26` | tag + encode(element) |

Note: These are wire-format types, not Rust types. `Vec`, `VecDeque`, and
`LinkedList` all encode as List. `HashMap` and `BTreeMap` both encode as Map.

> rs[signature.bytes.equivalence]
>
> Any "bytes" type MUST use the `bytes` tag (`0x11`) in signature encoding.
> This includes the dedicated `bytes` wire-format type and a list of `u8`.
> As a result, `bytes` and `List<u8>` MUST produce identical signature hashes.

## Struct Types

> rs[signature.struct]
>
> Struct types MUST be encoded as:
> ```
> 0x30 + varint(field_count) + (field_name + field_type)*
> ```
> Where each `field_name` is encoded as `varint(len) + utf8_bytes`.
> Fields MUST be encoded in declaration order.

Note: The struct's *name* is NOT included — only field names and types.
This allows renaming types without breaking compatibility.

## Enum Types

> rs[signature.enum]
>
> Enum types MUST be encoded as:
> ```
> 0x31 + varint(variant_count) + (variant_name + variant_payload)*
> ```
> Where each `variant_name` is encoded as `varint(len) + utf8_bytes`.
> `variant_payload` is:
> - `0x00` for unit variants
> - `0x01` + encode(T) for newtype variants
> - `0x02` + struct encoding (without the 0x30 tag) for struct variants

Variants MUST be encoded in declaration order.

## Recursive Types

> rs[signature.recursive]
>
> When encoding types that reference themselves (directly or indirectly),
> implementations MUST detect cycles and emit a back-reference tag (`0x32`)
> instead of infinitely recursing. Cycles can occur through any chain of
> type references: containers, struct fields, enum variants, or combinations
> thereof.
>
> The back-reference tag is a single byte that indicates "this type was
> already encoded earlier in this signature". This ensures:
> - No stack overflow during encoding
> - Deterministic output (same type always produces same bytes)
> - Finite signature size for recursive types

## Method Signature Encoding

> rs[signature.method]
>
> A method signature MUST be encoded as a tuple of its arguments followed
> by the return type:
> ```
> 0x25 + varint(arg_count) + encode(arg1) + ... + encode(argN) + encode(return_type)
> ```

This structure ensures unambiguous parsing — without the argument count,
`fn add(a: i32, b: i32) -> i64` would have the same bytes as
`fn foo(a: i32, b: i32, c: i64)` (which returns unit).

## Example

For a method:
```rust
async fn add(&self, a: i32, b: i32) -> i64;
```

The canonical bytes would be:
```
0x25          // Tuple tag (method signature)
0x02          // 2 arguments
0x09          // a: i32
0x09          // b: i32
0x0A          // return: i64
```

BLAKE3 hash of these bytes gives `sig_bytes`.

# Wire Type Mappings

Certain roam types have special wire representations that differ from
their Rust representation.

## Tx<T> / Rx<T> (Channels)

In Rust, a `#[roam::service]` trait describes what the handler implementation
("server") implements.

- `Rx<T>` means the handler receives a stream of `T` values from the caller.
- `Tx<T>` means the handler sends a stream of `T` values to the caller.

```rust
#[roam::service]
trait Adder {
    // Handler receives numbers from the caller.
    async fn sum(&self, numbers: Rx<u32>) -> u32;
}

// Caller sends numbers on tx and passes the receiving end to the RPC call.
let (tx, rx) = roam::channel();
spawn(async move {
    tx.send(123).await.unwrap();
});
let sum = client.sum(rx).await;
```

Channel ID behavior and Request.channels semantics are specified in
the main spec (`r[call.request.channels]`, `r[call.request.channels.schema-driven]`,
`r[channeling.allocation.caller]`).

The `#[roam::service]` proc macro MUST reject methods where `Tx<T>` or `Rx<T>`
appear inside the error type `E` of `Result<T, E>`, enforcing
`rs[streaming.error-no-streams]` from the main specification.

# RoamError

The `RoamError<E>` type is defined in the [main specification](@/spec/_index.md#roamerror).

Two separate concerns apply in Rust:

> rs[roam-error.semantic]
>
> Semantically, Rust `RoamError<E>` MUST expose the same variants defined by
> the main specification (`User`, `UnknownMethod`, `InvalidPayload`,
> `Cancelled`).

> rs[roam-error.wire]
>
> On the wire, Rust encoding MUST preserve the main-spec discriminant mapping.
> With postcard/facet enum encoding this is by variant order.

Rust type:

```rust
#[derive(Facet)]
pub enum RoamError<E> {
    User(E),
    UnknownMethod,
    InvalidPayload,
    Cancelled,
}
```

Wire discriminants:

| Variant | Discriminant |
|---------|--------------|
| `User(E)` | `0` |
| `UnknownMethod` | `1` |
| `InvalidPayload` | `2` |
| `Cancelled` | `3` |

## Generated Client Types

For a fallible method in a service definition:
```rust
#[roam::service]
trait MyService {
    async fn get_user(&self, id: UserId) -> Result<User, UserError>;
}
```

the generated client has:
```rust
impl MyServiceClient {
    async fn get_user(&self, id: UserId) -> Result<User, RoamError<UserError>>;
}
```

Callers can distinguish application errors from protocol errors:
```rust
match client.get_user(id).await {
    Ok(user) => { /* success */ }
    Err(RoamError::User(e)) => { /* application error: e */ }
    Err(RoamError::UnknownMethod) => { /* protocol version mismatch? */ }
    Err(RoamError::Cancelled) => { /* we or they cancelled */ }
    // ...
}
```

For an infallible method:
```rust
#[roam::service]
trait HealthService {
    async fn ping(&self) -> Pong;
}
```

the generated client has:
```rust
impl HealthServiceClient {
    async fn ping(&self) -> Result<Pong, RoamError<core::convert::Infallible>>;
}
```

### Protocol mismatch diagnostics

> rs[client.protocol-mismatch.diagnostics]
>
> Generated Rust clients MUST provide transparent protocol-mismatch
> diagnostics on `RoamError::UnknownMethod` and `RoamError::InvalidPayload`.
> This can involve additional RPC exchanges (for example, introspection calls
> to discover available methods/signatures) before surfacing the final error.

> rs[client.protocol-mismatch.best-effort]
>
> Diagnostic enrichment is best-effort. If the peer does not support
> introspection, or diagnostic lookup fails, the client MUST still return the
> original protocol error.
