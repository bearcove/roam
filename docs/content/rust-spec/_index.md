+++
title = "Rapace Rust Implementation Specification"
description = "Implementation details specific to the Rust implementation"
+++

# Introduction

This document specifies implementation details for the Rust implementation of
Rapace. These details are NOT required for implementations in other languages
— Swift, TypeScript, etc. get their types and method identities from code
generated by the Rust proto crate.

# Method Identity

Every method has a unique 64-bit identifier computed from its service name,
method name, and signature.

> r[method.identity.computation]
>
> The method ID MUST be computed as:
> ```
> method_id = blake3(kebab(ServiceName) + "." + kebab(methodName) + sig_bytes)[0..8]
> ```
> Where:
> - `kebab()` converts to kebab-case (e.g. `TemplateHost` → `template-host`)
> - `sig_bytes` is the BLAKE3 hash of the method's argument and return types
> - `[0..8]` takes the first 8 bytes as a u64

This means:
- Renaming a service or method changes the ID (breaking change)
- Changing the signature changes the ID (breaking change)
- Case variations normalize to the same ID (`loadTemplate` = `load_template`)

# Signature Hash

The `sig_bytes` used in method identity is a BLAKE3 hash of the method's
structural signature. This is computed at compile time by the `#[rapace::service]`
macro using [facet](https://facet.rs) type introspection.

> r[signature.hash.algorithm]
>
> The signature hash MUST be computed by hashing a canonical byte
> representation of the method signature using BLAKE3.

The canonical representation is built by concatenating type descriptors for
each argument (in order) followed by the return type. Each type is encoded
recursively as follows:

## Primitive Types

> r[signature.primitive]
>
> Primitive types MUST be encoded as a single byte tag:

| Type | Tag |
|------|-----|
| `bool` | `0x01` |
| `u8` | `0x02` |
| `u16` | `0x03` |
| `u32` | `0x04` |
| `u64` | `0x05` |
| `u128` | `0x06` |
| `i8` | `0x07` |
| `i16` | `0x08` |
| `i32` | `0x09` |
| `i64` | `0x0A` |
| `i128` | `0x0B` |
| `f32` | `0x0C` |
| `f64` | `0x0D` |
| `char` | `0x0E` |
| `String` | `0x0F` |
| `()` (unit) | `0x10` |
| `bytes` | `0x11` |

## Container Types

> r[signature.container]
>
> Container types MUST be encoded as a tag byte followed by their element type(s):

| Type | Tag | Encoding |
|------|-----|----------|
| List | `0x20` | tag + encode(element) |
| Option | `0x21` | tag + encode(inner) |
| Array | `0x22` | tag + varint(len) + encode(element) |
| Map | `0x23` | tag + encode(key) + encode(value) |
| Set | `0x24` | tag + encode(element) |
| Tuple | `0x25` | tag + varint(len) + encode(T1) + encode(T2) + ... |

Note: These are wire-format types, not Rust types. `Vec`, `VecDeque`, and
`LinkedList` all encode as List. `HashMap` and `BTreeMap` both encode as Map.

## Struct Types

> r[signature.struct]
>
> Struct types MUST be encoded as:
> ```
> 0x30 + varint(field_count) + (field_name + field_type)*
> ```
> Where each `field_name` is encoded as `varint(len) + utf8_bytes`.
> Fields MUST be encoded in declaration order.

Note: The struct's *name* is NOT included — only field names and types.
This allows renaming types without breaking compatibility.

## Enum Types

> r[signature.enum]
>
> Enum types MUST be encoded as:
> ```
> 0x31 + varint(variant_count) + (variant_name + variant_payload)*
> ```
> Where each `variant_name` is encoded as `varint(len) + utf8_bytes`.
> `variant_payload` is:
> - `0x00` for unit variants
> - `0x01` + encode(T) for newtype variants
> - `0x02` + struct encoding (without the 0x30 tag) for struct variants

Variants MUST be encoded in declaration order.

## Example

For a method:
```rust
async fn add(&self, a: i32, b: i32) -> i64;
```

The canonical bytes would be:
```
0x09          // a: i32
0x09          // b: i32
0x0A          // return: i64
```

BLAKE3 hash of these bytes gives `sig_bytes`.

# Introspection Types

The `Diagnostic` service uses these types for introspection and debugging.

```rust
struct MethodDetail {
    service_name: String,
    method_name: String,
    args: Vec<ArgDetail>,
    return_type: TypeDetail,
}

struct ArgDetail {
    name: String,
    type_info: TypeDetail,
}

struct ServiceSummary {
    name: String,
    method_count: u32,
    doc: Option<String>,
}

struct MethodSummary {
    name: String,
    method_id: u64,
    doc: Option<String>,
}

enum MismatchExplanation {
    /// Service doesn't exist
    UnknownService { closest: Option<String> },
    /// Service exists but method doesn't
    UnknownMethod { service: String, closest: Option<String> },
    /// Method exists but signature differs
    SignatureMismatch { 
        service: String,
        method: String,
        expected: MethodDetail,
    },
}
```

## TypeDetail

Describes a type's structure for introspection and diffing. This mirrors
the signature hash encoding but in a structured form.

```rust
enum TypeDetail {
    // Primitives
    Bool,
    U8, U16, U32, U64, U128,
    I8, I16, I32, I64, I128,
    F32, F64,
    Char,
    String,
    Unit,
    Bytes,
    
    // Containers (wire-format types, not Rust types)
    List(Box<TypeDetail>),
    Option(Box<TypeDetail>),
    Array { element: Box<TypeDetail>, len: u32 },
    Map { key: Box<TypeDetail>, value: Box<TypeDetail> },
    Set(Box<TypeDetail>),
    Tuple(Vec<TypeDetail>),
    
    // Composite
    Struct { fields: Vec<FieldDetail> },
    Enum { variants: Vec<VariantDetail> },
}

struct FieldDetail {
    name: String,
    type_info: TypeDetail,
}

struct VariantDetail {
    name: String,
    payload: VariantPayload,
}

enum VariantPayload {
    Unit,
    Newtype(TypeDetail),
    Struct(Vec<FieldDetail>),
}
```

## Usage

When `Diagnostic.explain_mismatch` returns `SignatureMismatch`, the client
can diff its local `MethodDetail` against the `expected` field to show
exactly where the types diverge:

```
Method `TemplateHost.load_template` signature mismatch:
  arg `context_id`: expected ContextId { id: u64 }
                        got ContextId { id: u32 }
                                           ^^^
```

# Error Handling

At the wire level, there are two kinds of responses:

1. **Method completed** — payload is the return value (whatever type that is)
2. **RPC error** — method didn't complete (not handled, timeout, cancelled, etc.)

Application-level errors (e.g., "user not found") are part of the return value,
not RPC errors. A method that returns `Result<User, UserError>` and returns
`Err(UserError::NotFound)` is a successful RPC — the method ran and returned
a value.

## Response Flattening

By default, calling a method that returns `Result<T, E>` gives you:

```rust
// Method: async fn load(&self, id: u64) -> Result<Template, LoadError>;
let result: Result<Result<Template, LoadError>, RpcError> = client.load(42).await;
```

With `#[flatten_response]` on the method (requires `LoadError: From<RpcError>`):

```rust
#[rapace::service]
pub trait Templates {
    #[flatten_response]
    async fn load(&self, id: u64) -> Result<Template, LoadError>;
}

// Now:
let result: Result<Template, LoadError> = client.load(42).await;
```

The RPC error is converted via `From<RpcError>` and merged into the
application error type. This is purely a codegen convenience — on the wire,
the distinction between "method returned error" and "RPC failed" is preserved.
