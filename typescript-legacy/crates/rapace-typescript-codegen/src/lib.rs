//! TypeScript code generator for rapace services.
//!
//! This crate generates TypeScript client code from rapace service definitions
//! using facet's Shape introspection.
//!
//! # Usage
//!
//! ```ignore
//! use rapace_typescript_codegen::TypeScriptCodegen;
//! use rapace::registry::ServiceRegistry;
//!
//! // Register your services first
//! ServiceRegistry::with_global_mut(|registry| {
//!     my_proto::my_service_register(registry);
//! });
//!
//! // Generate TypeScript code
//! let mut codegen = TypeScriptCodegen::new();
//! ServiceRegistry::with_global(|registry| {
//!     codegen.generate_from_registry(registry);
//! });
//!
//! // Write to file
//! std::fs::write("Generated.ts", codegen.output()).unwrap();
//! ```

use facet_core::{Def, ScalarType, Shape, StructKind, Type, UserType};
use rapace::registry::{MethodEntry, ServiceEntry, ServiceRegistry};
use std::collections::HashSet;
use std::fmt::Write;

/// TypeScript code generator for rapace services.
pub struct TypeScriptCodegen {
    output: String,
    generated_types: HashSet<&'static str>,
    indent: usize,
}

impl TypeScriptCodegen {
    /// Create a new TypeScript codegen instance.
    pub fn new() -> Self {
        Self {
            output: String::new(),
            generated_types: HashSet::new(),
            indent: 0,
        }
    }

    /// Get the generated TypeScript code.
    pub fn output(&self) -> &str {
        &self.output
    }

    /// Consume and return the generated TypeScript code.
    pub fn into_output(self) -> String {
        self.output
    }

    /// Generate TypeScript code from the service registry.
    pub fn generate_from_registry(&mut self, registry: &ServiceRegistry) {
        self.write_header();

        // First pass: collect all types that need to be generated
        let mut types_to_generate: Vec<&'static Shape> = Vec::new();
        for service in registry.services() {
            for method in service.iter_methods() {
                self.collect_types(method.request_shape, &mut types_to_generate);
                self.collect_types(method.response_shape, &mut types_to_generate);
            }
        }

        // Generate types in dependency order (simple types first)
        self.writeln("// Types\n");
        for shape in types_to_generate {
            self.generate_type(shape);
        }

        // Generate client classes
        self.writeln("\n// Clients\n");
        for service in registry.services() {
            self.generate_client(service);
        }
    }

    fn write_header(&mut self) {
        self.writeln("// Generated by rapace-typescript-codegen");
        self.writeln("// DO NOT EDIT");
        self.writeln("");
        self.writeln("import {");
        self.indent += 1;
        self.writeln("RapaceClient,");
        self.writeln("PostcardEncoder,");
        self.writeln("PostcardDecoder,");
        self.writeln("computeMethodId,");
        self.indent -= 1;
        self.writeln("} from \"rapace\";");
        self.writeln("");
    }

    fn collect_types(&mut self, shape: &'static Shape, types: &mut Vec<&'static Shape>) {
        // Skip if already collected
        if self.generated_types.contains(shape.type_identifier) {
            return;
        }

        // Handle tuple types (collect inner types but don't generate the tuple itself)
        if shape.type_identifier.starts_with('(') {
            if let Type::User(UserType::Struct(s)) = &shape.ty {
                for field in s.fields.iter() {
                    self.collect_types(field.shape(), types);
                }
            }
            return;
        }

        // Check if this is a type we need to generate
        match &shape.ty {
            Type::User(UserType::Struct(_)) | Type::User(UserType::Enum(_)) => {
                // Recursively collect nested types first
                self.collect_nested_types(shape, types);

                // Then add this type
                if !self.generated_types.contains(shape.type_identifier) {
                    self.generated_types.insert(shape.type_identifier);
                    types.push(shape);
                }
            }
            _ => {
                // For container types, collect inner types
                self.collect_nested_types(shape, types);
            }
        }
    }

    fn collect_nested_types(&mut self, shape: &'static Shape, types: &mut Vec<&'static Shape>) {
        match &shape.def {
            Def::Option(opt) => self.collect_types(opt.t(), types),
            Def::List(list) => self.collect_types(list.t(), types),
            Def::Map(map) => {
                self.collect_types(map.k(), types);
                self.collect_types(map.v(), types);
            }
            Def::Array(arr) => self.collect_types(arr.t(), types),
            Def::Result(res) => {
                self.collect_types(res.t(), types);
                self.collect_types(res.e(), types);
            }
            _ => {}
        }

        // Also check struct/enum fields
        match &shape.ty {
            Type::User(UserType::Struct(s)) => {
                for field in s.fields.iter() {
                    self.collect_types(field.shape(), types);
                }
            }
            Type::User(UserType::Enum(e)) => {
                for variant in e.variants.iter() {
                    for field in variant.data.fields.iter() {
                        self.collect_types(field.shape(), types);
                    }
                }
            }
            _ => {}
        }
    }

    fn generate_type(&mut self, shape: &'static Shape) {
        // Skip unit type
        if shape.type_identifier == "()" {
            return;
        }

        // Skip tuple types (they start with '(')
        if shape.type_identifier.starts_with('(') {
            return;
        }

        match &shape.ty {
            Type::User(UserType::Struct(struct_type)) => {
                self.generate_struct(shape.type_identifier, struct_type);
            }
            Type::User(UserType::Enum(enum_type)) => {
                self.generate_enum(shape.type_identifier, enum_type);
            }
            _ => {}
        }
    }

    fn generate_struct(&mut self, name: &str, struct_type: &facet_core::StructType) {
        let ts_name = clean_type_name(name);

        self.writeln(&format!("export interface {} {{", ts_name));
        self.indent += 1;

        // Generate fields
        for field in struct_type.fields.iter() {
            let ts_type = self.shape_to_ts_type(field.shape());
            self.writeln(&format!("{}: {};", field.name, ts_type));
        }

        self.indent -= 1;
        self.writeln("}");
        self.writeln("");

        // Generate encoder function
        self.writeln(&format!(
            "export function encode{}(encoder: PostcardEncoder, value: {}): void {{",
            ts_name, ts_name
        ));
        self.indent += 1;
        for field in struct_type.fields.iter() {
            self.generate_encode_field(&format!("value.{}", field.name), field.shape());
        }
        self.indent -= 1;
        self.writeln("}");
        self.writeln("");

        // Generate decoder function
        self.writeln(&format!(
            "export function decode{}(decoder: PostcardDecoder): {} {{",
            ts_name, ts_name
        ));
        self.indent += 1;
        self.writeln("return {");
        self.indent += 1;
        for field in struct_type.fields.iter() {
            let decode_expr = self.generate_decode_expr(field.shape());
            self.writeln(&format!("{}: {},", field.name, decode_expr));
        }
        self.indent -= 1;
        self.writeln("};");
        self.indent -= 1;
        self.writeln("}");
        self.writeln("");
    }

    fn generate_enum(&mut self, name: &str, enum_type: &facet_core::EnumType) {
        let ts_name = clean_type_name(name);

        // Generate discriminated union type
        let variants: Vec<String> = enum_type
            .variants
            .iter()
            .map(|v| {
                if v.data.fields.is_empty() {
                    format!("{{ type: \"{}\" }}", to_camel_case(v.name))
                } else if v.data.kind == StructKind::Tuple && v.data.fields.len() == 1 {
                    let field = &v.data.fields[0];
                    format!(
                        "{{ type: \"{}\"; value: {} }}",
                        to_camel_case(v.name),
                        self.shape_to_ts_type(field.shape())
                    )
                } else {
                    let fields: Vec<String> = v
                        .data
                        .fields
                        .iter()
                        .map(|f| format!("{}: {}", f.name, self.shape_to_ts_type(f.shape())))
                        .collect();
                    format!(
                        "{{ type: \"{}\"; {} }}",
                        to_camel_case(v.name),
                        fields.join("; ")
                    )
                }
            })
            .collect();

        self.writeln(&format!("export type {} =", ts_name));
        self.indent += 1;
        for (i, variant) in variants.iter().enumerate() {
            let suffix = if i < variants.len() - 1 { " |" } else { ";" };
            self.writeln(&format!("{}{}", variant, suffix));
        }
        self.indent -= 1;
        self.writeln("");

        // Generate encoder function
        self.writeln(&format!(
            "export function encode{}(encoder: PostcardEncoder, value: {}): void {{",
            ts_name, ts_name
        ));
        self.indent += 1;
        self.writeln("switch (value.type) {");
        self.indent += 1;
        for (idx, variant) in enum_type.variants.iter().enumerate() {
            let case_name = to_camel_case(variant.name);
            self.writeln(&format!("case \"{}\":", case_name));
            self.indent += 1;
            self.writeln(&format!("encoder.enumDiscriminant({});", idx));
            if variant.data.kind == StructKind::Tuple && variant.data.fields.len() == 1 {
                let field = &variant.data.fields[0];
                self.generate_encode_field("value.value", field.shape());
            } else {
                for field in variant.data.fields.iter() {
                    self.generate_encode_field(&format!("value.{}", field.name), field.shape());
                }
            }
            self.writeln("break;");
            self.indent -= 1;
        }
        self.indent -= 1;
        self.writeln("}");
        self.indent -= 1;
        self.writeln("}");
        self.writeln("");

        // Generate decoder function
        self.writeln(&format!(
            "export function decode{}(decoder: PostcardDecoder): {} {{",
            ts_name, ts_name
        ));
        self.indent += 1;
        self.writeln("const discriminant = decoder.enumDiscriminant();");
        self.writeln("switch (discriminant) {");
        self.indent += 1;
        for (idx, variant) in enum_type.variants.iter().enumerate() {
            let case_name = to_camel_case(variant.name);
            self.writeln(&format!("case {}:", idx));
            self.indent += 1;
            if variant.data.fields.is_empty() {
                self.writeln(&format!("return {{ type: \"{}\" }};", case_name));
            } else if variant.data.kind == StructKind::Tuple && variant.data.fields.len() == 1 {
                let field = &variant.data.fields[0];
                let decode_expr = self.generate_decode_expr(field.shape());
                self.writeln(&format!(
                    "return {{ type: \"{}\", value: {} }};",
                    case_name, decode_expr
                ));
            } else {
                self.writeln(&format!("return {{"));
                self.indent += 1;
                self.writeln(&format!("type: \"{}\",", case_name));
                for field in variant.data.fields.iter() {
                    let decode_expr = self.generate_decode_expr(field.shape());
                    self.writeln(&format!("{}: {},", field.name, decode_expr));
                }
                self.indent -= 1;
                self.writeln("};");
            }
            self.indent -= 1;
        }
        self.writeln("default:");
        self.indent += 1;
        self.writeln(&format!(
            "throw new Error(`Unknown {} discriminant: ${{discriminant}}`);",
            ts_name
        ));
        self.indent -= 1;
        self.indent -= 1;
        self.writeln("}");
        self.indent -= 1;
        self.writeln("}");
        self.writeln("");
    }

    fn generate_encode_field(&mut self, expr: &str, shape: &'static Shape) {
        // Handle container types
        match &shape.def {
            Def::Option(opt) => {
                let inner_encode = self.generate_encode_expr_inline("v", opt.t());
                self.writeln(&format!(
                    "encoder.option({}, (enc, v) => {{ {} }});",
                    expr, inner_encode
                ));
                return;
            }
            Def::List(list) => {
                let item_shape = list.t();
                if is_u8_type(item_shape) {
                    self.writeln(&format!("encoder.byteArray({});", expr));
                } else if is_string_type(item_shape) {
                    self.writeln(&format!("encoder.stringArray({});", expr));
                } else {
                    let inner_encode = self.generate_encode_expr_inline("v", item_shape);
                    self.writeln(&format!(
                        "encoder.array({}, (enc, v) => {{ {} }});",
                        expr, inner_encode
                    ));
                }
                return;
            }
            _ => {}
        }

        // Handle scalar types
        if let Some(scalar) = shape.scalar_type() {
            let method = scalar_to_ts_encode_method(scalar);
            self.writeln(&format!("encoder.{}({});", method, expr));
            return;
        }

        // Handle struct/enum types
        match &shape.ty {
            Type::User(UserType::Struct(_)) | Type::User(UserType::Enum(_)) => {
                let type_name = clean_type_name(shape.type_identifier);
                self.writeln(&format!("encode{}(encoder, {});", type_name, expr));
            }
            _ => {
                self.writeln(&format!("// TODO: encode {}", shape.type_identifier));
            }
        }
    }

    fn generate_encode_expr_inline(&self, expr: &str, shape: &'static Shape) -> String {
        // Handle scalar types
        if let Some(scalar) = shape.scalar_type() {
            let method = scalar_to_ts_encode_method(scalar);
            return format!("enc.{}({});", method, expr);
        }

        // Handle struct/enum types
        match &shape.ty {
            Type::User(UserType::Struct(_)) | Type::User(UserType::Enum(_)) => {
                let type_name = clean_type_name(shape.type_identifier);
                format!("encode{}(enc, {});", type_name, expr)
            }
            _ => format!("/* TODO: encode {} */", shape.type_identifier),
        }
    }

    fn generate_decode_expr(&self, shape: &'static Shape) -> String {
        // Handle unit type
        if shape.type_identifier == "()" {
            return "undefined".to_string();
        }

        // Handle container types
        match &shape.def {
            Def::Option(opt) => {
                let inner_decode = self.generate_decode_expr(opt.t());
                return format!("decoder.option((dec) => {})", inner_decode);
            }
            Def::List(list) => {
                let item_shape = list.t();
                if is_u8_type(item_shape) {
                    return "decoder.bytes()".to_string();
                } else if is_string_type(item_shape) {
                    return "decoder.stringArray()".to_string();
                } else {
                    let inner_decode = self.generate_decode_expr(item_shape);
                    return format!("decoder.array((dec) => {})", inner_decode);
                }
            }
            _ => {}
        }

        // Handle scalar types
        if let Some(scalar) = shape.scalar_type() {
            return scalar_to_ts_decode_method(scalar).to_string();
        }

        // Handle struct/enum types
        match &shape.ty {
            Type::User(UserType::Struct(_)) | Type::User(UserType::Enum(_)) => {
                let type_name = clean_type_name(shape.type_identifier);
                format!("decode{}(decoder)", type_name)
            }
            _ => format!("undefined /* TODO: decode {} */", shape.type_identifier),
        }
    }

    fn generate_client(&mut self, service: &ServiceEntry) {
        let class_name = format!("{}Client", service.name);

        self.writeln(&format!("export class {} {{", class_name));
        self.indent += 1;

        self.writeln("private client: RapaceClient;");
        self.writeln("");

        // Constructor
        self.writeln("constructor(client: RapaceClient) {");
        self.indent += 1;
        self.writeln("this.client = client;");
        self.indent -= 1;
        self.writeln("}");
        self.writeln("");

        // Static factory
        self.writeln(&format!(
            "static async connect(url: string): Promise<{}> {{",
            class_name
        ));
        self.indent += 1;
        self.writeln("const client = await RapaceClient.connect(url);");
        self.writeln(&format!("return new {}(client);", class_name));
        self.indent -= 1;
        self.writeln("}");
        self.writeln("");

        // Generate methods
        for method in service.iter_methods() {
            self.generate_method(service.name, method);
        }

        // Close method
        self.writeln("close(): void {");
        self.indent += 1;
        self.writeln("this.client.close();");
        self.indent -= 1;
        self.writeln("}");

        self.indent -= 1;
        self.writeln("}");
        self.writeln("");
    }

    fn generate_method(&mut self, service_name: &str, method: &MethodEntry) {
        let method_id = method.id.0;
        let response_type = self.shape_to_ts_type(method.response_shape);

        // Build parameter list
        let params = if method.args.is_empty() {
            String::new()
        } else if method.args.len() == 1 {
            let arg = &method.args[0];
            let ts_type = self.arg_type_to_ts(&arg.type_name);
            format!("{}: {}", arg.name, ts_type)
        } else {
            method
                .args
                .iter()
                .map(|arg| format!("{}: {}", arg.name, self.arg_type_to_ts(&arg.type_name)))
                .collect::<Vec<_>>()
                .join(", ")
        };

        if method.is_streaming {
            // Streaming method - TODO
            self.writeln(&format!("// TODO: Streaming method {}", method.name));
        } else {
            // Unary method
            self.writeln(&format!(
                "async {}({}): Promise<{}> {{",
                to_camel_case(method.name),
                params,
                response_type
            ));
            self.indent += 1;

            // Encode request
            self.writeln("const encoder = new PostcardEncoder();");

            if method.args.len() == 1 {
                // Single argument - encode it directly
                let arg = &method.args[0];
                self.generate_encode_field(arg.name, method.request_shape);
            } else if method.args.len() > 1 {
                // Multiple arguments - encode each
                for arg in &method.args {
                    self.writeln(&format!("encoder.u64({}); // TODO: proper encoding", arg.name));
                }
            }

            self.writeln("");
            self.writeln(&format!(
                "const response = await this.client.call(0x{:08X}, encoder.bytes);",
                method_id
            ));
            self.writeln("const decoder = new PostcardDecoder(response);");
            let decode_expr = self.generate_decode_expr(method.response_shape);
            self.writeln(&format!("return {};", decode_expr));

            self.indent -= 1;
            self.writeln("}");
        }
        self.writeln("");
    }

    fn shape_to_ts_type(&self, shape: &'static Shape) -> String {
        // Handle unit type
        if shape.type_identifier == "()" {
            return "void".to_string();
        }

        // Handle container types
        match &shape.def {
            Def::Option(opt) => {
                return format!("{} | null", self.shape_to_ts_type(opt.t()));
            }
            Def::List(list) => {
                let item_type = self.shape_to_ts_type(list.t());
                if is_u8_type(list.t()) {
                    return "Uint8Array".to_string();
                }
                return format!("{}[]", item_type);
            }
            Def::Map(map) => {
                return format!(
                    "Map<{}, {}>",
                    self.shape_to_ts_type(map.k()),
                    self.shape_to_ts_type(map.v())
                );
            }
            Def::Array(arr) => {
                return format!("{}[]", self.shape_to_ts_type(arr.t()));
            }
            Def::Result(res) => {
                return format!(
                    "{{ ok: true; value: {} }} | {{ ok: false; error: {} }}",
                    self.shape_to_ts_type(res.t()),
                    self.shape_to_ts_type(res.e())
                );
            }
            _ => {}
        }

        // Handle scalar types
        if let Some(scalar) = shape.scalar_type() {
            return scalar_to_ts_type(scalar).to_string();
        }

        // Handle user types
        match &shape.ty {
            Type::User(UserType::Struct(_)) | Type::User(UserType::Enum(_)) => {
                clean_type_name(shape.type_identifier)
            }
            _ => "unknown".to_string(),
        }
    }

    fn arg_type_to_ts(&self, rust_type: &str) -> String {
        match rust_type {
            "String" | "&str" => "string".to_string(),
            "bool" => "boolean".to_string(),
            "i8" | "i16" | "i32" | "u8" | "u16" | "u32" | "f32" | "f64" => "number".to_string(),
            "i64" | "u64" => "bigint".to_string(),
            "ItemId" => "bigint".to_string(),
            _ => {
                if rust_type.starts_with("Vec<") && rust_type.ends_with('>') {
                    let inner = &rust_type[4..rust_type.len() - 1].trim();
                    if *inner == "u8" {
                        return "Uint8Array".to_string();
                    }
                    return format!("{}[]", self.arg_type_to_ts(inner));
                }
                if rust_type.starts_with("Option<") && rust_type.ends_with('>') {
                    let inner = &rust_type[7..rust_type.len() - 1].trim();
                    return format!("{} | null", self.arg_type_to_ts(inner));
                }
                clean_type_name(rust_type)
            }
        }
    }

    fn writeln(&mut self, line: &str) {
        let indent = "  ".repeat(self.indent);
        writeln!(self.output, "{}{}", indent, line).unwrap();
    }
}

impl Default for TypeScriptCodegen {
    fn default() -> Self {
        Self::new()
    }
}

// Helper functions

fn clean_type_name(name: &str) -> String {
    name.rsplit("::").next().unwrap_or(name).to_string()
}

fn to_camel_case(name: &str) -> String {
    let mut result = String::new();
    let mut capitalize_next = false;

    for (i, c) in name.chars().enumerate() {
        if c == '_' {
            capitalize_next = true;
        } else if capitalize_next {
            result.push(c.to_ascii_uppercase());
            capitalize_next = false;
        } else if i == 0 {
            result.push(c.to_ascii_lowercase());
        } else {
            result.push(c);
        }
    }

    result
}

fn scalar_to_ts_type(scalar: ScalarType) -> &'static str {
    match scalar {
        ScalarType::String | ScalarType::Str | ScalarType::CowStr => "string",
        ScalarType::Bool => "boolean",
        ScalarType::Char => "string",
        ScalarType::I8 | ScalarType::I16 | ScalarType::I32 => "number",
        ScalarType::U8 | ScalarType::U16 | ScalarType::U32 => "number",
        ScalarType::F32 | ScalarType::F64 => "number",
        ScalarType::I64 | ScalarType::I128 | ScalarType::ISize => "bigint",
        ScalarType::U64 | ScalarType::U128 | ScalarType::USize => "bigint",
        _ => "unknown",
    }
}

fn scalar_to_ts_encode_method(scalar: ScalarType) -> &'static str {
    match scalar {
        ScalarType::String | ScalarType::Str | ScalarType::CowStr => "string",
        ScalarType::Bool => "bool",
        ScalarType::I8 => "i8",
        ScalarType::I16 => "i16",
        ScalarType::I32 => "i32",
        ScalarType::I64 => "i64",
        ScalarType::U8 => "u8",
        ScalarType::U16 => "u16",
        ScalarType::U32 => "u32",
        ScalarType::U64 => "u64",
        ScalarType::F32 => "f32",
        ScalarType::F64 => "f64",
        _ => "u8", // fallback
    }
}

fn scalar_to_ts_decode_method(scalar: ScalarType) -> &'static str {
    match scalar {
        ScalarType::String | ScalarType::Str | ScalarType::CowStr => "decoder.string()",
        ScalarType::Bool => "decoder.bool()",
        ScalarType::I8 => "decoder.i8()",
        ScalarType::I16 => "decoder.i16()",
        ScalarType::I32 => "decoder.i32()",
        ScalarType::I64 => "decoder.i64()",
        ScalarType::U8 => "decoder.u8()",
        ScalarType::U16 => "decoder.u16()",
        ScalarType::U32 => "decoder.u32()",
        ScalarType::U64 => "decoder.u64()",
        ScalarType::F32 => "decoder.f32()",
        ScalarType::F64 => "decoder.f64()",
        _ => "decoder.u8()", // fallback
    }
}

fn is_string_type(shape: &Shape) -> bool {
    matches!(
        shape.scalar_type(),
        Some(ScalarType::String | ScalarType::Str | ScalarType::CowStr)
    )
}

fn is_u8_type(shape: &Shape) -> bool {
    matches!(shape.scalar_type(), Some(ScalarType::U8))
}
